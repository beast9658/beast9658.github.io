{"title":"Antd Form.List实现自定义可编辑表格","uid":"679a9e76b771c60b95232fe737f13603","slug":"Antd Form.List实现自定义可编辑表格","date":"2021-07-25T13:39:19.000Z","updated":"2023-04-21T08:40:34.113Z","comments":true,"path":"api/articles/Antd Form.List实现自定义可编辑表格.json","keywords":null,"cover":[],"content":"<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/028c842058ce46ddb9fbf0fed268539f~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"Antd Form.List实现自定义可编辑表格\"></p>\n<h3 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h3><p>定制化较深的需求，往往需要可编辑表格来支持表格内的编辑，但是针对必填项校验以及自定义action动作，常规的EditableTable难以满足需要，而EditableProTable则因为定制化太深而不够灵活，所以我们需要更加灵活的方案来实现我们需要的效果，经试验，Form.List是个不错的实现思路。</p>\n<h3 id=\"二、针对需求\"><a href=\"#二、针对需求\" class=\"headerlink\" title=\"二、针对需求\"></a>二、针对需求</h3><ol>\n<li>表格内编辑</li>\n<li>动态新增行（自定义action按钮动作）</li>\n<li>最小维度为行的必填项校验</li>\n<li>灵活可扩展</li>\n</ol>\n<h3 id=\"三、实现方法\"><a href=\"#三、实现方法\" class=\"headerlink\" title=\"三、实现方法\"></a>三、实现方法</h3><ol>\n<li>尝试 在项目中，我碰到这样的需求，需要表格可编辑，且初始默认一行可编辑状态数据，点击行最后一列的add进行必填项校验，校验完成新增一行且把已编辑完的数据置为不可编辑状态，起初考虑的实现方式很简单，在外层包一个Form，columns里面的项再包裹Form.Item，至于是否可编辑状态，给表格的数据源加入一个editable字段用于判断是否编辑就行了，本以为这个方案可行，但实际上问题很多，如果要针对行进行校验，那显然每一个行都要和Form利用Form.Item的name属性进行绑定，这时候name是啥呢，没有层级划分，如果你给name的值单单为数据的字段名，那添加一行后下一行岂不是和第一行的name重复了？这会导致新增一行有初始数据，且初始数据是上一行已保存的数据，至于校验，每次新增行调用form.submit可以实现行的校验，但显然这种方案是不可行的。</li>\n</ol>\n<p>意识到要让行数据对应Form的标志唯一，那么就考虑使用Form.List实现。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c55973895214035bd417eb514c1a2c5~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li>Form.List</li>\n</ol>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aefdb4a5f36b418495bd01695bd3b0ea~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>Form.List的基本用法参考antd官方文档，可见这个元素就是为了解决标志重复的问题而生的，它对初始的数组数据又做多了一层映射，这层映射对应一个数组，而数组内的元素则是存有原数据数组下标的对象。多说无益，看图。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a884bbe13984e62afea6f1ed9895ea8~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>有了这层映射，我们Form.Item的name便有了每行唯一的上级，于是我们就可以将表头配置的columns写成如下的形式。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">render: (text, record) &#x3D;&gt; &#123;\n        paidDetails[record.name])\n        return paidDetails[record.name]?.editable ?\n          &lt;Form.Item\n            rules&#x3D;&#123;[&#123; required: true, message: undefined &#125;]&#125;\n            name&#x3D;&#123;[record.name, &#39;paymentTerm&#39;]&#125;\n            fieldKey&#x3D;&#123;[record.fieldKey, &#39;paymentTerm&#39;]&#125;\n            style&#x3D;&#123;&#123; marginBottom: &#39;0px&#39; &#125;&#125;\n          &gt;\n            &lt;Select placeholder&#x3D;&#123;&#39;Please enter&#39;&#125; style&#x3D;&#123;&#123; width: 200 &#125;&#125; &gt;\n              &#123;\n                paymentTremOptions &amp;&amp; paymentTremOptions.map((item) &#x3D;&gt; &#123;\n                  return &lt;Option value&#x3D;&#123;item.value&#125; key&#x3D;&#123;item.value&#125;&gt;&#123;item.label&#125;&lt;&#x2F;Option&gt;\n                &#125;)\n              &#125;\n            &lt;&#x2F;Select&gt;\n          &lt;&#x2F;Form.Item&gt;\n          :                     (paymentTremOptions[paidDetails[record.name]?.paymentTerm - 1]?.label || &#39;-&#39;)\n          &#125;\n复制代码</code></pre>\n\n<p>到了这一步，本以为基本上顺利完成了，但是还是有些意想不到的问题，要实现校验后添加一行，利用Form.List本身的add根本不现实，因为我们还需要新添加的行可编辑而已校验的行不可编辑，也就是说要更改每行数据的editable字段，所以自然而然想到这里我们必须自定义新增行了。</p>\n<p>然而一波未平一波又起，问题还是不断出现，以下是我整理的会遇到的细节问题：</p>\n<ul>\n<li>columns内add动作调用form.submit进行校验，外层在Form的onFinish对状态数据进行处理（不可行，更新状态数据成功了，而fields还是不变，导致新增行失败）</li>\n<li>既然fields不变，那每次进行判断fields长度与状态数据是否不匹配，然后再增加或减少一个数据（仍旧不可行，新增确实成功了，但是删除的时候会碰到特殊情况，比如删除最后一个直接报错，应该是手动处理fields不完善导致的，没有继续深究原因，但显然这条路走不通，fields既然是Form.Item内部维护的数据，那就不该由开发者手动去操作，否则会出现各种各样的问题）</li>\n</ul>\n<ol start=\"3\">\n<li>最终实现</li>\n</ol>\n<p>最终问题在自定义add上，fields不能手动更改，但肯定有更改的方法，唯一能想到的途经就是通过form了，想想也是，我们给form添加初始值也不能直接更新状态数据就实现啊，都是利用setFieldsValue的，所以改用setFieldsValue后果然实现了。 还有一点，每次表格内行编辑完的数据如何保存，通过setFieldsValue只能新增行，但是行内的数据会丢失，丢失的原因很简单，我们在编辑的时候虽然Form临时保存了数据，但是添加行后，因为所有行的编辑状态会重新判断，所以表格会重新render，我们在编辑时又没有实时将变化更新到状态数据，而Form又拿状态数据作为初始值，自然导致重新render后行数和编辑状态都对了但是每行的字段数据却丢失了，知道问题，解决起来就很简单了，在setFieldsValue的同时也将数据更新到状态就可以了。</p>\n<p>这些处理完后，接下来的问题就是何时进行校验何时进行新增，如果要在校验之后进行新增，那如何做到呢？方法不止一个，我们点击add的时候触发form.submit，就能在触发Form的onFinish之前进行校验，然后在onFinish内更新状态数据同时调用setFieldsValue更新表单数据就行了。 另一种方法也类似，无非是 把动作再做拆分，先利用 form.validateFields做校验，然后在其链式调用then中进行更新状态数据同时调用setFieldsValue更新表单数据就可以了。</p>\n<p>添加实现了接下来就是删除，删除也很简单，不用进行校验，根据唯一标识过滤即可。</p>\n<h3 id=\"四、实现代码\"><a href=\"#四、实现代码\" class=\"headerlink\" title=\"四、实现代码\"></a>四、实现代码</h3><ol>\n<li>页面</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> &lt;Form form&#x3D;&#123;form&#125; initialValues&#x3D;&#123;&#123; table: paidDetails &#125;&#125; onFinish&#x3D;&#123;(data) &#x3D;&gt; &#123;\n            setPaidDetails(data.table)\n          &#125;&#125;&gt;\n            &lt;Form.List name&#x3D;&quot;table&quot;&gt;\n              &#123;(fields) &#x3D;&gt; &#123;\n                console.log(fields,&#39;fields&#39;)\n                return (\n                  &lt;div&gt;\n                    &lt;Table\n                      className&#x3D;&#123;&#96;xp-table x-table-large $&#123;styles.paidDetailTable&#125;&#96;&#125;\n                      scroll&#x3D;&#123;&#123; scrollToFirstRowOnChange: true, x: &#39;max-content&#39; &#125;&#125;\n                      dataSource&#x3D;&#123;fields&#125;\n                      rowKey&#x3D;&#123;&#39;id&#39;&#125;\n                      pagination&#x3D;&#123;false&#125;\n                      columns&#x3D;&#123;PaidDetailColumns(paidDetails, setPaidDetails, form, formatMessage)&#125;\n                    &#x2F;&gt;\n                  &lt;&#x2F;div&gt;\n                );\n              &#125;\n              &#125;\n            &lt;&#x2F;Form.List&gt;\n          &lt;&#x2F;Form&gt;\n复制代码</code></pre>\n\n<ol start=\"2\">\n<li>columns</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">export const PaidDetailColumns &#x3D; (\n  paidDetails,\n  setPaidDetails,\n  form,\n  formatMessage\n) &#x3D;&gt; &#123;\n  const columnsList &#x3D; [    &#123;      title: formatMessage(&#123; id: &#39;app.No&#39; &#125;),      render: (_, record, index) &#x3D;&gt; &#123;        return index + 1      &#125;    &#125;,    &#123;      title: formatMessage(&#123; id: &#39;repairSettlement.paymentTerm&#39; &#125;),      dataIndex: &#39;paymentTerm&#39;,      render: (text, record) &#x3D;&gt; &#123;        console.log(record, paymentTremOptions, paidDetails[record.name])\n        return paidDetails[record.name]?.editable ?\n          &lt;Form.Item\n            rules&#x3D;&#123;[&#123; required: true, message: undefined &#125;]&#125;\n            name&#x3D;&#123;[record.name, &#39;paymentTerm&#39;]&#125;\n            fieldKey&#x3D;&#123;[record.fieldKey, &#39;paymentTerm&#39;]&#125;\n            style&#x3D;&#123;&#123; marginBottom: &#39;0px&#39; &#125;&#125;\n          &gt;\n            &lt;Select placeholder&#x3D;&#123;&#39;Please enter&#39;&#125; style&#x3D;&#123;&#123; width: 200 &#125;&#125; &gt;\n              &#123;\n                paymentTremOptions &amp;&amp; paymentTremOptions.map((item) &#x3D;&gt; &#123;\n                  return &lt;Option value&#x3D;&#123;item.value&#125; key&#x3D;&#123;item.value&#125;&gt;&#123;item.label&#125;&lt;&#x2F;Option&gt;\n                &#125;)\n              &#125;\n            &lt;&#x2F;Select&gt;\n          &lt;&#x2F;Form.Item&gt;\n          : (paymentTremOptions[paidDetails[record.name]?.paymentTerm - 1]?.label || &#39;-&#39;)\n      &#125;\n    &#125;,\n    &#123;\n      title: formatMessage(&#123; id: &#39;repairSettlement.paymentReceivedAmount&#39; &#125;),\n      dataIndex: &#39;receivableAmount&#39;,\n      render: (text, record) &#x3D;&gt; &#123;\n        return paidDetails[record.name]?.editable ?\n          &lt;Form.Item\n            rules&#x3D;&#123;[&#123; required: true, message: undefined &#125;]&#125;\n            name&#x3D;&#123;[record.name, &#39;receivableAmount&#39;]&#125;\n            fieldKey&#x3D;&#123;[record.fieldKey, &#39;receivableAmount&#39;]&#125;\n            style&#x3D;&#123;&#123; marginBottom: &#39;0px&#39; &#125;&#125;\n          &gt;\n            &lt;InputNumber placeholder&#x3D;&#123;&#39;Please enter&#39;&#125; style&#x3D;&#123;&#123; width: 200 &#125;&#125; &#x2F;&gt;\n          &lt;&#x2F;Form.Item&gt;\n          : (paidDetails[record.name]?.receivableAmount || &#39;-&#39;)\n      &#125;\n    &#125;,\n    &#123;\n      title: formatMessage(&#123; id: &#39;repairSettlement.remark&#39; &#125;),\n      dataIndex: &#39;remark&#39;,\n      render: (text, record) &#x3D;&gt; &#123;\n        return paidDetails[record.name]?.editable ?\n          &lt;Form.Item\n            name&#x3D;&#123;[record.name, &#39;remark&#39;]&#125;\n            fieldKey&#x3D;&#123;[record.fieldKey, &#39;remark&#39;]&#125;\n            style&#x3D;&#123;&#123; marginBottom: &#39;0px&#39; &#125;&#125;\n          &gt;\n            &lt;Input placeholder&#x3D;&#123;&#39;Please enter&#39;&#125; style&#x3D;&#123;&#123; width: 200 &#125;&#125; &#x2F;&gt;\n          &lt;&#x2F;Form.Item&gt;\n          : (paidDetails[record.name]?.remark || &#39;-&#39;)\n      &#125;\n    &#125;,\n    &#123;\n      title: formatMessage(&#123; id: &#39;app.action&#39; &#125;),\n      fixed: &#39;right&#39;,\n      render: (text, record, _) &#x3D;&gt; &#123;\n        return paidDetails[record.name]?.editable ?\n          &lt;a\n            key&#x3D;&quot;editable&quot;\n            onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n              form.validateFields().then(() &#x3D;&gt; &#123;\n                const list &#x3D; form.getFieldValue(&#39;table&#39;);\n                list.forEach((element: any, index: number) &#x3D;&gt; &#123;\n                  list[index].editable &#x3D; false\n                &#125;);\n                const nextList &#x3D; list.concat([&#123;                  editable: true,                  id: (Math.random() * 1000000).toFixed(0)                &#125;]);\n                console.log(nextList)\n                form.submit()\n                form.setFieldsValue(&#123;\n                  table: nextList,\n                &#125;);\n              &#125;)\n            &#125;&#125;\n          &gt;\n            &#123;formatMessage(&#123; id: &#39;app.add&#39; &#125;)&#125;\n          &lt;&#x2F;a&gt;\n          :\n          &lt;a\n            key&#x3D;&quot;editable&quot;\n            onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n              const list &#x3D; form.getFieldValue(&#39;table&#39;).filter((element: any, index: number) &#x3D;&gt; &#123;\n                return index !&#x3D;&#x3D; record.name\n              &#125;);\n              const nextList &#x3D; list.concat([]);\n              setPaidDetails(nextList)\n              form.setFieldsValue(&#123;\n                table: nextList,\n              &#125;);\n            &#125;&#125;\n          &gt;\n            &#123;formatMessage(&#123; id: &#39;app.remove&#39; &#125;)&#125;\n          &lt;&#x2F;a&gt;\n      &#125;\n\n    &#125;\n  ]\n  return columnsList\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"五、注意事项\"><a href=\"#五、注意事项\" class=\"headerlink\" title=\"五、注意事项\"></a>五、注意事项</h3><p>1、 注意回显form.setFieldsValue({table: 状态数据}) 这里table对应Form.List的标识, 需要回显的时候Form的initialValue就不需要了</p>\n","text":" 一、前言定制化较深的需求，往往需要可编辑表格来支持表格内的编辑，但是针对必填项校验以及自定义action动作，常规的EditableTable难以满足需要，而EditableProTable则因为定制化太深而不够灵活，所以我们需要更加灵活的方案来实现我们需要的效果，经试验，Fo...","link":"","photos":[],"count_time":{"symbolsCount":"9.4k","symbolsTime":"9 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">一、前言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E9%92%88%E5%AF%B9%E9%9C%80%E6%B1%82\"><span class=\"toc-text\">二、针对需求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">三、实现方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">四、实现代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">五、注意事项</span></a></li></ol>","author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"TypeScript，初次见面","uid":"1dcd3b31893419d8e8f3a54468e3f5d8","slug":"TypeScript，初次见面","date":"2021-08-03T11:45:38.000Z","updated":"2023-04-21T08:43:11.544Z","comments":true,"path":"api/articles/TypeScript，初次见面.json","keywords":null,"cover":[],"text":"为什么用 TS ?说实话，最开始并没有想把 TS 用到实际项目中来，一来是感觉“类型”会限制 JS 的优势（好吧，就是浪写浪惯了）；二来听闻 TS + Redux 的酸爽滋味，有点望而却步；三来 TS 环境使用的库需要加类型的声明，很多库并不支持，有点担心推进的流畅度 … 这个时...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"面试题笔记——VUE篇(下)","uid":"eb0bae97b5766c0795d8d777051a13ca","slug":"面试题笔记——VUE篇(下)","date":"2021-06-24T12:41:13.000Z","updated":"2023-04-21T08:36:21.355Z","comments":true,"path":"api/articles/面试题笔记——VUE篇(下).json","keywords":null,"cover":null,"text":"四、路由 Vue-Router 的懒加载如何实现非懒加载：import List from ‘@&#x2F;components&#x2F;list.vue’const router &#x3D; new VueRouter({ routes: [ { path: ‘&#x2F;...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}