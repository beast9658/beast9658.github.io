{"title":"TypeScript，初次见面","uid":"1dcd3b31893419d8e8f3a54468e3f5d8","slug":"TypeScript，初次见面","date":"2021-08-03T11:45:38.000Z","updated":"2023-04-21T08:43:11.544Z","comments":true,"path":"api/articles/TypeScript，初次见面.json","keywords":null,"cover":[],"content":"<h2 id=\"为什么用-TS\"><a href=\"#为什么用-TS\" class=\"headerlink\" title=\"为什么用 TS ?\"></a>为什么用 TS ?</h2><p>说实话，最开始并没有想把 TS 用到实际项目中来，一来是感觉“类型”会限制 JS 的优势（好吧，就是浪写浪惯了）；二来听闻 TS + Redux 的酸爽滋味，有点望而却步；三来 TS 环境使用的库需要加类型的声明，很多库并不支持，有点担心推进的流畅度 …</p>\n<p>这个时候，就需要有一股无形的力量推你一把。推我的是团队正在日益普及 TS, 我希望推动你的可以是这篇文章 ~</p>\n<p>接下来，会有 React + TS 的项目为背景，介绍我在初学 TS 开发项目中遇到的一些问题，希望对你有所帮助。</p>\n<h2 id=\"初学者的困惑\"><a href=\"#初学者的困惑\" class=\"headerlink\" title=\"初学者的困惑\"></a>初学者的困惑</h2><p><strong>一. 如何优雅的声明类型</strong></p>\n<ol>\n<li><strong>基础</strong></li>\n</ol>\n<p>不就是比 JS 多了一个类型声明吗？老夫撸起袖子拎起键盘就是一梭子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface Basic &#123;\n  num: number;\n  str: string | null;\n  bol?: boolean;\n&#125;</code></pre>\n\n<p>轻轻松松，五种 JS 值类型就声明好了。那数组、函数呢？再来：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface Func &#123;\n  func(str: string): void;\n&#125;\n\ninterface Arr &#123;\n  str: string[];\n  mixed: Array&lt;string | number&gt;;\n  fixedStructure: [string, number];\n  basics: Basic[];\n&#125;</code></pre>\n\n<p>除此之外，竟然还可以定义自己的类型呢，比如常用的回调函数，在声明处需要指定回调函数的类型：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">event.on(&#39;change&#39;, function() &#123;&#125;);</code></pre>\n\n<p>那这个 <code>on</code> 方法需要如何声明呢？试试看 <code>Function</code>当 cb 函数的类型呢</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">on(type: string, cb: Function): &#123;&#125;</code></pre>\n\n<p>然后就恭喜了，你会得到一个 tslint error :</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/473c0103e8c8494c99cd062438fb3f34~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>庆幸的是，在这个 error 里面它告诉了你应该怎么做：声明一个专用的函数类型就可以了：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type Cb &#x3D; () &#x3D;&gt; void;\n\non(type: string, cb: Cb);</code></pre>\n\n<p>至此，我们的 TS 人生算是起步了</p>\n<p>另外，枚举类型也是很常用的，比如声明一个状态机的各个状态：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">enum Status &#123;\n  Draft,\n  Published\n&#125;\n\n&#x2F;&#x2F; 也可指定值\nenum Status &#123;\n  Draft &#x3D; &#39;Draft&#39;,\n  Published &#x3D; &#39;Published&#39;\n&#125;</code></pre>\n\n<p>在使用枚举的时候，常会遇到如何将枚举和原始数据类型相互转换的需求，比如接口请求到的 status 是 <code>Draft</code> 字符串，但是代码中声明的 status 是 Enum 类型，如何转换呢？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; string to enum\nconst str &#x3D; &#39;Draft&#39;;\nconst status: Status &#x3D; Status[str];\n\n&#x2F;&#x2F; enum to string\nStatus[Status.Published] &#x3D;&#x3D;&#x3D; &#39;Published&#39;</code></pre>\n\n<p><strong>2. 糅合</strong></p>\n<p>独立的类型或接口声明看起来似乎并没有那么难，到项目中糅合一下呢？</p>\n<ul>\n<li>可能会有几十个类型声明；</li>\n<li>类型声明可能出现在<strong>接口入参出参</strong>中、<strong>React 组件的 Props 和 State</strong> 中、<strong>函数方法</strong>中；</li>\n<li>当项目到达一定规模，可以抽象出独立的库的时候，类型也需要抽象；</li>\n<li>…</li>\n</ul>\n<p>你可能遇到各种情况，会打破你对 TS 的掌控。如何是好？</p>\n<p>先说我们实践下来的结论：<strong>独立声明</strong>、<strong>就近声明</strong>、<strong>按职责分组</strong>、<strong>杜绝“硬凑”关联</strong>、<strong>有限抽象。</strong></p>\n<p><strong>- 独立声明</strong></p>\n<p>一个 ts 文件只声明一个类型或者接口，文件名为需要暴露的类型名称，方便检索和管理。</p>\n<p><strong>- 就近声明</strong></p>\n<p>当一个声明没有被外部引用或者依赖时，可以考虑就近放在使用的地方，典型的场景是 React 组件的 Props 和 State 的类型声明。</p>\n<p><strong>- 按职责分组</strong></p>\n<p>在项目中，需要声明类型的可大致分为两类：一类是 model，也就是接口请求相关的，包括入参和出参；另一类是 view，界面渲染相关的。因此，我在 <strong>独立声明</strong> 的基础上，可以类型按照model 和 view 的维度进行分组，相互独立。</p>\n<p>那么问题来了，如果是独立的类型声明的话，怎么把 model 的数据应用到 view 呢？ 可能你需要一个 adapter 来做类型的的转换：DTOTypes -&gt; adapter -&gt; ViewTypes, 完成类似于<strong>将接口中的字符串映射成枚举类型</strong>这之类的转换。</p>\n<p><strong>- 杜绝“硬凑”关联</strong></p>\n<p>不要硬凑两个接口或者类型的关系，比如一个接口的创建和更新，可能字段都是一样，区别是一个有 id 另一个没有，于是我们可能就想着写一个类型然后 id 可选就好了。这样是少写了一个类型，但是可能会带来另外一些麻烦，比如带 id 的数据传给了新建的接口，但是 ts 检查不出来。所以，建议不要怕麻烦，直接拆分成 <code>CreateInputDTO</code> 和 <code>UpdateInputDTO</code>.</p>\n<p><strong>- 有限抽象</strong></p>\n<p>在<strong>杜绝“硬凑”关联</strong>的基础上，我们可以抽象出通用的声明。</p>\n<p>基于上述原则，解决了我作为一个初学者在类型声明上的困扰，如有不对的或者更好的建议，欢迎指正~</p>\n<p><strong>3. 万能药膏 any</strong></p>\n<p>不是所有的类型声明都能一马平川的，当遇到确实解决不了的类型报错的时候，<code>as any</code> 能带给你不一样的快感，但是不建议使用啊…</p>\n<p><strong>二. 如何引用外部库</strong></p>\n<p>接下来聊聊第三方库在 TS 环境下的使用。</p>\n<p>在 JS 中，npm 上有丰富的海量的库帮我们完成日常的编码，可能并不是所有的库都能完全被应用到 TS 中，因为有些缺少类型声明。</p>\n<p>比如，在 TS 中使用 <code>react</code> , 你会得到这样的一个类型检查错误：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e41022927f714442969f5f0d519d2e84~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>因为 react 的库中并没有类型声明。</p>\n<p>现在比较通用的做法是，能力实现和类型实现独立成两个库，也就是你需要再安装类型声明的库: <code>@types/react</code>.</p>\n<p>当遇到上述问题的时候，尝试安装一下 <code>@types/[package]</code>.</p>\n<p>然而，并不是所有的库都有类型声明的实现，也会有很多不支持 TS 的存在，然而又必须得使用这个库的时候该怎么办？</p>\n<p><strong>自己写声明！</strong></p>\n<p>以 <code>progressbar.js</code>为例，基本使用方法是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import * as ProgressBar from &#39;progressbar.js&#39;;\n\nnew ProgressBar.Circle(this.$progress, &#123;\n  strokeWidth: 8,\n  trailColor: &#39;#e5e4e5&#39;,\n  trailWidth: 8,\n  easing: &#39;easeInOut&#39;\n&#125;);</code></pre>\n\n<p>我们需要对库中暴露出的 api 去做声明，对上述例子做个分解：暴露了 Circle 类，Circle 构造函数包含两个参数，一个 HTMLElement，一个 options. OK, come on~</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 首先声明一下模块：\ndeclare module &#39;progressbar.js&#39; &#123;\n  &#x2F;&#x2F; 模块中暴露了 Circle 类\n  export class Circle &#123;\n    constructor(container: HTMLElement, options: Options);\n  &#125;\n\n  &#x2F;&#x2F; 构造函数的 Options 需要单独声明 \n  interface Options &#123;\n    easing?: string;\n    strokeWidth?: number;\n    trailColor?: string;\n    trailWidth?: number;\n  &#125;\n&#125;</code></pre>\n\n<p>如此我们便完成了一个简单的声明，当然实际使用中的 API 肯定比上述情况复杂，根据使用情况，用了哪些 API 或者参数，就补充那些的声明即可。</p>\n<p><strong>三. 如何组织一个 TS 项目</strong></p>\n<p>TS 项目的目录组织上，跟 JS 项目一样，补充好 types 的声明就可以了。</p>\n<p>需要注意的是，将你希望对外暴露的能力相关的类型声明都暴露出去，不友好的声明会让接入你项目的人非常的痛苦，同时，在 package.json 中需要指定 type 的 path, 比如：<code>&quot;types&quot;: &quot;dist/types/index.d.ts&quot;</code></p>\n<p>另外，务必加上 <code>tslint</code>, 更规范的去用 TS 实现功能，对于入门而言尤为重要。</p>\n<h2 id=\"TS-带来的改变\"><a href=\"#TS-带来的改变\" class=\"headerlink\" title=\"TS 带来的改变\"></a>TS 带来的改变</h2><p>接触 TS 一个月的感受上来说，过了磨合期的痛苦，就能慢慢感受到 TS 带来的便利。</p>\n<p>比如，有一个类型你记得名字是 ABC，你在 VSCode 中输入 A，然后发现，竟然能找到我的声明，按一下回车，卧槽，自动给你 import 进来了，不用在一个个字的输入 ..&#x2F;..&#x2F;..&#x2F;..&#x2F;，不用算目录层级是否正确了，是不是很爽。</p>\n<p>另外，强类型并不是没有好处啊，浪写惯了可能还是会留隐患的，有点约束也好 …</p>\n<p>虽然你每天要多敲很多 <code>import * as xx from &#39;xx&#39;</code>, 但是你的代码也更为可靠了不是。</p>\n<p>与君共勉，提前感受下一代 ES 标准，TS 用起来吧~</p>\n","text":"为什么用 TS ?说实话，最开始并没有想把 TS 用到实际项目中来，一来是感觉“类型”会限制 JS 的优势（好吧，就是浪写浪惯了）；二来听闻 TS + Redux 的酸爽滋味，有点望而却步；三来 TS 环境使用的库需要加类型的声明，很多库并不支持，有点担心推进的流畅度 … 这个时...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-TS\"><span class=\"toc-text\">为什么用 TS ?</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%E5%9B%B0%E6%83%91\"><span class=\"toc-text\">初学者的困惑</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TS-%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%94%B9%E5%8F%98\"><span class=\"toc-text\">TS 带来的改变</span></a></li></ol>","author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"可能是你需要的 React + TypeScript 50 条规范和经验","uid":"6bbcc54b583d8f9e999b08536b9ffec3","slug":"可能是你需要的 React + TypeScript 50 条规范和经验","date":"2021-08-08T05:24:16.000Z","updated":"2023-04-21T08:46:17.973Z","comments":true,"path":"api/articles/可能是你需要的 React + TypeScript 50 条规范和经验.json","keywords":null,"cover":null,"text":"1. 注释(1) 文件顶部的注释，包括描述、作者、日期&#x2F;** * @description xxxxxx * @author chengfeng * @since 19&#x2F;05&#x2F;21 *&#x2F; 复制代码 (2) 模块的注释&#x2F;** * 拷...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Antd Form.List实现自定义可编辑表格","uid":"679a9e76b771c60b95232fe737f13603","slug":"Antd Form.List实现自定义可编辑表格","date":"2021-07-25T13:39:19.000Z","updated":"2023-04-21T08:40:34.113Z","comments":true,"path":"api/articles/Antd Form.List实现自定义可编辑表格.json","keywords":null,"cover":[],"text":" 一、前言定制化较深的需求，往往需要可编辑表格来支持表格内的编辑，但是针对必填项校验以及自定义action动作，常规的EditableTable难以满足需要，而EditableProTable则因为定制化太深而不够灵活，所以我们需要更加灵活的方案来实现我们需要的效果，经试验，Fo...","link":"","photos":[],"count_time":{"symbolsCount":"9.4k","symbolsTime":"9 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}