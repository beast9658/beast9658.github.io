{"title":"可能是你需要的 React + TypeScript 50 条规范和经验","uid":"6bbcc54b583d8f9e999b08536b9ffec3","slug":"可能是你需要的 React + TypeScript 50 条规范和经验","date":"2021-08-08T05:24:16.000Z","updated":"2023-04-21T08:46:17.973Z","comments":true,"path":"api/articles/可能是你需要的 React + TypeScript 50 条规范和经验.json","keywords":null,"cover":null,"content":"<h3 id=\"1-注释\"><a href=\"#1-注释\" class=\"headerlink\" title=\"1. 注释\"></a>1. 注释</h3><h4 id=\"1-文件顶部的注释，包括描述、作者、日期\"><a href=\"#1-文件顶部的注释，包括描述、作者、日期\" class=\"headerlink\" title=\"(1) 文件顶部的注释，包括描述、作者、日期\"></a>(1) 文件顶部的注释，包括描述、作者、日期</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * @description xxxxxx\n * @author chengfeng\n * @since 19&#x2F;05&#x2F;21\n *&#x2F;\n复制代码</code></pre>\n\n<h4 id=\"2-模块的注释\"><a href=\"#2-模块的注释\" class=\"headerlink\" title=\"(2) 模块的注释\"></a>(2) 模块的注释</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 拷贝数据\n * @param  &#123;*&#125;  data   要拷贝的源数据\n * @param  &#123;boolean&#125; [isDeep&#x3D;false] 是否深拷贝，默认浅拷贝\n * @return &#123;*&#125;         返回拷贝后的数据\n *&#x2F;\n复制代码</code></pre>\n\n<h4 id=\"3-业务代码注释\"><a href=\"#3-业务代码注释\" class=\"headerlink\" title=\"(3) 业务代码注释\"></a>(3) 业务代码注释</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*业务代码注释*&#x2F;\n复制代码</code></pre>\n\n<h4 id=\"4-变量注释\"><a href=\"#4-变量注释\" class=\"headerlink\" title=\"(4) 变量注释\"></a>(4) 变量注释</h4><pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IState &#123;\n  &#x2F;&#x2F; 名字\n  name: string;\n  &#x2F;&#x2F; 电话\n  phone: number;\n  &#x2F;&#x2F; 地址\n  address: string;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"2-引用组件顺序\"><a href=\"#2-引用组件顺序\" class=\"headerlink\" title=\"2. 引用组件顺序\"></a>2. 引用组件顺序</h3><ul>\n<li>先引用外部组件库,,再引用当前组件块级组件, 然后是 common 里的公共函数库最后是 css 样式</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import * as React from &#39;react&#39;;\nimport &#123; Dropdown, Menu, Icon &#125; from &#39;antd&#39;;\nimport Header from &#39;.&#x2F;Header&#39;;\nimport toast from &#39;common&#x2F;toast&#39;;\nimport &#39;.&#x2F;index.less&#39;;\n复制代码</code></pre>\n\n<h3 id=\"3-引号\"><a href=\"#3-引号\" class=\"headerlink\" title=\"3. 引号\"></a>3. 引号</h3><ul>\n<li>使用单引号,或者 es6 的反引号</li>\n</ul>\n<h3 id=\"4-缩进\"><a href=\"#4-缩进\" class=\"headerlink\" title=\"4. 缩进\"></a>4. 缩进</h3><ul>\n<li>使用两个空格</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const handleCheck &#x3D; () &#x3D;&gt; &#123;\n  onCancel &amp;&amp; onCancel();\n  onClose &amp;&amp; onClose();\n&#125;;\n复制代码</code></pre>\n\n<h3 id=\"5-分号\"><a href=\"#5-分号\" class=\"headerlink\" title=\"5. 分号\"></a>5. 分号</h3><ul>\n<li>除了代码块的以外的每个表达式后必须加分号。</li>\n</ul>\n<h3 id=\"6-括号\"><a href=\"#6-括号\" class=\"headerlink\" title=\"6. 括号\"></a>6. 括号</h3><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; not good\nif (condition) doSomething();\n\n&#x2F;&#x2F; good\nif (condition) &#123;\n  doSomething();\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"7-空格\"><a href=\"#7-空格\" class=\"headerlink\" title=\"7. 空格\"></a>7. 空格</h3><ul>\n<li>二元和三元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\n++ x;\ny ++;\nz &#x3D; x?1:2;\n\n&#x2F;&#x2F; good\n++x;\ny++;\nz &#x3D; x ? 1 : 2;\n复制代码</code></pre>\n\n<ul>\n<li>用作代码块起始的左花括号 { 前必须有一个空格。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nif (condition)&#123;\n&#125;\n\nwhile (condition)&#123;\n&#125;\n\nfunction funcName()&#123;\n&#125;\n\n&#x2F;&#x2F; good\nif (condition) &#123;\n&#125;\n\nwhile (condition) &#123;\n&#125;\n\nfunction funcName() &#123;\n&#125;\n\n复制代码</code></pre>\n\n<ul>\n<li>if &#x2F; else &#x2F; for &#x2F; while &#x2F; function &#x2F; switch &#x2F; do &#x2F; try &#x2F; catch &#x2F; finally 关键字后，必须有一个空格。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nif(condition) &#123;\n&#125;\n\nwhile(condition) &#123;\n&#125;\n\n(function() &#123;\n&#125;)();\n\n&#x2F;&#x2F; good\nif (condition) &#123;\n&#125;\n\nwhile (condition) &#123;\n&#125;\n\n(function () &#123;\n&#125;)();\n复制代码</code></pre>\n\n<ul>\n<li>在对象创建时，属性中的 : 之后必须有空格，: 之前不允许有空格。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nvar obj &#x3D; &#123;\n    a : 1,\n    b:2,\n    c :3\n&#125;;\n\n&#x2F;&#x2F; good\nvar obj &#x3D; &#123;\n    a: 1,\n    b: 2,\n    c: 3\n&#125;;\n复制代码</code></pre>\n\n<h3 id=\"8-换行\"><a href=\"#8-换行\" class=\"headerlink\" title=\"8. 换行\"></a>8. 换行</h3><ul>\n<li>每个独立语句结束后必须换行。</li>\n<li>在函数声明、函数表达式、函数调用、对象创建、数组创建、for 语句等场景中，不允许在 , 或 ; 前换行</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nvar obj &#x3D; &#123;\n    a: 1\n    , b: 2\n    , c: 3,\n&#125;;\n\nfunction test()\n&#123;\n    ...\n&#125;\nfor (const key in object)\n &#123;\n  if (object.hasOwnProperty(key)) &#123;\n    const element &#x3D; object[key];\n\n  &#125;\n&#125;\n&#x2F;&#x2F; good\nvar obj &#x3D; &#123;\n    a: 1,\n    b: 2,\n    c: 3,\n&#125;;\n\nfunction test() &#123;\n    ...\n&#125;\n\nfor (const key in object) &#123;\n  if (object.hasOwnProperty(key)) &#123;\n    const element &#x3D; object[key];\n\n  &#125;\n&#125;\n复制代码</code></pre>\n\n<ul>\n<li>下列关键字后：else, catch, finally 不需要换行</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nif (condition) &#123;\n    ...\n&#125;\nelse &#123;\n    ...\n&#125;\n\ntry &#123;\n    ...\n&#125;\ncatch (e) &#123;\n    ...\n&#125;\nfinally &#123;\n    ...\n&#125;\n\n\n&#x2F;&#x2F; good\nif (condition) &#123;\n    ...\n&#125; else &#123;\n    ...\n&#125;\n\ntry &#123;\n    ...\n&#125; catch (e) &#123;\n    ...\n&#125; finally &#123;\n    ...\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"9-数组、对象\"><a href=\"#9-数组、对象\" class=\"headerlink\" title=\"9. 数组、对象\"></a>9. 数组、对象</h3><ul>\n<li>对象属性名不需要加引号；</li>\n<li>对象以缩进的形式书写，不要写在一行；</li>\n<li>数组最后不要有逗号。</li>\n<li>对象最后要有逗号。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n&#x2F;&#x2F; bad\nconst a &#x3D; &#123;\n    &#39;b&#39;: 1\n&#125;;\n\nconst a &#x3D; &#123;b: 1&#125;;\n\nconst a &#x3D; &#123;\n    b: 1,\n    c: 2\n&#125;;\nconst arr &#x3D; [1, 2, 3, 4,];\n\n&#x2F;&#x2F; good\nconst a &#x3D; &#123;\n    b: 1,\n    c: 2,\n&#125;;\n\nconst arr &#x3D; [1, 2, 3, 4];\n复制代码</code></pre>\n\n<h3 id=\"10-命名\"><a href=\"#10-命名\" class=\"headerlink\" title=\"10. 命名\"></a>10. 命名</h3><ul>\n<li>类名: 大驼峰式风格，字母和数字，例如：AbcTest。禁止汉字、特殊符号，禁止非大驼峰式风格。</li>\n<li>函数名: 小驼峰式风格，字母和数字，例如：abcTest。禁止汉字、特殊符号，禁止非小驼峰式风格，例如snake_case等。</li>\n<li>变量名: 同函数名。</li>\n<li>常量: 全大写风格，大写字母、数字和下划线，单词之间以下划线分隔，例如：ABC_TEST。禁止汉字、特殊符号、小写字母。</li>\n<li>使用 onXxx 形式作为 props 中用于回调的属性名称。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IProps &#123;\n  onClose?: () &#x3D;&gt; void;\n  onOk?: (item: Record&lt;string, any&gt;) &#x3D;&gt; void;\n&#125;\n复制代码</code></pre>\n\n<ul>\n<li>组件内的事件函数使用 handle 开头尾,handleCheckBtn。</li>\n<li>使用 withXxx 形式的词作为高阶组件的名称。</li>\n<li>接口命名前面带上 I 表示 interface</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IProps &#123;&#125;\ninterface IState &#123;&#125;\n复制代码</code></pre>\n\n<h3 id=\"11-类型断言\"><a href=\"#11-类型断言\" class=\"headerlink\" title=\"11. 类型断言\"></a>11. 类型断言</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nfunction getLength(something: string | number): number &#123;\n    return something.length;\n&#125;\n\n&#x2F;&#x2F; index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n&#x2F;&#x2F;   Property &#39;length&#39; does not exist on type &#39;number&#39;.\n\n&#x2F;&#x2F; bad \nfunction getLength(something: string | number): number &#123;\n    if ((&lt;string&gt;something).length) &#123;\n        return (&lt;string&gt;something).length;\n    &#125; else &#123;\n        return something.toString().length;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; good\nfunction getLength(something: string | number): number &#123;\n  if (typeof something &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n    return something.length;\n  &#125; else &#123;\n    return something.toString().length;\n  &#125;\n&#125;\n\n复制代码</code></pre>\n\n<h3 id=\"12-interface声明顺序\"><a href=\"#12-interface声明顺序\" class=\"headerlink\" title=\"12. interface声明顺序\"></a>12. interface声明顺序</h3><p>日常用到比较多的是四种，只读参数放第一位，必选参数第二位，可选参数次之，不确定参数放最后</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface iProps &#123;\n  readonly x: number;\n  readonly y: number;\n  name: string;\n  age: number;\n  height?: number;\n  [propName: string]: any;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"13-ts好用的相关工具泛型\"><a href=\"#13-ts好用的相关工具泛型\" class=\"headerlink\" title=\"13. ts好用的相关工具泛型\"></a>13. ts好用的相关工具泛型</h3><ul>\n<li>Record&lt;string,any&gt; 用这个来声明对象结构的类型</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">用于定义一个javascript的对象，key是字符串，value是任意类型\nconst people:Record&lt;string,any&gt; &#x3D; &#123;\n    name: &#39;chengfeng&#39;,\n    age: 10\n&#125;\n复制代码</code></pre>\n\n<ul>\n<li>Partial 作用是将传入的属性变为可选项.</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface iPeople &#123;\n    title: string;\n    name: string;\n&#125;\n\nconst people: Partial&lt;iPeople&gt; &#x3D; &#123;\n    title: &#39;Delete inactive users&#39;,\n&#125;;\n定义的结构可以是接口iPeople的任意key\n复制代码</code></pre>\n\n<ul>\n<li>Readonly 作用是将传入的属性变为变成只读</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface iPeople &#123;\n    title: string;\n    name: string;\n&#125;\n\nconst people: Readonly&lt;Todo&gt; &#x3D; &#123;\n    title: &#39;todo list&#39;,\n    name: chenfeng;\n&#125;;\ntitle name属性就是只读的了\n复制代码</code></pre>\n\n<ul>\n<li>Required 的作用是将传入的属性变为必选项</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface iPeople &#123;\n    title?: string;\n    name?: string;\n&#125;\n\nconst people1: Props &#x3D; &#123; title: &#39;ts&#39; &#125;; &#x2F;&#x2F; OK\n\nconst people22: Required&lt;iPeople&gt; &#x3D; &#123; title: &#39;ts&#39; &#125;; &#x2F;&#x2F; Error: property &#39;name&#39; missing\n复制代码</code></pre>\n\n<p><a href=\"https://link.juejin.cn/?target=https://github.com/Microsoft/TypeScript-Handbook/diffs/0?base_sha=22b37a2d8c9a1dd378795444baf954c2e7ecccf5&commentable=true&head_user=csantos42&pull_number=801&sha1=22b37a2d8c9a1dd378795444baf954c2e7ecccf5&sha2=9d4c56f5d414dbe23780719885baa3df40222412&short_path=0b2da51&unchanged=expanded&utf8=%25E2%259C%2593%23requiredt\" title=\"https://github.com/Microsoft/TypeScript-Handbook/diffs/0?base_sha=22b37a2d8c9a1dd378795444baf954c2e7ecccf5&amp;commentable=true&amp;head_user=csantos42&amp;pull_number=801&amp;sha1=22b37a2d8c9a1dd378795444baf954c2e7ecccf5&amp;sha2=9d4c56f5d414dbe23780719885baa3df40222412&amp;short_path=0b2da51&amp;unchanged=expanded&amp;utf8=%E2%9C%93#requiredt\">查看更多</a></p>\n<h3 id=\"14-ts一些好用的小tips\"><a href=\"#14-ts一些好用的小tips\" class=\"headerlink\" title=\"14. ts一些好用的小tips\"></a>14. ts一些好用的小tips</h3><ul>\n<li>keyof</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface iPeople &#123;\n  name: string;\n  age: number\n&#125;\n\ntype T &#x3D; keyof iPeople &#x2F;&#x2F; -&gt; &quot;name&quot; | &quot;age&quot;\n复制代码</code></pre>\n\n<ul>\n<li>in</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type Keys &#x3D; &quot;a&quot; | &quot;b&quot;\ntype Obj &#x3D;  &#123;\n  [p in Keys]: any\n&#125; &#x2F;&#x2F; -&gt; &#123; a: any, b: any &#125;\n复制代码</code></pre>\n\n<h3 id=\"15-规范其他\"><a href=\"#15-规范其他\" class=\"headerlink\" title=\"15. 规范其他\"></a>15. 规范其他</h3><ul>\n<li>不要使用 var 声明变量</li>\n<li>不会被修改的变量使用 const 声明</li>\n<li>去除声明但未被引用的代码</li>\n<li>禁止在代码里使用 debug</li>\n<li>不允许有空的代码块</li>\n</ul>\n<h3 id=\"16-仅当初始-state-需要从-props-计算得到的时候，才将-state-的声明放在构造函数中，其它情况下使用静态属性声明-state-并且一般情况下不要将-prop-传给-state\"><a href=\"#16-仅当初始-state-需要从-props-计算得到的时候，才将-state-的声明放在构造函数中，其它情况下使用静态属性声明-state-并且一般情况下不要将-prop-传给-state\" class=\"headerlink\" title=\"16. 仅当初始 state 需要从 props 计算得到的时候，才将 state 的声明放在构造函数中，其它情况下使用静态属性声明 state,并且一般情况下不要将 prop 传给 state\"></a>16. 仅当初始 state 需要从 props 计算得到的时候，才将 state 的声明放在构造函数中，其它情况下使用静态属性声明 state,并且一般情况下不要将 prop 传给 state</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nconstructor ()&#123;\n  this.setState(&#123; people: this.props.people &#125;)\n&#125;\n\n&#x2F;&#x2F; good\nstate: IState &#x3D; &#123;\n  people: &#123;&#125;,\n&#125;;\n复制代码</code></pre>\n\n<h3 id=\"17-渲染默认值\"><a href=\"#17-渲染默认值\" class=\"headerlink\" title=\"17. 渲染默认值\"></a>17. 渲染默认值</h3><ul>\n<li>添加非空判断可以提高代码的稳健性,例如后端返回的一些值,可能会出现不存在的情况，应该要给默认值.</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nrender()&#123;\n  &#123;name&#125;\n&#125;\n\n&#x2F;&#x2F; good\nrender()&#123;\n  &#123;!!name || &#39;--&#39;&#125;\n&#125;\n\n\n复制代码</code></pre>\n\n<ul>\n<li>还有一种情况，就是本来后端应该返回一个数组给你，但是数据库取不到数据，可能后端给你返回了null,然后前端null.length。这样就gg了</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nconst &#123; list, totalCount &#125; &#x3D; await getPeopleList(keyword, page, pageSize);\nlist 可能是null或者undefined\nlist.length将直接导致前端报错\n\nthis.setState(&#123;\n  status: STATUS.READY,\n  apps: list,\n  total: totalCount,\n  page: page,\n&#125;);\n\n\n&#x2F;&#x2F; good \nconst &#123; list, totalCount &#125; &#x3D; await getPeopleList(keyword, page, pageSize);\nthis.setState(&#123;\n  status: STATUS.READY,\n  apps: list || [],\n  total: totalCount || 0,\n  page: page,\n&#125;);\n\n复制代码</code></pre>\n\n<h3 id=\"18-不确定的属性，最后却疯狂的用…访问不存在的属性\"><a href=\"#18-不确定的属性，最后却疯狂的用…访问不存在的属性\" class=\"headerlink\" title=\"18. 不确定的属性，最后却疯狂的用…访问不存在的属性\"></a>18. 不确定的属性，最后却疯狂的用…访问不存在的属性</h3><p>例如一些地方，不确定这个变量里面到底有什么，但自己觉得有，就疯狂的…,最明显的就是后端返回了一个对象给你，前端拿到之后判断都不判断直接data.dataList.forEach()</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nconst data &#x3D; await getPeopleList(keyword, page, pageSize);\ndata.dataList.forEach() &#x2F;&#x2F; 直接挂了\n\n&#x2F;&#x2F; good\nconst data &#x3D; await getPeopleList(keyword, page, pageSize);\nif (data &amp;&amp; data.dataList &amp;&amp; Array.isArray(data.dataList) &#123;\n    data.dataList.forEach() \n&#125;\n复制代码</code></pre>\n\n<h3 id=\"19-数据格式转换\"><a href=\"#19-数据格式转换\" class=\"headerlink\" title=\"19. 数据格式转换\"></a>19. 数据格式转换</h3><ol>\n<li>把字符串转整型可以使用+号</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">let maxPrice &#x3D; +form.maxPrice.value;\nlet maxPrice &#x3D; Number(form.maxPrice.value);\n复制代码</code></pre>\n\n<ol start=\"2\">\n<li>转成 boolean 值用!!</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">let mobile &#x3D; !!ua.match(&#x2F;iPhone|iPad|Android|iPod|Windows Phone&#x2F;);\n复制代码</code></pre>\n\n<h3 id=\"20-判断条件真假\"><a href=\"#20-判断条件真假\" class=\"headerlink\" title=\"20. 判断条件真假\"></a>20. 判断条件真假</h3><p>js 中以下为假,其他情况为真</p>\n<ul>\n<li>false</li>\n<li>null</li>\n<li>undefined</li>\n<li>0</li>\n<li>‘’ (空字符串)</li>\n<li>NaN</li>\n</ul>\n<h3 id=\"21-简单组件可以使用函数代替\"><a href=\"#21-简单组件可以使用函数代替\" class=\"headerlink\" title=\"21. 简单组件可以使用函数代替\"></a>21. 简单组件可以使用函数代替</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nclass Listing extends React.Component &#123;\n  render() &#123;\n    return &lt;div&gt;&#123;this.props.hello&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; good\nfunction Listing(&#123; hello &#125;) &#123;\n  return &lt;div&gt;&#123;hello&#125;&lt;&#x2F;div&gt;;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"22-对于常用的属性进行缓存\"><a href=\"#22-对于常用的属性进行缓存\" class=\"headerlink\" title=\"22. 对于常用的属性进行缓存\"></a>22. 对于常用的属性进行缓存</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nthis.props.app.openid;\nthis.state.time\n\n&#x2F;&#x2F; good\nconst &#123; app &#125; &#x3D; this.props;\nconst &#123; time &#125; &#x3D; this.state;\nconsole.log(app.openid)\n复制代码</code></pre>\n\n<h3 id=\"23-input-输入框使用-trim\"><a href=\"#23-input-输入框使用-trim\" class=\"headerlink\" title=\"23. input 输入框使用 trim()\"></a>23. input 输入框使用 trim()</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nlet searchContent &#x3D; form.search.value;\n\n&#x2F;&#x2F; good\nlet searchContent &#x3D; form.search.value.trim();\n复制代码</code></pre>\n\n<h3 id=\"24-使用-location-跳转前需要先转义\"><a href=\"#24-使用-location-跳转前需要先转义\" class=\"headerlink\" title=\"24. 使用 location 跳转前需要先转义\"></a>24. 使用 location 跳转前需要先转义</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nwindow.location.href &#x3D; redirectUrl + &#39;?a&#x3D;10&amp;b&#x3D;20&#39;;\n\n&#x2F;&#x2F; good\nwindow.location.href &#x3D; redirectUrl + encodeURIComponent(&#39;?a&#x3D;10&amp;b&#x3D;20&#39;);\n复制代码</code></pre>\n\n<h3 id=\"25-使用-react-router\"><a href=\"#25-使用-react-router\" class=\"headerlink\" title=\"25. 使用 react-router\"></a>25. 使用 react-router</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">\n&#x2F;&#x2F; bad\nimport &#123; withRouter, RouteComponentProps &#125; from &#39;react-router-dom&#39;;\n\nexport interface IProps extends RouteComponentProps&lt;any&gt; &#123;&#125;\nclass App extends React.Component&lt;IProps, AppStates&gt; &#123;&#125;\nexport default withRouter(App);\n\n\n&#x2F;&#x2F; good\nimport &#123; withRouter, RouteComponentProps &#125; from &#39;react-router-dom&#39;;\n\nclass App extends React.Component&lt;IProps &amp; RouteComponentProps&lt;&#123;&#125;&gt;, AppStates&gt; &#123;&#125;\nexport default withRouter(App);\n\n复制代码</code></pre>\n\n<h3 id=\"26-同时开发，数据请求-api-目录-git-冲突目录方案\"><a href=\"#26-同时开发，数据请求-api-目录-git-冲突目录方案\" class=\"headerlink\" title=\"26. 同时开发，数据请求 api 目录 git 冲突目录方案\"></a>26. 同时开发，数据请求 api 目录 git 冲突目录方案</h3><ul>\n<li>在 api 目录下新建一个目录，目录对应一级 tab,这个目录内放置一个 index.js ，最后把二级 tab 组件所使用的 api 请求都在这个 index.js 内引入。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 目前\n\n|- api\n  |- pageA.ts\n  |- pageB.ts\n\n&#x2F;&#x2F; 建议\n\n|- api\n  |- pageA\n    |- index.js\n    |- aaa.js\n    |- bbb.js\n  |- pageB\n    |- index.js\n    |- aaa.js\n    |- bbb.js\n    |- ccc.js\n复制代码</code></pre>\n\n<h3 id=\"27-组件嵌套过深\"><a href=\"#27-组件嵌套过深\" class=\"headerlink\" title=\"27. 组件嵌套过深\"></a>27. 组件嵌套过深</h3><ul>\n<li>组件一般不要超过三层,最多四层,层级过深可能会导致数据传递过深，在做一些颗粒度比较细的操作的时候，处理起来较为繁琐，可以使用 redux 等状态管理工具替代。</li>\n</ul>\n<h3 id=\"28-代码过滤掉你没考虑到的情况\"><a href=\"#28-代码过滤掉你没考虑到的情况\" class=\"headerlink\" title=\"28. 代码过滤掉你没考虑到的情况\"></a>28. 代码过滤掉你没考虑到的情况</h3><ul>\n<li>例如一个函数，你只想操作字符串，那你必须在函数开头就只允许参数是字符串</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function parse (str:string)&#123;\n  if (typeof(str) &#x3D;&#x3D;&#x3D; &#39;string&#39; ) &#123;\n\n  &#125;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"29-业务代码里面的异步请求需要-try-catch\"><a href=\"#29-业务代码里面的异步请求需要-try-catch\" class=\"headerlink\" title=\"29. 业务代码里面的异步请求需要 try catch\"></a>29. 业务代码里面的异步请求需要 try catch</h3><ul>\n<li>ajax 请求，使用 try catch，错误提示后端返回,并且做一些失败后的状态操作例如进入列表页，我们需要一个 loading 状态，然后去请求数据,可是失败之后，也需要把 loading 状态去掉,把 loading 隐藏的代码就写在 finally 里面。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">getStudentList &#x3D; async () &#x3D;&gt; &#123;\n  try &#123;\n    this.setState(&#123;\n      loading: true,\n      isEmpty: false\n    &#125;);\n    await getStudentList(&#123;&#125;);\n  &#125; catch (e) &#123;\n    &#x2F;&#x2F; TODO\n    console.log(e)\n  &#125; finally &#123;\n    &#x2F;&#x2F;  失败之后的一些兜底操作\n    this.setState(&#123;\n      loading: false,\n      isEmpty: true\n    &#125;);\n  &#125;\n&#125;;\n复制代码</code></pre>\n\n<h3 id=\"30-setState有三种用法\"><a href=\"#30-setState有三种用法\" class=\"headerlink\" title=\"30. setState有三种用法\"></a>30. setState有三种用法</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 对象\nthis.setState(&#123;\n\n&#125;)\n\n&#x2F;&#x2F; 函数，一般是用于在setState之前做一些操作\nthis.setState(\n  () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; TODO\n    console.log(&#39;&#39;)\n    return &#123;\n      a:300\n    &#125;\n  &#125;\n)\n\n&#x2F;&#x2F; 第二个参数，一般是用于在setState之后做一些操作\nthis.setState(&#123;\n  a:300\n&#125;, () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; TODO\n&#125;)\n复制代码</code></pre>\n\n<h3 id=\"31-setState可能是同步的\"><a href=\"#31-setState可能是同步的\" class=\"headerlink\" title=\"31. setState可能是同步的\"></a>31. setState可能是同步的</h3><ul>\n<li>setState 在react里的合成事件和钩子函数中是“异步”的。</li>\n<li>setState 在原生事件和 setTimeout 中是同步的。</li>\n</ul>\n<h3 id=\"32-不要在-setState-前面加-await\"><a href=\"#32-不要在-setState-前面加-await\" class=\"headerlink\" title=\"32. 不要在 setState 前面加 await\"></a>32. 不要在 setState 前面加 await</h3><ul>\n<li>setState 前面也是可以带 await 的，会变成同步设置状态,但这是一种巧合，不确定未来哪个版本就不支持了，为了遵循 react 框架的设计原则，我们使用回掉函数的形式。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nfunc &#x3D; async (name, value, status) &#x3D;&gt; &#123;\n  await this.setState(&#123;\n    name\n  &#125;);\n  &#x2F;&#x2F; TODO\n&#125;;\n\n&#x2F;&#x2F; good\nfunc &#x3D; (name, value, status) &#x3D;&gt; &#123;\n  this.setState(\n    &#123;\n      name\n    &#125;,\n    () &#x3D;&gt; &#123;\n      &#x2F;&#x2F; TODO\n    &#125;\n  );\n&#125;;\n复制代码</code></pre>\n\n<h3 id=\"33-阻止事件默认行为\"><a href=\"#33-阻止事件默认行为\" class=\"headerlink\" title=\"33. 阻止事件默认行为\"></a>33. 阻止事件默认行为</h3><ul>\n<li>在 React 中你不能通过返回 false 来阻止默认行为。必须明确调用 preventDefault 。</li>\n</ul>\n<h3 id=\"34-在-componentWillUnmount-里面去除副作用的函数\"><a href=\"#34-在-componentWillUnmount-里面去除副作用的函数\" class=\"headerlink\" title=\"34. 在 componentWillUnmount 里面去除副作用的函数\"></a>34. 在 componentWillUnmount 里面去除副作用的函数</h3><ul>\n<li>清除 EventListener</li>\n<li>中止数据请求</li>\n<li>清除定时器</li>\n</ul>\n<h3 id=\"35-key\"><a href=\"#35-key\" class=\"headerlink\" title=\"35. key\"></a>35. key</h3><ul>\n<li>对于组件中的 key 优化，起到最大化重用 dom</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;bad\nthis.state.dataAry.map((item, index) &#x3D;&gt; &#123;\n  return &lt;span key&#x3D;&#123;index&#125; &#x2F;&gt;;\n&#125;);\n\n&#x2F;&#x2F;good\nthis.state.dataAry.map(item &#x3D;&gt; &lt;span key&#x3D;&#123;item.id&#125; &#x2F;&gt;);\n复制代码</code></pre>\n\n<h3 id=\"36-for-in-中一定要有-hasOwnProperty-的判断（即禁止直接读取原型对象的属性）\"><a href=\"#36-for-in-中一定要有-hasOwnProperty-的判断（即禁止直接读取原型对象的属性）\" class=\"headerlink\" title=\"36. for-in 中一定要有 hasOwnProperty 的判断（即禁止直接读取原型对象的属性）\"></a>36. for-in 中一定要有 hasOwnProperty 的判断（即禁止直接读取原型对象的属性）</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;bad\nconst arr &#x3D; [];\nconst key &#x3D; &#39;&#39;;\n\nfor (key in obj) &#123;\n  arr.push(obj[key]);\n&#125;\n\n&#x2F;&#x2F;good\nconst arr &#x3D; [];\nconst key &#x3D; &#39;&#39;;\n\nfor (key in obj) &#123;\n  if (obj.hasOwnProperty(key)) &#123;\n    arr.push(obj[key]);\n  &#125;\n&#125;\n\n复制代码</code></pre>\n\n<h3 id=\"37-第三方库函数的使用\"><a href=\"#37-第三方库函数的使用\" class=\"headerlink\" title=\"37. 第三方库函数的使用\"></a>37. 第三方库函数的使用</h3><ul>\n<li>用 try catch 包裹，防止第三方库的出现错误，导致整个程序崩溃</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*\n * Echart 用于代绘制图表，但当其自身发生错误时，可能影响到业务代码的执行\n *&#x2F;\n&#x2F;&#x2F; bad\nconst iniDom &#x3D; document.getElementById(&#39;init-container&#39;);\nconst echartObj &#x3D; echarts.init(iniDom);\nthis.setState(\n  &#123;\n    echartObj\n  &#125;,\n  () &#x3D;&gt; &#123;\n    const &#123; echartObj &#125; &#x3D; this.state;\n    &#x2F;&#x2F; 更新图表\n    echartObj.setOption(CHART_CONFIG, true);\n  &#125;\n);\n\n&#x2F;&#x2F; good\ntry &#123;\n  const iniDom &#x3D; document.getElementById(&#39;init-container&#39;);\n  const echartObj &#x3D; echarts.init(iniDom);\n  this.setState(\n    &#123;\n      echartObj\n    &#125;,\n    () &#x3D;&gt; &#123;\n      const &#123; echartObj &#125; &#x3D; this.state;\n      &#x2F;&#x2F; 更新图表\n      echartObj.setOption(CHART_CONFIG, true);\n    &#125;\n  );\n&#125; catch (error) &#123;\n  &#x2F;&#x2F; TODO\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"38-防止-xss-攻击\"><a href=\"#38-防止-xss-攻击\" class=\"headerlink\" title=\"38. 防止 xss 攻击\"></a>38. 防止 xss 攻击</h3><ul>\n<li>input，textarea 等标签，不要直接把 html 文本直接渲染在页面上,使用 xssb 等过滤之后再输出到标签上;</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import &#123; html2text &#125; from &#39;xss&#39;;\nrender()&#123;\n  &lt;div\n  dangerouslySetInnerHTML&#x3D;&#123;&#123;\n    __html: html2text(htmlContent)\n  &#125;&#125;\n&#x2F;&gt;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"39-在组件中获取真实-dom\"><a href=\"#39-在组件中获取真实-dom\" class=\"headerlink\" title=\"39. 在组件中获取真实 dom\"></a>39. 在组件中获取真实 dom</h3><ul>\n<li>使用 16 版本后的 createRef()函数</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class MyComponent extends React.Component&lt;iProps, iState&gt; &#123;\n  constructor(props) &#123;\n    super(props);\n    this.inputRef &#x3D; React.createRef();\n  &#125;\n\n  render() &#123;\n    return &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;this.inputRef&#125; &#x2F;&gt;;\n  &#125;\n\n  componentDidMount() &#123;\n    this.inputRef.current.focus();\n  &#125;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"40-减少魔法数字\"><a href=\"#40-减少魔法数字\" class=\"headerlink\" title=\"40. 减少魔法数字\"></a>40. 减少魔法数字</h3><ul>\n<li>写代码的时候尽量减少一些未知含义的数字，尽量用英文单词。例如type &#x3D;&#x3D;&#x3D; 0的时候做了一些操作，让人不知所以然。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nif (type !&#x3D;&#x3D; 0) &#123;\n  &#x2F;&#x2F; TODO\n&#125;\n\n&#x2F;&#x2F; good\nconst STATUS: Record&lt;string, any&gt; &#x3D; &#123;\n  READY: 0,\n  FETCHING: 1,\n  FAILED: 2\n&#125;;\n\nif (type &#x3D;&#x3D;&#x3D; STATUS.READY) &#123;\n  &#x2F;&#x2F; TODO\n&#125;\n\n&#x2F;&#x2F; best\nenum STATUS &#123;\n  &#x2F;&#x2F; 就绪\n  READY &#x3D; 0,\n  &#x2F;&#x2F; 请求中\n  FETCHING &#x3D; 1,\n  &#x2F;&#x2F; 请求失败\n  FAILED &#x3D; 2,\n&#125;\n\n复制代码</code></pre>\n\n<h3 id=\"41-如果需要优化-react-性能（一般用不到）\"><a href=\"#41-如果需要优化-react-性能（一般用不到）\" class=\"headerlink\" title=\"41. 如果需要优化 react 性能（一般用不到）\"></a>41. 如果需要优化 react 性能（一般用不到）</h3><ul>\n<li>如果组件的 state 和 props 都是简单类型，可以继承 PureComponent 而不是 Component</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import &#123; Component, PureComponent &#125; from &#39;react&#39;;\n&#x2F;&#x2F; bad\nclass Message extends Component &#123;\n  render() &#123;\n    return &lt;span&gt;&#123;this.state.message&#125;&lt;&#x2F;span&gt;;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; good\nclass Message extends PureComponent &#123;\n  render() &#123;\n    return &lt;span&gt;&#123;this.state.message&#125;&lt;&#x2F;span&gt;;\n  &#125;\n&#125;\n复制代码</code></pre>\n\n<ul>\n<li>重写 shouldComponentUpdate 方法,在 shouldComponentUpdate 里面根据 state,props 是否有改变来判断是否需要重新渲染.如果组件继承了 PureComponent 就没必要再重写 shouldComponentUpdate 方法</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import &#123; isReactPropsEqual, isReactStateEqual &#125; from &#39;@fe&#x2F;common&#x2F;lib&#x2F;equal&#39;;\nshouldComponentUpdate(nextProps:IProps, nextState:IState) &#123;\n    if (isReactStateEqual(nextState,this.state) &amp;&amp; isReactPropsEqual(nextProps,this.props)) &#123;\n        return false;\n    &#125;\n    return true;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"42-Event-事件对象类型\"><a href=\"#42-Event-事件对象类型\" class=\"headerlink\" title=\"42. Event 事件对象类型\"></a>42. Event 事件对象类型</h3><p>很多小伙伴用了很久的ts,都不知道常用 Event 事件对象类型：</p>\n<p>ClipboardEvent&lt;T &#x3D; Element&gt; 剪贴板事件对象</p>\n<p>DragEvent&lt;T &#x3D; Element&gt; 拖拽事件对象</p>\n<p>ChangeEvent&lt;T &#x3D; Element&gt; Change 事件对象</p>\n<p>KeyboardEvent&lt;T &#x3D; Element&gt; 键盘事件对象</p>\n<p>MouseEvent&lt;T &#x3D; Element&gt; 鼠标事件对象</p>\n<p>TouchEvent&lt;T &#x3D; Element&gt; 触摸事件对象</p>\n<p>WheelEvent&lt;T &#x3D; Element&gt; 滚轮事件对象</p>\n<p>AnimationEvent&lt;T &#x3D; Element&gt; 动画事件对象</p>\n<p>TransitionEvent&lt;T &#x3D; Element&gt; 过渡事件对象</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import &#123; MouseEvent &#125; from &#39;react&#39;;\n\ninterface IProps &#123;\n  onClick(event: MouseEvent&lt;HTMLDivElement&gt;): void;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"43-使用私有属性取代state状态\"><a href=\"#43-使用私有属性取代state状态\" class=\"headerlink\" title=\"43. 使用私有属性取代state状态\"></a>43. 使用私有属性取代state状态</h3><p>对于一些不需要控制ui的状态属性，我们可以直接绑到this上， 即私有属性，没有必要弄到this.state上，不然会触发渲染机制，造成性能浪费 例如请求翻页数据的时候,我们都会有个变量。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\nstate: IState &#x3D; &#123;\n  pageNo:1,\n  pageSize:10\n&#125;;\n\n&#x2F;&#x2F; good \nqueryParams:Record&lt;string,any&gt; &#x3D; &#123;\n  pageNo:1,\n  pageSize:10\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"44-代码细粒度的思考\"><a href=\"#44-代码细粒度的思考\" class=\"headerlink\" title=\"44. 代码细粒度的思考\"></a>44. 代码细粒度的思考</h3><p>总结四句话。我们在写组件或者函数的的时候，工具函数和业务逻辑抽离，表单校验和业务抽离、事件函数和业务抽离，ajax和业务抽离。 例如有些页面是通过location.href跳转的，我们有些业务逻辑等都是放到didmountMount,但是后期改需求，可能要用react-router进行跳转，可能要改的逻辑就会很多了，所以函数抽离出来，需求更新就少改一点代码。 如果还不确定如何划分函数的细粒度，我有个建议。使用过两次以上的代码，要抽离组件或者函数，两次的可以不用</p>\n<h3 id=\"45-if-else-等判断太多了，后期难以维护。\"><a href=\"#45-if-else-等判断太多了，后期难以维护。\" class=\"headerlink\" title=\"45. if else 等判断太多了，后期难以维护。\"></a>45. if else 等判断太多了，后期难以维护。</h3><p>个人觉得if else 嵌套深看起来也不会太难受，难受的是，项目迭代久之后，自己都忘记曾经写过这些代码，而且类型多或者不确定有什么类型，是否后期还会加的情况下，改起来就非常复杂了，而且很容易踩坑和背锅。 用配置取代if嵌套，大概就是抽离一个config.ts出来，里面放一些配置。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">例如你的业务代码里面，会根据不同url参数，代码会执行不同的逻辑.\n&#x2F;info?type&#x3D;wechat&amp;uid&#x3D;123456&amp;\nconst qsObj &#x3D; qs(window.location.url)\nconst urlType &#x3D; qsObj.type\n&#x2F;&#x2F; bad \nif (urlType &#x3D;&#x3D;&#x3D; &#39;wechat&#39;) &#123;\n    doSomeThing()\n&#125; else if () &#123;\n    doSomeThing()\n&#125; else if () &#123;\n    doSomeThing()\n&#125; else if () &#123;\n    doSomeThing()\n&#125;\n\n&#x2F;&#x2F; good \nconfig.t\nconst urlTypeConfig: Record&lt;string, typeItem&gt; &#x3D; &#123;\n  &#39;wechat&#39;: &#123; &#x2F;&#x2F; key 就是对应的type\n    name: &#39;wechat&#39;, \n    show: [&#39;header&#39;, &#39;footer&#39;, &#39;wechat&#39;] &#x2F;&#x2F; 展示什么，可能是异步的\n    pession: [&#39;admin&#39;], &#x2F;&#x2F; 权限是什么，可能是异步的\n  &#125;,\n  &#39;zhifubao&#39;: &#123; &#x2F;&#x2F; key 就是对应的type\n    name: &#39;zhifubao&#39;, \n    show: [&#39;header&#39;, &#39;footer&#39;, &#39;zhifubao&#39;] &#x2F;&#x2F; 展示什么，可能是异步的\n    pession: [&#39;admin&#39;], &#x2F;&#x2F; 权限是什么，可能是异步的\n  &#125;,\n&#125;\n\n&#x2F;&#x2F; 业务逻辑\nconst qsObj &#x3D; qs(window.location.url)\nconst urlType &#x3D; qsObj.type\nObject.keys(urlTypeConfig).forEach(item &#x3D;&gt; &#123;\n  if(urlType &#x3D;&#x3D;&#x3D; item.type) &#123;\n    doSomeThing(item.show)\n  &#125;\n&#125;)\n\n复制代码</code></pre>\n\n<h3 id=\"46-不要使用renderXXX-要使用函数式组件\"><a href=\"#46-不要使用renderXXX-要使用函数式组件\" class=\"headerlink\" title=\"46. 不要使用renderXXX,要使用函数式组件\"></a>46. 不要使用renderXXX,要使用函数式组件</h3><p>发现团队一些小伙伴为了减少render函数里面的代码量，会把一些元素拆分到函数里面。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; bad\n  renderHeader &#x3D; () &#x3D;&gt; &#123;\n    return (&lt;div &#x2F;&gt;)\n  &#125;\n  renderBody &#x3D; () &#x3D;&gt; &#123;\n    return (&lt;div &#x2F;&gt;)\n  &#125;\n  renderFooter &#x3D; () &#x3D;&gt; &#123;\n    return (&lt;div &#x2F;&gt;)\n  &#125;\n  render()&#123;\n    return(\n      &lt;div&gt;\n        renderHeader()\n        renderBody()\n        renderFooter()\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n复制代码</code></pre>\n\n<p>更好的办法，是用函数式组件取代在当前组件里面写方法</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; good\n function RenderHeader(props) &#x3D;  &#123;\n    return (&lt;div &#x2F;&gt;)\n  &#125;\n function RenderBody(props) &#x3D;  &#123;\n    return (&lt;div &#x2F;&gt;)\n  &#125;\n function RenderFooter(props) &#x3D;  &#123;\n    return (&lt;div &#x2F;&gt;)\n  &#125;\nclass Component extends React.Component&lt;iProps, iState&gt;&#123;  \n  render () &#123;\n    return(\n      &lt;div&gt;\n        &lt;RenderHeader &#x2F;&gt;\n        &lt;RenderBody &#x2F;&gt;\n        &lt;RenderFooter &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"47-a标签安全问题\"><a href=\"#47-a标签安全问题\" class=\"headerlink\" title=\"47. a标签安全问题\"></a>47. a标签安全问题</h3><p>使用a标签打开一个新窗口过程中的安全问题。新页面中可以使用window.opener来控制原始页面。如果新老页面同域，那么在新页面中可以任意操作原始页面。如果是不同域，新页面中依然可以通过window.opener.location，访问到原始页面的location对象</p>\n<p>在带有target&#x3D;”_blank”的a标签中，加上rel&#x3D;”noopener”属性。如果使用window.open的方式打开页面，将opener对象置为空。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var newWindow &#x3D; window.open();\nnewWindow.opener &#x3D; null;\n复制代码</code></pre>\n\n<h3 id=\"48-void-0-替代undefined\"><a href=\"#48-void-0-替代undefined\" class=\"headerlink\" title=\"48. void 0 替代undefined\"></a>48. void 0 替代undefined</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">clearSessioin &#x3D; () &#x3D;&gt; &#123;\n\t\n  req.session.userName &#x3D; undefined;\n  \n  req.session.userName &#x3D; void 0\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"49-前端不要操作cookie\"><a href=\"#49-前端不要操作cookie\" class=\"headerlink\" title=\"49. 前端不要操作cookie\"></a>49. 前端不要操作cookie</h3><p>在做一些前后端鉴权的时候，后端应该开启domain,secure,httponly严格模式，禁止前端操作cookie，防止csrf攻击。</p>\n<h3 id=\"50-代码检查插件\"><a href=\"#50-代码检查插件\" class=\"headerlink\" title=\"50. 代码检查插件\"></a>50. 代码检查插件</h3><p>我们可以使用构建工具继承 husky eslint tslint lint-stage prettier来规范代码。</p>\n<ul>\n<li><a href=\"https://link.juejin.cn/?target=https://www.npmjs.com/package/eslint-config-prettier\" title=\"https://www.npmjs.com/package/eslint-config-prettier\">eslint-config-prettier</a></li>\n<li><a href=\"https://link.juejin.cn/?target=https://www.npmjs.com/package/eslint-plugin-prettier\" title=\"https://www.npmjs.com/package/eslint-plugin-prettier\">eslint-plugin-prettier</a></li>\n<li><a href=\"https://link.juejin.cn/?target=https://www.npmjs.com/package/eslint-plugin-react\" title=\"https://www.npmjs.com/package/eslint-plugin-react\">eslint-plugin-react</a></li>\n<li><a href=\"https://link.juejin.cn/?target=https://www.npmjs.com/package/tslint-react\" title=\"https://www.npmjs.com/package/tslint-react\">tslint-react</a></li>\n<li><a href=\"https://link.juejin.cn/?target=https://www.npmjs.com/package/tslint-plugin-prettier\" title=\"https://www.npmjs.com/package/tslint-plugin-prettier\">tslint-plugin-prettier</a></li>\n<li><a href=\"https://link.juejin.cn/?target=https://www.npmjs.com/package/tslint-config-prettier\" title=\"https://www.npmjs.com/package/tslint-config-prettier\">tslint-config-prettier</a></li>\n<li><a href=\"https://link.juejin.cn/?target=https://github.com/Faithree/web-build-tool-demo/tree/master/28-workflow\" title=\"https://github.com/Faithree/web-build-tool-demo/tree/master/28-workflow\">团队开发工作流</a></li>\n</ul>\n<p>作者：乘风gg<br>链接：<a href=\"https://juejin.cn/post/6844903849166110728\">https://juejin.cn/post/6844903849166110728</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n","text":"1. 注释(1) 文件顶部的注释，包括描述、作者、日期&#x2F;** * @description xxxxxx * @author chengfeng * @since 19&#x2F;05&#x2F;21 *&#x2F; 复制代码 (2) 模块的注释&#x2F;** * 拷...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">1. 注释</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%96%87%E4%BB%B6%E9%A1%B6%E9%83%A8%E7%9A%84%E6%B3%A8%E9%87%8A%EF%BC%8C%E5%8C%85%E6%8B%AC%E6%8F%8F%E8%BF%B0%E3%80%81%E4%BD%9C%E8%80%85%E3%80%81%E6%97%A5%E6%9C%9F\"><span class=\"toc-text\">(1) 文件顶部的注释，包括描述、作者、日期</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%A8%A1%E5%9D%97%E7%9A%84%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">(2) 模块的注释</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">(3) 业务代码注释</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%8F%98%E9%87%8F%E6%B3%A8%E9%87%8A\"><span class=\"toc-text\">(4) 变量注释</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%BC%95%E7%94%A8%E7%BB%84%E4%BB%B6%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">2. 引用组件顺序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%BC%95%E5%8F%B7\"><span class=\"toc-text\">3. 引号</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%BC%A9%E8%BF%9B\"><span class=\"toc-text\">4. 缩进</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%88%86%E5%8F%B7\"><span class=\"toc-text\">5. 分号</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E6%8B%AC%E5%8F%B7\"><span class=\"toc-text\">6. 括号</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E7%A9%BA%E6%A0%BC\"><span class=\"toc-text\">7. 空格</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E6%8D%A2%E8%A1%8C\"><span class=\"toc-text\">8. 换行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">9. 数组、对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E5%91%BD%E5%90%8D\"><span class=\"toc-text\">10. 命名</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">11. 类型断言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-interface%E5%A3%B0%E6%98%8E%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">12. interface声明顺序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-ts%E5%A5%BD%E7%94%A8%E7%9A%84%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">13. ts好用的相关工具泛型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-ts%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B0%8Ftips\"><span class=\"toc-text\">14. ts一些好用的小tips</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-%E8%A7%84%E8%8C%83%E5%85%B6%E4%BB%96\"><span class=\"toc-text\">15. 规范其他</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-%E4%BB%85%E5%BD%93%E5%88%9D%E5%A7%8B-state-%E9%9C%80%E8%A6%81%E4%BB%8E-props-%E8%AE%A1%E7%AE%97%E5%BE%97%E5%88%B0%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%89%8D%E5%B0%86-state-%E7%9A%84%E5%A3%B0%E6%98%8E%E6%94%BE%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%EF%BC%8C%E5%85%B6%E5%AE%83%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%A3%B0%E6%98%8E-state-%E5%B9%B6%E4%B8%94%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E8%A6%81%E5%B0%86-prop-%E4%BC%A0%E7%BB%99-state\"><span class=\"toc-text\">16. 仅当初始 state 需要从 props 计算得到的时候，才将 state 的声明放在构造函数中，其它情况下使用静态属性声明 state,并且一般情况下不要将 prop 传给 state</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-%E6%B8%B2%E6%9F%93%E9%BB%98%E8%AE%A4%E5%80%BC\"><span class=\"toc-text\">17. 渲染默认值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-%E4%B8%8D%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%9C%80%E5%90%8E%E5%8D%B4%E7%96%AF%E7%8B%82%E7%9A%84%E7%94%A8%E2%80%A6%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">18. 不确定的属性，最后却疯狂的用…访问不存在的属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#19-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">19. 数据格式转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-%E5%88%A4%E6%96%AD%E6%9D%A1%E4%BB%B6%E7%9C%9F%E5%81%87\"><span class=\"toc-text\">20. 判断条件真假</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#21-%E7%AE%80%E5%8D%95%E7%BB%84%E4%BB%B6%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E4%BB%A3%E6%9B%BF\"><span class=\"toc-text\">21. 简单组件可以使用函数代替</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#22-%E5%AF%B9%E4%BA%8E%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">22. 对于常用的属性进行缓存</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#23-input-%E8%BE%93%E5%85%A5%E6%A1%86%E4%BD%BF%E7%94%A8-trim\"><span class=\"toc-text\">23. input 输入框使用 trim()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#24-%E4%BD%BF%E7%94%A8-location-%E8%B7%B3%E8%BD%AC%E5%89%8D%E9%9C%80%E8%A6%81%E5%85%88%E8%BD%AC%E4%B9%89\"><span class=\"toc-text\">24. 使用 location 跳转前需要先转义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#25-%E4%BD%BF%E7%94%A8-react-router\"><span class=\"toc-text\">25. 使用 react-router</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#26-%E5%90%8C%E6%97%B6%E5%BC%80%E5%8F%91%EF%BC%8C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82-api-%E7%9B%AE%E5%BD%95-git-%E5%86%B2%E7%AA%81%E7%9B%AE%E5%BD%95%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">26. 同时开发，数据请求 api 目录 git 冲突目录方案</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#27-%E7%BB%84%E4%BB%B6%E5%B5%8C%E5%A5%97%E8%BF%87%E6%B7%B1\"><span class=\"toc-text\">27. 组件嵌套过深</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#28-%E4%BB%A3%E7%A0%81%E8%BF%87%E6%BB%A4%E6%8E%89%E4%BD%A0%E6%B2%A1%E8%80%83%E8%99%91%E5%88%B0%E7%9A%84%E6%83%85%E5%86%B5\"><span class=\"toc-text\">28. 代码过滤掉你没考虑到的情况</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#29-%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E9%87%8C%E9%9D%A2%E7%9A%84%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E9%9C%80%E8%A6%81-try-catch\"><span class=\"toc-text\">29. 业务代码里面的异步请求需要 try catch</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#30-setState%E6%9C%89%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">30. setState有三种用法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#31-setState%E5%8F%AF%E8%83%BD%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84\"><span class=\"toc-text\">31. setState可能是同步的</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#32-%E4%B8%8D%E8%A6%81%E5%9C%A8-setState-%E5%89%8D%E9%9D%A2%E5%8A%A0-await\"><span class=\"toc-text\">32. 不要在 setState 前面加 await</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#33-%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA\"><span class=\"toc-text\">33. 阻止事件默认行为</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#34-%E5%9C%A8-componentWillUnmount-%E9%87%8C%E9%9D%A2%E5%8E%BB%E9%99%A4%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">34. 在 componentWillUnmount 里面去除副作用的函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#35-key\"><span class=\"toc-text\">35. key</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#36-for-in-%E4%B8%AD%E4%B8%80%E5%AE%9A%E8%A6%81%E6%9C%89-hasOwnProperty-%E7%9A%84%E5%88%A4%E6%96%AD%EF%BC%88%E5%8D%B3%E7%A6%81%E6%AD%A2%E7%9B%B4%E6%8E%A5%E8%AF%BB%E5%8F%96%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%89\"><span class=\"toc-text\">36. for-in 中一定要有 hasOwnProperty 的判断（即禁止直接读取原型对象的属性）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#37-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">37. 第三方库函数的使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#38-%E9%98%B2%E6%AD%A2-xss-%E6%94%BB%E5%87%BB\"><span class=\"toc-text\">38. 防止 xss 攻击</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#39-%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E-dom\"><span class=\"toc-text\">39. 在组件中获取真实 dom</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#40-%E5%87%8F%E5%B0%91%E9%AD%94%E6%B3%95%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">40. 减少魔法数字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#41-%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E4%BC%98%E5%8C%96-react-%E6%80%A7%E8%83%BD%EF%BC%88%E4%B8%80%E8%88%AC%E7%94%A8%E4%B8%8D%E5%88%B0%EF%BC%89\"><span class=\"toc-text\">41. 如果需要优化 react 性能（一般用不到）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#42-Event-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">42. Event 事件对象类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#43-%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%8F%96%E4%BB%A3state%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">43. 使用私有属性取代state状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#44-%E4%BB%A3%E7%A0%81%E7%BB%86%E7%B2%92%E5%BA%A6%E7%9A%84%E6%80%9D%E8%80%83\"><span class=\"toc-text\">44. 代码细粒度的思考</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#45-if-else-%E7%AD%89%E5%88%A4%E6%96%AD%E5%A4%AA%E5%A4%9A%E4%BA%86%EF%BC%8C%E5%90%8E%E6%9C%9F%E9%9A%BE%E4%BB%A5%E7%BB%B4%E6%8A%A4%E3%80%82\"><span class=\"toc-text\">45. if else 等判断太多了，后期难以维护。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#46-%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8renderXXX-%E8%A6%81%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">46. 不要使用renderXXX,要使用函数式组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#47-a%E6%A0%87%E7%AD%BE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">47. a标签安全问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#48-void-0-%E6%9B%BF%E4%BB%A3undefined\"><span class=\"toc-text\">48. void 0 替代undefined</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#49-%E5%89%8D%E7%AB%AF%E4%B8%8D%E8%A6%81%E6%93%8D%E4%BD%9Ccookie\"><span class=\"toc-text\">49. 前端不要操作cookie</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#50-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E6%8F%92%E4%BB%B6\"><span class=\"toc-text\">50. 代码检查插件</span></a></li></ol>","author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"数组转树","uid":"d7aff688f09321eb25c6942e9ba97bfe","slug":"数组转树","date":"2021-09-02T13:54:10.000Z","updated":"2023-04-21T08:51:02.009Z","comments":true,"path":"api/articles/数组转树.json","keywords":null,"cover":null,"text":"前端使用树插件是一个非常常见的使用场景。树插件的数据格式在我使用过的插件都是一样的。 而这个数据格式是由后端组装好返回给前端还是前端自己组装，这个问题在前端和后端也经常拿来撕逼。 大多数情况下后端会组装好，也有一部分前端自己处理，早之前我合作过的一个后端提出了一个观点， 浏览器是...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"TypeScript，初次见面","uid":"1dcd3b31893419d8e8f3a54468e3f5d8","slug":"TypeScript，初次见面","date":"2021-08-03T11:45:38.000Z","updated":"2023-04-21T08:43:11.544Z","comments":true,"path":"api/articles/TypeScript，初次见面.json","keywords":null,"cover":[],"text":"为什么用 TS ?说实话，最开始并没有想把 TS 用到实际项目中来，一来是感觉“类型”会限制 JS 的优势（好吧，就是浪写浪惯了）；二来听闻 TS + Redux 的酸爽滋味，有点望而却步；三来 TS 环境使用的库需要加类型的声明，很多库并不支持，有点担心推进的流畅度 … 这个时...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}