{"title":"React Hooks的学习笔记","uid":"15b860383ab68e267beb31ba2d0c1dea","slug":"React Hooks的学习笔记","date":"2021-09-15T12:50:54.000Z","updated":"2023-04-21T08:53:56.671Z","comments":true,"path":"api/articles/React Hooks的学习笔记.json","keywords":null,"cover":null,"content":"<h2 id=\"Hooks的起步使用\"><a href=\"#Hooks的起步使用\" class=\"headerlink\" title=\"Hooks的起步使用\"></a>Hooks的起步使用</h2><p>其实Hooks主要常用的可以有以下几个：</p>\n<ul>\n<li><code>useState</code></li>\n<li><code>useEffect</code></li>\n<li><code>useContext</code></li>\n<li><code>useMemo</code></li>\n<li><code>useRef</code></li>\n<li><code>useReducer</code></li>\n<li><code>useCallback</code></li>\n</ul>\n<p>列举的以上这几个，其实已经算是比较常用的，尤其是前两个，接下来就会介绍它们部分几个的使用。</p>\n<h3 id=\"useState\"><a href=\"#useState\" class=\"headerlink\" title=\"useState\"></a>useState</h3><p><code>useState</code>这个钩子其实对应的是我们之前<code>class Component</code>里的<code>this.setState</code>。</p>\n<ol>\n<li><code>useState</code>传参代表默认值，可以是原始值，也可以是对象、数组，所以其实表达能力很丰富。</li>\n<li><code>useState</code>调用后返回是一对值，对应<strong>当前的值</strong>和<strong>更新这个值的函数</strong>，用数组解构的方式获取很简洁。</li>\n<li><code>useState</code>在一个函数组件里可以多次使用。</li>\n<li><code>useState</code>和<code>this.setState</code>区别之处在于，前者每次更新后<code>state</code>都是新值，换而言之其实是不可变数据的概念。而后者使用后，其实更新<code>state</code>部分的值，引用本身并无改变。</li>\n</ol>\n<p>简单使用如下示例。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import React, &#123; useState &#125; from &#39;react&#39;;\n\nexport default function StateHook() &#123;\n  const [count, useCount] &#x3D; useState(0);\n  return (\n    &lt;&gt;\n      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; useCount(count + 1)&#125;&gt;Click me&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"useEffect\"><a href=\"#useEffect\" class=\"headerlink\" title=\"useEffect\"></a>useEffect</h3><p><code>useEffect</code>这个钩子势必是我们常用的。</p>\n<ol>\n<li>它基本可以等价于<code>componentDidMount</code>和<code>componentDidUpdate</code>的这两个生命周期钩子组合的效果。那么它的调用时机大概是每次渲染结束后，所以不会阻塞组件渲染。</li>\n<li><code>useEffect</code>一般用于实现设置数据请求、监听器等有副作用的功能，传入的第一个参数<strong>函数A1</strong>用于设置副作用，而是传入的这个函数可以返回一个<strong>函数A2</strong>用于取消<strong>函数A1</strong>的副作用。这两个函数的React调用它们时机分别在于，注册副作用的<strong>函数A1</strong>在当次渲染结束后立即执行，取消副作用的<strong>函数A2</strong>在下次渲染开始之前立即执行。再次强调，这么设计的理由还是为了不阻塞组件渲染。</li>\n<li><code>useEffect</code>第二个参数用于设置副作用的依赖数组。什么意思？思维灵活的同学已经想到了，如果每次渲染都执行副作用，有可能造成性能浪费，那么可以通过告诉React，这个钩子依赖某些<code>props</code>或者<code>states</code>，在这些依赖不发生改变时，这个副作用不会再重复执行。在以下的例子中，可以传空数组，告诉React该副作用什么也不依赖，那么它只会在第一次渲染时执行一次（但是一般不推荐这么做）。如果不传第二个参数，则意味着每次渲染都必然执行一次，此时应当注意内存泄露。</li>\n<li>同学们有没有发现，使用<code>useEffect</code>后，一个副作用的注册监听与对应的取消注册逻辑全部放在了一起，对比与以往的分别在<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code>里分散同一副作用的逻辑。<code>useEffect</code>的使用更有吸引力和说服力了。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;\n\nexport default function EffectHook(&#123; dep &#125;) &#123;\n  const [width, setWidth] &#x3D; useState(window.innerWidth);\n  \n  function handleWindowResize() &#123;\n    const w &#x3D; window.innerWidth;\n    setWidth(w);\n  &#125;\n  \n  useEffect(() &#x3D;&gt; &#123;\n    window.addEventListener(&#39;resize&#39;, handleWindowResize);\n    return () &#x3D;&gt; &#123;\n      window.removeEventListener(&#39;resize&#39;, handleWindowResize);\n    &#125;;\n  &#125;, \n    &#x2F;&#x2F; deps\n    []\n  );\n\n  return (\n    &lt;&gt;\n      &lt;p&gt;window.innerWidth: &#123;width&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"useContext\"><a href=\"#useContext\" class=\"headerlink\" title=\"useContext\"></a>useContext</h3><p>这个钩子还是和原有的<code>Context.Provider</code>、<code>Context.Consumer</code>一样的理解即可。用法示例如下，理解方便，不再赘述。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import React, &#123; useContext &#125; from &#39;react&#39;;\n\nexport const souliz &#x3D; &#123;\n  name: &#39;souliz&#39;,\n  description: &#39;A normal human named by his cat.&#39;\n&#125;;\n\nexport const UserContext &#x3D; React.createContext(souliz);\n\nexport default function ContextHook() &#123;\n  const context &#x3D; useContext(UserContext);\n\n  return (\n    &lt;&gt;\n      &lt;p&gt;UserContext name: &#123;context.name&#125;&lt;&#x2F;p&gt;\n      &lt;p&gt;UserContext description: &#123;context.description&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"useMemo\"><a href=\"#useMemo\" class=\"headerlink\" title=\"useMemo\"></a>useMemo</h3><p>有时候我们会遇到一个极耗性能的函数方法，但由于依赖了函数组件里一些状态值，又不得不放在其中。那么如果我们每次渲染都去重复调用的发，组件的渲染必然会十分卡顿。</p>\n<p>因此写了以下示例验证，一个计算斐波那契的函数（众所周知的慢），读者可以拷贝这段代码，注释<code>useMemo</code>那一行，使用直接计算来看，点击按钮触发组件重新渲染，会发现很卡顿（当然了），那么此时<code>useMemo</code>作用就发挥出来了，其实理解上还是和原有的<code>React.memo</code>一样，可用于缓存一下计算缓慢的函数，如果依赖没有发生改变，则重复使用旧值。前提必然是这个函数是一个纯函数，否则必然会引发问题。</p>\n<p>（<code>useCallback</code>其实也和<code>useMemo</code>道理类似，不过它解决的问题其实如果依赖不改变，使用旧的函数引用，在<code>useEffect</code>的依赖是函数时，可以使用<code>useCallback</code>的特性来避免重复触发副作用的发生，因此不再赘述<code>useCallback</code>）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import React, &#123; useState, useMemo &#125; from &#39;react&#39;;\n\nlet fib &#x3D; n &#x3D;&gt; (n &gt; 1 ? fib(n - 1) + fib(n - 2) : n);\nlet renders &#x3D; 0;\n\nexport default function MemoHook() &#123;\n  const defaultInput &#x3D; 37;\n  const [input, setInput] &#x3D; useState(defaultInput);\n  const [time, setTime] &#x3D; useState(0);\n  const value &#x3D; useMemo(() &#x3D;&gt; fib(input), [input]);\n  &#x2F;&#x2F; 来来来，看看不使用Memo的后果就是卡顿\n  &#x2F;&#x2F; const value &#x3D; fib(input);\n\n  return (\n    &lt;&gt;\n      &lt;p&gt;fib value is &#123;value&#125;&lt;&#x2F;p&gt;\n      &lt;input\n        type&#x3D;&quot;number&quot;\n        value&#x3D;&#123;input&#125;\n        onChange&#x3D;&#123;e &#x3D;&gt; setInput(e.target.value)&#125;\n      &#x2F;&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setTime(time + 1)&#125;&gt;Trigger render &#123;time&#125;&lt;&#x2F;button&gt;\n      &lt;footer&gt;render times: &#123;renders++&#125;&lt;&#x2F;footer&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"useRef\"><a href=\"#useRef\" class=\"headerlink\" title=\"useRef\"></a>useRef</h3><p><code>useRef</code>这个钩子需要更通用的理解方式，不同于我们之前使用的<code>React.createRef()</code>，这个钩子用于创建的是一个引用对象，那么可以用于突破<code>useState</code>所带来的局限。什么意思呢？<code>useState</code>每次渲染都是新的值，也就是下面示例中，如果我点击3次按钮，分别更新了值触发5次组件重新渲染，那么通过延时5秒后获取current值如示例二，如果需要在某些操作中获取组件最新的某些<code>state</code>是最新的值的时候，<code>useRef</code>可以派上大用场。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import React, &#123; useRef, useEffect, useState &#125; from &#39;react&#39;;\n\nexport default function RefHook() &#123;\n  const [count, setCount] &#x3D; useState(0);\n  const latestCount &#x3D; useRef(count);\n\n  latestCount.current &#x3D; count;\n  useEffect(() &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(&#96;Ref: You clicked $&#123;latestCount.current&#125; times&#96;);\n      console.log(&#96;state: You clicked $&#123;count&#125; times&#96;);\n    &#125;, 5000);\n  &#125;);\n\n  return (\n    &lt;&gt;\n      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;Click me&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Ref: You clicked 3 times\nstate: You clicked 1 times\nRef: You clicked 3 times\nstate: You clicked 2 times\nRef: You clicked 3 times\nstate: You clicked 3 times\n复制代码</code></pre>\n\n<h3 id=\"useReducer\"><a href=\"#useReducer\" class=\"headerlink\" title=\"useReducer\"></a>useReducer</h3><p>相信同学们都使用过redux，React Team考虑到这种使用方式常见，于是设计出来了这么一个钩子。这样的话其实解决了我们常见写redux的多文件跳跃编写的烦恼，而且十分易于理解。（当然还有比较高级的用法）。以下代码示例。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import React, &#123; useState, useReducer &#125; from &#39;react&#39;;\n\nconst defaultTodos &#x3D; [\n  &#123;\n    id: 1,\n    text: &#39;Todo 1&#39;,\n    completed: false\n  &#125;,\n  &#123;\n    id: 2,\n    text: &#39;Todo 2&#39;,\n    completed: false\n  &#125;\n];\n\nfunction todosReducer(state, action) &#123;\n  switch (action.type) &#123;\n    case &#39;add&#39;:\n      return [\n        ...state,\n        &#123;\n          id:  Date.now(),\n          text: action.text,\n          completed: false\n        &#125;\n      ];\n    case &#39;complete&#39;:\n      return state.map(todo &#x3D;&gt; &#123;\n        if (todo.id &#x3D;&#x3D;&#x3D; action.id) &#123;\n          todo.completed &#x3D; true;\n        &#125;\n        return todo;\n      &#125;);\n    default:\n      return state;\n  &#125;\n&#125;\n\nexport default function ReducerHook() &#123;\n  const [todos, dispatch] &#x3D; useReducer(todosReducer, defaultTodos);\n  const [value, setValue] &#x3D; useState(&#39;&#39;);\n\n  function handleTextChange(e) &#123;\n    setValue(e.target.value);\n  &#125;\n\n  function handleAddTodo() &#123;\n    if (value &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;\n      return;\n    &#125;\n    dispatch(&#123;\n      type: &#39;add&#39;,\n      text: value\n    &#125;);\n    setValue(&#39;&#39;);\n  &#125;\n\n  function handleCompleteTodo(id) &#123;\n    dispatch(&#123;\n      type: &#39;complete&#39;,\n      id\n    &#125;);\n  &#125;\n\n  return (\n    &lt;&gt;\n      &lt;section&gt;\n        &lt;input\n          type&#x3D;&quot;text&quot;\n          onChange&#x3D;&#123;handleTextChange&#125;\n          value&#x3D;&#123;value&#125;\n        &#x2F;&gt;\n        &lt;button onClick&#x3D;&#123;handleAddTodo&#125;&gt;Add Todo&lt;&#x2F;button&gt;\n      &lt;&#x2F;section&gt;\n      &lt;ul className&#x3D;&quot;todos&quot;&gt;\n        &#123;todos.map(todo &#x3D;&gt; (\n          &lt;ol id&#x3D;&#123;todo.id&#125; key&#x3D;&#123;todo.id&#125;&gt;\n            &lt;span\n              style&#x3D;&#123;&#123;\n                textDecoration: todo.completed ? &#39;line-through&#39; : &#39;none&#39;\n              &#125;&#125;\n            &gt;\n              &#123;todo.text&#125;\n            &lt;&#x2F;span&gt;\n            &lt;input\n              type&#x3D;&quot;checkbox&quot;\n              disabled&#x3D;&#123;todo.completed&#125;\n              onClick&#x3D;&#123;() &#x3D;&gt; handleCompleteTodo(todo.id)&#125;\n            &#x2F;&gt;\n          &lt;&#x2F;ol&gt;\n        ))&#125;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码</code></pre>\n\n<p>其实<code>useReducer</code>的原理大概也可以这么来实现。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function useReducer(reducer, initialState) &#123;\n  const [state, setState] &#x3D; useState(initialState);\n\n  function dispatch(action) &#123;\n    const nextState &#x3D; reducer(state, action);\n    setState(nextState);\n  &#125;\n\n  return [state, dispatch];\n&#125;\n复制代码</code></pre>\n\n<p>相信学完这些Hooks的使用后，许多同学都是内心充满了很多疑惑的同时也想要尝试看看怎么使用到实际项目了。</p>\n<p>当然现在React官方的建议是：</p>\n<ul>\n<li>可以小规模的使用了，但是无需重写以前的组件实现。React是不会移除<code>class Component</code>这些原有API的。</li>\n<li>如果决定使用Hooks的话，可以加上React提供的<code>eslint-plugin-react-hooks</code>，用于检测对于Hooks的不正当使用。（听说create-react-app很快将会加上这个配置）</li>\n<li>学习与使用React Hooks其实更需要的是换一种心智模型去理解，Hooks更多的像是一个同步处理数据的过程。</li>\n</ul>\n<h2 id=\"Hooks存在的意义以及原因？\"><a href=\"#Hooks存在的意义以及原因？\" class=\"headerlink\" title=\"Hooks存在的意义以及原因？\"></a>Hooks存在的意义以及原因？</h2><p>传统组件的开发有以下几个局限：</p>\n<ol>\n<li>难以复用含有state（状态）的组件逻辑。HOC、render props这两种做法虽然可以解决，但是一是需要重新架构组件，可能会使代码更复杂。二是可能会造成wrapper hell。</li>\n<li>复杂组件难以理解消化。因为状态逻辑、消息订阅、请求、以及副作用在不同的生命钩子混乱穿插，彼此耦合，使得一个组件难以再细化拆分。即使使用了Redux这种状态管理的库后，也引进了更高层的抽象，同时需要在不同的文件之间穿插跳跃，复用组件也不是一件容易的事。</li>\n<li>class让人困惑。（先别急着反对）一个是this让人困惑，常常需要绑定、第二是class转译和压缩出来的代码其实相当冗长。</li>\n</ol>\n<h2 id=\"Hooks的注意事项\"><a href=\"#Hooks的注意事项\" class=\"headerlink\" title=\"Hooks的注意事项\"></a>Hooks的注意事项</h2><ol>\n<li>只能在函数的顶层使用，不能嵌套于循环体、判断条件等里面。原因是因为需要确保Hooks每次在组件渲染中都是按照<strong>同样的顺序</strong>，这个十分重要，具体原因将会是一个很大的篇幅</li>\n<li>只能在React函数组件里，或者自定义钩子(custom Hooks)里使用。</li>\n</ol>\n","text":"Hooks的起步使用其实Hooks主要常用的可以有以下几个： useState useEffect useContext useMemo useRef useReducer useCallback 列举的以上这几个，其实已经算是比较常用的，尤其是前两个，接下来就会介绍它们部分几个...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hooks%E7%9A%84%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">Hooks的起步使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useState\"><span class=\"toc-text\">useState</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useEffect\"><span class=\"toc-text\">useEffect</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useContext\"><span class=\"toc-text\">useContext</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useMemo\"><span class=\"toc-text\">useMemo</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useRef\"><span class=\"toc-text\">useRef</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useReducer\"><span class=\"toc-text\">useReducer</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hooks%E5%AD%98%E5%9C%A8%E7%9A%84%E6%84%8F%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%9F\"><span class=\"toc-text\">Hooks存在的意义以及原因？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hooks%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">Hooks的注意事项</span></a></li></ol>","author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Antv X6 绘制拖拽流程图","uid":"41fa294c894ff0de66f9b80c0c4a5c37","slug":"Antv X6 绘制拖拽流程图","date":"2021-10-20T09:21:06.000Z","updated":"2023-04-21T09:03:09.746Z","comments":true,"path":"api/articles/Antv X6 绘制拖拽流程图.json","keywords":null,"cover":[],"text":"使用antv x6 绘制拖拽流程图安装# npm $ npm install @antv&#x2F;x6 --save # yarn $ yarn add @antv&#x2F;x6 复制代码 使用创建容器 &lt;!-- 画布 --&gt; &lt;div class&#x3D...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"数组转树","uid":"d7aff688f09321eb25c6942e9ba97bfe","slug":"数组转树","date":"2021-09-02T13:54:10.000Z","updated":"2023-04-21T08:51:02.009Z","comments":true,"path":"api/articles/数组转树.json","keywords":null,"cover":null,"text":"前端使用树插件是一个非常常见的使用场景。树插件的数据格式在我使用过的插件都是一样的。 而这个数据格式是由后端组装好返回给前端还是前端自己组装，这个问题在前端和后端也经常拿来撕逼。 大多数情况下后端会组装好，也有一部分前端自己处理，早之前我合作过的一个后端提出了一个观点， 浏览器是...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}