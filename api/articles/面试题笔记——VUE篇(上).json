{"title":"面试题笔记——VUE篇(上)","uid":"be5afecc963f0a7007cee0b82bb652a1","slug":"面试题笔记——VUE篇(上)","date":"2021-06-23T02:33:53.000Z","updated":"2023-04-21T08:34:36.787Z","comments":true,"path":"api/articles/面试题笔记——VUE篇(上).json","keywords":null,"cover":[],"content":"<h2 id=\"一、Vue-基础\"><a href=\"#一、Vue-基础\" class=\"headerlink\" title=\"一、Vue 基础\"></a>一、Vue 基础</h2><h3 id=\"1-Vue的基本原理\"><a href=\"#1-Vue的基本原理\" class=\"headerlink\" title=\"1. Vue的基本原理\"></a>1. Vue的基本原理</h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter&#x2F;setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ba0c62cf3874627b8232c540c466d6e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"0_tB3MJCzh_cB6i3mS-1.png\"></p>\n<h3 id=\"2-双向数据绑定的原理\"><a href=\"#2-双向数据绑定的原理\" class=\"headerlink\" title=\"2. 双向数据绑定的原理\"></a>2. 双向数据绑定的原理</h3><p>Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p>\n<ol>\n<li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li>\n<li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>\n<li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>\n<li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li>\n</ol>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/229ac3f0729b422c8343d495bcfb4662~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h3 id=\"3-使用-Object-defineProperty-来进行数据劫持有什么缺点？\"><a href=\"#3-使用-Object-defineProperty-来进行数据劫持有什么缺点？\" class=\"headerlink\" title=\"3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？\"></a>3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p>\n<p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p>\n<h3 id=\"4-MVVM、MVC、MVP的区别\"><a href=\"#4-MVVM、MVC、MVP的区别\" class=\"headerlink\" title=\"4. MVVM、MVC、MVP的区别\"></a>4. MVVM、MVC、MVP的区别</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p>\n<p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p>\n<p><strong>（1）MVC</strong></p>\n<p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b4ca355d4ff4e98a55322b1627d1c3e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>（2）MVVM</p>\n<p>MVVM 分为 Model、View、ViewModel：</p>\n<ul>\n<li>Model代表数据模型，数据和业务逻辑都在Model层中定义；</li>\n<li>View代表UI视图，负责数据的展示；</li>\n<li>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</li>\n</ul>\n<p>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p>\n<p>这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6824ec59527c4b0cbf4ab175a7f7b802~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p><strong>（3）MVP</strong></p>\n<p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p>\n<h3 id=\"5-Computed-和-Watch-的区别\"><a href=\"#5-Computed-和-Watch-的区别\" class=\"headerlink\" title=\"5. Computed 和 Watch 的区别\"></a>5. Computed 和 Watch 的区别</h3><p><strong>对于Computed：</strong></p>\n<ul>\n<li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li>\n<li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li>\n<li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li>\n<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li>\n<li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li>\n</ul>\n<p><strong>对于Watch：</strong></p>\n<ul>\n<li><p>它不支持缓存，数据变化时，它就会触发相应的操作</p>\n</li>\n<li><p>支持异步监听</p>\n</li>\n<li><p>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</p>\n</li>\n<li><p>当一个属性发生变化时，就需要执行相应的操作</p>\n</li>\n<li><p>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：</p>\n<ul>\n<li>immediate：组件加载立即触发回调函数</li>\n<li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li>\n</ul>\n</li>\n</ul>\n<p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p>\n<p><strong>总结：</strong></p>\n<ul>\n<li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</li>\n<li>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li>\n</ul>\n<p><strong>运用场景：</strong></p>\n<ul>\n<li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。</li>\n<li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>\n</ul>\n<h3 id=\"6-Computed-和-Methods-的区别\"><a href=\"#6-Computed-和-Methods-的区别\" class=\"headerlink\" title=\"6. Computed 和 Methods 的区别\"></a>6. Computed 和 Methods 的区别</h3><p>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的</p>\n<p><strong>不同点：</strong></p>\n<ul>\n<li>computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</li>\n<li>method 调用总会执行该函数。</li>\n</ul>\n<h3 id=\"7-slot是什么？有什么作用？原理是什么？\"><a href=\"#7-slot是什么？有什么作用？原理是什么？\" class=\"headerlink\" title=\"7. slot是什么？有什么作用？原理是什么？\"></a>7. slot是什么？有什么作用？原理是什么？</h3><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p>\n<ul>\n<li>默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li>\n<li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li>\n<li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li>\n</ul>\n<p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p>\n<h3 id=\"8-过滤器的作用，如何实现一个过滤器\"><a href=\"#8-过滤器的作用，如何实现一个过滤器\" class=\"headerlink\" title=\"8. 过滤器的作用，如何实现一个过滤器\"></a>8. 过滤器的作用，如何实现一个过滤器</h3><p>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用<code>filters</code>来过滤数据，<code>filters</code>不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 <code>computed</code> ，方法 <code>methods</code> 都是通过修改数据来处理数据格式的输出显示）。</p>\n<p><strong>使用场景：</strong></p>\n<ul>\n<li>需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 &#x2F; 显示。</li>\n<li>比如后端返回一个 <strong>年月日的日期字符串</strong>，前端需要展示为 <strong>多少天前</strong> 的数据格式，此时就可以用<code>fliters</code>过滤器来处理数据。</li>\n</ul>\n<p>过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在<strong>插值表达式 <strong><code>&#123;&#123; &#125;&#125;</code> 和 <code>v-bind</code></strong> 表达式</strong> 中，然后放在操作符“ <code>|</code> ”后面进行指示。</p>\n<p>例如，在显示金额，给商品价格添加单位：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;li&gt;商品价格：&#123;&#123;item.price | filterPrice&#125;&#125;&lt;&#x2F;li&gt;\n\n filters: &#123;\n    filterPrice (price) &#123;\n      return price ? (&#39;￥&#39; + price) : &#39;--&#39;\n    &#125;\n  &#125;\n复制代码</code></pre>\n\n<h3 id=\"9-如何保存页面的当前的状态\"><a href=\"#9-如何保存页面的当前的状态\" class=\"headerlink\" title=\"9. 如何保存页面的当前的状态\"></a>9. 如何保存页面的当前的状态</h3><p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p>\n<ul>\n<li>前组件会被卸载</li>\n<li>前组件不会被卸载</li>\n</ul>\n<p>那么可以按照这两种情况分别得到以下方法：</p>\n<p><strong>组件会被卸载：</strong></p>\n<p><strong>（1）将状态存储在LocalStorage &#x2F; SessionStorage</strong></p>\n<p>只需要在组件即将被销毁的生命周期 <code>componentWillUnmount</code> （react）中在 LocalStorage &#x2F; SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。</p>\n<p>比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>兼容性好，不需要额外库或工具。</li>\n<li>简单快捷，基本可以满足大部分需求。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li>\n<li>如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li>\n</ul>\n<p><strong>（2）路由传值</strong></p>\n<p>通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。</p>\n<p>在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>简单快捷，不会污染 LocalStorage &#x2F; SessionStorage。</li>\n<li>可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify &#x2F; parse 的不足）</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li>\n</ul>\n<p><strong>组件不会被卸载：</strong></p>\n<p><strong>（1）单页面渲染</strong></p>\n<p>要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>代码量少</li>\n<li>不需要考虑状态传递过程中的错误</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>增加 A 组件维护成本</li>\n<li>需要传入额外的 prop 到 B 组件</li>\n<li>无法利用路由定位页面</li>\n</ul>\n<p>除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的<strong>activated、deactivated</strong>这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;keep-alive&gt;\n\t&lt;router-view v-if&#x3D;&quot;$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;kepp-alive&gt;\n复制代码</code></pre>\n\n<p><strong>router.js</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;\n  path: &#39;&#x2F;&#39;,\n  name: &#39;xxx&#39;,\n  component: ()&#x3D;&gt;import(&#39;..&#x2F;src&#x2F;views&#x2F;xxx.vue&#39;),\n  meta:&#123;\n    keepAlive: true &#x2F;&#x2F; 需要被缓存\n  &#125;\n&#125;,\n复制代码</code></pre>\n\n<h3 id=\"10-常见的事件修饰符及其作用\"><a href=\"#10-常见的事件修饰符及其作用\" class=\"headerlink\" title=\"10. 常见的事件修饰符及其作用\"></a>10. 常见的事件修饰符及其作用</h3><ul>\n<li><code>.stop</code>：等同于 JavaScript 中的 <code>event.stopPropagation()</code> ，防止事件冒泡；</li>\n<li><code>.prevent</code> ：等同于 JavaScript 中的 <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li>\n<li><code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</li>\n<li><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li>\n<li><code>.once</code> ：只会触发一次。</li>\n</ul>\n<h3 id=\"11-v-if、v-show、v-html-的原理\"><a href=\"#11-v-if、v-show、v-html-的原理\" class=\"headerlink\" title=\"11. v-if、v-show、v-html 的原理\"></a>11. v-if、v-show、v-html 的原理</h3><ul>\n<li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li>\n<li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；</li>\n<li>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</li>\n</ul>\n<h3 id=\"13-v-if和v-show的区别\"><a href=\"#13-v-if和v-show的区别\" class=\"headerlink\" title=\"13. v-if和v-show的区别\"></a>13. v-if和v-show的区别</h3><ul>\n<li><strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li>\n<li><strong>编译过程</strong>：v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li>\n<li><strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li>\n<li><strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li>\n<li><strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li>\n</ul>\n<h3 id=\"14-v-model-是如何实现的，语法糖实际是什么？\"><a href=\"#14-v-model-是如何实现的，语法糖实际是什么？\" class=\"headerlink\" title=\"14. v-model 是如何实现的，语法糖实际是什么？\"></a>14. v-model 是如何实现的，语法糖实际是什么？</h3><p><strong>（1）作用在表单元素上</strong> 动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;input v-model&#x3D;&quot;sth&quot; &#x2F;&gt;\n&#x2F;&#x2F;  等同于\n&lt;input \n    v-bind:value&#x3D;&quot;message&quot; \n    v-on:input&#x3D;&quot;message&#x3D;$event.target.value&quot;\n&gt;\n&#x2F;&#x2F;$event 指代当前触发的事件对象;\n&#x2F;&#x2F;$event.target 指代当前触发的事件对象的dom;\n&#x2F;&#x2F;$event.target.value 就是当前dom的value值;\n&#x2F;&#x2F;在@input方法中，value &#x3D;&gt; sth;\n&#x2F;&#x2F;在:value中,sth &#x3D;&gt; value;\n复制代码</code></pre>\n\n<p><strong>（2）作用在组件上</strong> 在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件</p>\n<p><strong>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。</strong> 因此父组件 v-model 语法糖本质上可以修改为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;child :value&#x3D;&quot;message&quot;  @input&#x3D;&quot;function(e)&#123;message &#x3D; e&#125;&quot;&gt;&lt;&#x2F;child&gt;\n复制代码</code></pre>\n\n<p>在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。 例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 父组件\n&lt;aa-input v-model&#x3D;&quot;aa&quot;&gt;&lt;&#x2F;aa-input&gt;\n&#x2F;&#x2F; 等价于\n&lt;aa-input v-bind:value&#x3D;&quot;aa&quot; v-on:input&#x3D;&quot;aa&#x3D;$event.target.value&quot;&gt;&lt;&#x2F;aa-input&gt;\n\n&#x2F;&#x2F; 子组件：\n&lt;input v-bind:value&#x3D;&quot;aa&quot; v-on:input&#x3D;&quot;onmessage&quot;&gt;&lt;&#x2F;aa-input&gt;\n\nprops:&#123;value:aa,&#125;\nmethods:&#123;\n    onmessage(e)&#123;\n        $emit(&#39;input&#39;,e.target.value)\n    &#125;\n&#125;\n复制代码</code></pre>\n\n<p>默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input <code>$emit</code>过来的值。</p>\n<h3 id=\"15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？\"><a href=\"#15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？\" class=\"headerlink\" title=\"15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？\"></a>15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？</h3><p>可以。v-model 实际上是一个语法糖，如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;input v-model&#x3D;&quot;searchText&quot;&gt;\n复制代码</code></pre>\n\n<p>实际上相当于：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;input\n  v-bind:value&#x3D;&quot;searchText&quot;\n  v-on:input&#x3D;&quot;searchText &#x3D; $event.target.value&quot;\n&gt;\n复制代码</code></pre>\n\n<p>用在自定义组件上也是同理：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;custom-input v-model&#x3D;&quot;searchText&quot;&gt;\n复制代码</code></pre>\n\n<p>相当于：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;custom-input\n  v-bind:value&#x3D;&quot;searchText&quot;\n  v-on:input&#x3D;&quot;searchText &#x3D; $event&quot;\n&gt;&lt;&#x2F;custom-input&gt;\n复制代码</code></pre>\n\n<p>显然，custom-input 与父组件的交互如下：</p>\n<ol>\n<li>父组件将<code>searchText</code>变量传入custom-input 组件，使用的 prop 名为<code>value</code>；</li>\n<li>custom-input 组件向父组件传出名为<code>input</code>的事件，父组件将接收到的值赋值给<code>searchText</code>；</li>\n</ol>\n<p>所以，custom-input 组件的实现应该类似于这样：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Vue.component(&#39;custom-input&#39;, &#123;\n  props: [&#39;value&#39;],\n  template: &#96;\n    &lt;input\n      v-bind:value&#x3D;&quot;value&quot;\n      v-on:input&#x3D;&quot;$emit(&#39;input&#39;, $event.target.value)&quot;\n    &gt;\n  &#96;\n&#125;)\n复制代码</code></pre>\n\n<h3 id=\"16-data为什么是一个函数而不是对象\"><a href=\"#16-data为什么是一个函数而不是对象\" class=\"headerlink\" title=\"16. data为什么是一个函数而不是对象\"></a>16. data为什么是一个函数而不是对象</h3><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p>\n<p>而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。</p>\n<p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p>\n<h3 id=\"17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？\"><a href=\"#17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？\" class=\"headerlink\" title=\"17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？\"></a>17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</h3><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p>\n<p><strong>（1）keep-alive</strong></p>\n<p>keep-alive有以下三个属性：</p>\n<ul>\n<li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li>\n<li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li>\n<li>max 数字，最多可以缓存多少组件实例。</li>\n</ul>\n<p>注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。</p>\n<p><strong>主要流程</strong></p>\n<ol>\n<li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li>\n<li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li>\n<li>key生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li>\n<li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li>\n</ol>\n<p><strong>（2）keep-alive 的实现</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const patternTypes: Array&lt;Function&gt; &#x3D; [String, RegExp, Array] &#x2F;&#x2F; 接收：字符串，正则，数组\n\nexport default &#123;\n  name: &#39;keep-alive&#39;,\n  abstract: true, &#x2F;&#x2F; 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n\n  props: &#123;\n    include: patternTypes, &#x2F;&#x2F; 匹配的组件，缓存\n    exclude: patternTypes, &#x2F;&#x2F; 不去匹配的组件，不缓存\n    max: [String, Number], &#x2F;&#x2F; 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限\n  &#125;,\n\n  created() &#123;\n    &#x2F;&#x2F; 用于初始化缓存虚拟DOM数组和vnode的key\n    this.cache &#x3D; Object.create(null)\n    this.keys &#x3D; []\n  &#125;,\n\n  destroyed() &#123;\n    &#x2F;&#x2F; 销毁缓存cache的组件实例\n    for (const key in this.cache) &#123;\n      pruneCacheEntry(this.cache, key, this.keys)\n    &#125;\n  &#125;,\n\n  mounted() &#123;\n    &#x2F;&#x2F; prune 削减精简[v.]\n    &#x2F;&#x2F; 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容\n    this.$watch(&#39;include&#39;, (val) &#x3D;&gt; &#123;\n      pruneCache(this, (name) &#x3D;&gt; matches(val, name))\n    &#125;)\n    this.$watch(&#39;exclude&#39;, (val) &#x3D;&gt; &#123;\n      pruneCache(this, (name) &#x3D;&gt; !matches(val, name))\n    &#125;)\n  &#125;,\n&#125;\n复制代码</code></pre>\n\n<p><strong>render函数：</strong></p>\n<ol>\n<li>会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件</li>\n<li>keep-alive 只对第一个组件有效，所以获取第一个子组件。</li>\n<li>和 keep-alive 搭配使用的一般有：动态组件 和router-view</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">render () &#123;\n  &#x2F;&#x2F;\n  function getFirstComponentChild (children: ?Array&lt;VNode&gt;): ?VNode &#123;\n    if (Array.isArray(children)) &#123;\n  for (let i &#x3D; 0; i &lt; children.length; i++) &#123;\n    const c &#x3D; children[i]\n    if (isDef(c) &amp;&amp; (isDef(c.componentOptions) || isAsyncPlaceholder(c))) &#123;\n      return c\n    &#125;\n  &#125;\n  &#125;\n  &#125;\n  const slot &#x3D; this.$slots.default &#x2F;&#x2F; 获取默认插槽\n  const vnode: VNode &#x3D; getFirstComponentChild(slot)&#x2F;&#x2F; 获取第一个子组件\n  const componentOptions: ?VNodeComponentOptions &#x3D; vnode &amp;&amp; vnode.componentOptions &#x2F;&#x2F; 组件参数\n  if (componentOptions) &#123; &#x2F;&#x2F; 是否有组件参数\n    &#x2F;&#x2F; check pattern\n    const name: ?string &#x3D; getComponentName(componentOptions) &#x2F;&#x2F; 获取组件名\n    const &#123; include, exclude &#125; &#x3D; this\n    if (\n      &#x2F;&#x2F; not included\n      (include &amp;&amp; (!name || !matches(include, name))) ||\n      &#x2F;&#x2F; excluded\n      (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))\n    ) &#123;\n      &#x2F;&#x2F; 如果不匹配当前组件的名字和include以及exclude\n      &#x2F;&#x2F; 那么直接返回组件的实例\n      return vnode\n    &#125;\n\n    const &#123; cache, keys &#125; &#x3D; this\n\n    &#x2F;&#x2F; 获取这个组件的key\n    const key: ?string &#x3D; vnode.key &#x3D;&#x3D; null\n      &#x2F;&#x2F; same constructor may get registered as different local components\n      &#x2F;&#x2F; so cid alone is not enough (#3269)\n      ? componentOptions.Ctor.cid + (componentOptions.tag ? &#96;::$&#123;componentOptions.tag&#125;&#96; : &#39;&#39;)\n      : vnode.key\n\n    if (cache[key]) &#123;\n      &#x2F;&#x2F; LRU缓存策略执行\n      vnode.componentInstance &#x3D; cache[key].componentInstance &#x2F;&#x2F; 组件初次渲染的时候componentInstance为undefined\n\n      &#x2F;&#x2F; make current key freshest\n      remove(keys, key)\n      keys.push(key)\n      &#x2F;&#x2F; 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面\n    &#125; else &#123;\n      &#x2F;&#x2F; 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除\n      &#x2F;&#x2F; 使用时间间隔最长的一个\n      cache[key] &#x3D; vnode\n      keys.push(key)\n      &#x2F;&#x2F; prune oldest entry\n      if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;\n        pruneCacheEntry(cache, keys[0], keys, this._vnode)\n      &#125;\n    &#125;\n    &#x2F;&#x2F; 将组件的keepAlive属性设置为true\n    vnode.data.keepAlive &#x3D; true &#x2F;&#x2F; 作用：判断是否要执行组件的created、mounted生命周期函数\n  &#125;\n  return vnode || (slot &amp;&amp; slot[0])\n&#125;\n复制代码</code></pre>\n\n<p>keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。</p>\n<p><strong>实现步骤：</strong></p>\n<ol>\n<li>获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</li>\n<li>通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</li>\n<li>需要缓存，判断他当前是否在缓存数组里面：</li>\n</ol>\n<ul>\n<li>存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</li>\n<li>不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</li>\n</ul>\n<ol start=\"4\">\n<li>最后将这个组件的 keepAlive 设置为 true</li>\n</ol>\n<p><strong>（3）keep-alive 本身的创建过程和 patch 过程</strong></p>\n<p>缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。</p>\n<p><strong>首次渲染</strong></p>\n<ul>\n<li>组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; core&#x2F;instance&#x2F;lifecycle\nfunction initLifecycle (vm: Component) &#123;\n  const options &#x3D; vm.$options\n\n  &#x2F;&#x2F; locate first non-abstract parent\n  let parent &#x3D; options.parent\n  if (parent &amp;&amp; !options.abstract) &#123; &#x2F;&#x2F; 判断组件的abstract属性，才往父组件里面挂载DOM\n    while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;\n      parent &#x3D; parent.$parent\n    &#125;\n    parent.$children.push(vm)\n  &#125;\n\n  vm.$parent &#x3D; parent\n  vm.$root &#x3D; parent ? parent.$root : vm\n\n  vm.$children &#x3D; []\n  vm.$refs &#x3D; &#123;&#125;\n\n  vm._watcher &#x3D; null\n  vm._inactive &#x3D; null\n  vm._directInactive &#x3D; false\n  vm._isMounted &#x3D; false\n  vm._isDestroyed &#x3D; false\n  vm._isBeingDestroyed &#x3D; false\n&#125;\n复制代码</code></pre>\n\n<ul>\n<li>判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; core&#x2F;vdom&#x2F;create-component\ninit (vnode: VNodeWithData, hydrating: boolean): ?boolean &#123;\n    if (\n      vnode.componentInstance &amp;&amp;\n      !vnode.componentInstance._isDestroyed &amp;&amp;\n      vnode.data.keepAlive\n    ) &#123; &#x2F;&#x2F; componentInstance在初次是undefined!!!\n      &#x2F;&#x2F; kept-alive components, treat as a patch\n      const mountedNode: any &#x3D; vnode &#x2F;&#x2F; work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode) &#x2F;&#x2F; prepatch函数执行的是组件更新的过程\n    &#125; else &#123;\n      const child &#x3D; vnode.componentInstance &#x3D; createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      )\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating)\n    &#125;\n  &#125;,\n复制代码</code></pre>\n\n<p>prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入</p>\n<p><strong>（4）LRU （least recently used）缓存策略</strong></p>\n<p>LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。 LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 <strong>“如果数据最近被访问过，那么将来被访问的几率也更高”</strong> 。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶</p>\n<ul>\n<li>新数据插入到链表头部</li>\n<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li>\n<li>链表满的时候，将链表尾部的数据丢弃。</li>\n</ul>\n<h3 id=\"18-nextTick-原理及作用\"><a href=\"#18-nextTick-原理及作用\" class=\"headerlink\" title=\"18. $nextTick 原理及作用\"></a>18. $nextTick 原理及作用</h3><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p>\n<p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微&#x2F;宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p>\n<p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p>\n<p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p>\n<ul>\n<li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI&#x2F;DOM 的渲染，可以减少一些无用渲染</li>\n<li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li>\n</ul>\n<p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。</p>\n<p>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在<code>$nextTick</code>中。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">this.$nextTick(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 获取数据的操作...&#125;)\n复制代码</code></pre>\n\n<p>所以，在以下情况下，会用到nextTick：</p>\n<ul>\n<li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在<code>nextTick()</code>的回调函数中。</li>\n<li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。</li>\n</ul>\n<p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在<code>nextTick()</code>的回调函数中。</p>\n<h3 id=\"19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？\"><a href=\"#19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？\" class=\"headerlink\" title=\"19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？\"></a><strong>19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</strong></h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;template&gt; \n   &lt;div&gt;\n      &lt;ul&gt;\n         &lt;li v-for&#x3D;&quot;value in obj&quot; :key&#x3D;&quot;value&quot;&gt; &#123;&#123;value&#125;&#125; &lt;&#x2F;li&gt; \n      &lt;&#x2F;ul&gt; \n      &lt;button @click&#x3D;&quot;addObjB&quot;&gt;添加 obj.b&lt;&#x2F;button&gt; \n   &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n    export default &#123; \n       data () &#123; \n          return &#123; \n              obj: &#123; \n                  a: &#39;obj.a&#39; \n              &#125; \n          &#125; \n       &#125;,\n       methods: &#123; \n          addObjB () &#123; \n              this.obj.b &#x3D; &#39;obj.b&#39; \n              console.log(this.obj) \n          &#125; \n      &#125;\n   &#125;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api <strong>$set()：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">addObjB () (\n   this.$set(this.obj, &#39;b&#39;, &#39;obj.b&#39;)\n   console.log(this.obj)\n&#125;\n复制代码</code></pre>\n\n<p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p>\n<h3 id=\"20-Vue中封装的数组方法有哪些，其如何实现页面更新\"><a href=\"#20-Vue中封装的数组方法有哪些，其如何实现页面更新\" class=\"headerlink\" title=\"20. Vue中封装的数组方法有哪些，其如何实现页面更新\"></a>20. Vue中封装的数组方法有哪些，其如何实现页面更新</h3><p>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/deaa6289a4eb45cc864822a11211ab66~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"> 那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 缓存数组原型\nconst arrayProto &#x3D; Array.prototype;\n&#x2F;&#x2F; 实现 arrayMethods.__proto__ &#x3D;&#x3D;&#x3D; Array.prototype\nexport const arrayMethods &#x3D; Object.create(arrayProto);\n&#x2F;&#x2F; 需要进行功能拓展的方法\nconst methodsToPatch &#x3D; [\n  &quot;push&quot;,\n  &quot;pop&quot;,\n  &quot;shift&quot;,\n  &quot;unshift&quot;,\n  &quot;splice&quot;,\n  &quot;sort&quot;,\n  &quot;reverse&quot;\n];\n\n&#x2F;**\n * Intercept mutating methods and emit events\n *&#x2F;\nmethodsToPatch.forEach(function(method) &#123;\n  &#x2F;&#x2F; 缓存原生数组方法\n  const original &#x3D; arrayProto[method];\n  def(arrayMethods, method, function mutator(...args) &#123;\n    &#x2F;&#x2F; 执行并缓存原生数组功能\n    const result &#x3D; original.apply(this, args);\n    &#x2F;&#x2F; 响应式处理\n    const ob &#x3D; this.__ob__;\n    let inserted;\n    switch (method) &#123;\n    &#x2F;&#x2F; push、unshift会新增索引，所以要手动observer\n      case &quot;push&quot;:\n      case &quot;unshift&quot;:\n        inserted &#x3D; args;\n        break;\n      &#x2F;&#x2F; splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。\n      case &quot;splice&quot;:\n        inserted &#x3D; args.slice(2);\n        break;\n    &#125;\n    &#x2F;&#x2F; \n    if (inserted) ob.observeArray(inserted);&#x2F;&#x2F; 获取插入的值，并设置响应式监听\n    &#x2F;&#x2F; notify change\n    ob.dep.notify();&#x2F;&#x2F; 通知依赖更新\n    &#x2F;&#x2F; 返回原生数组方法的执行结果\n    return result;\n  &#125;);\n&#125;);\n复制代码</code></pre>\n\n<p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p>\n<h3 id=\"21-Vue-单页应用与多页应用的区别\"><a href=\"#21-Vue-单页应用与多页应用的区别\" class=\"headerlink\" title=\"21. Vue 单页应用与多页应用的区别\"></a>21. Vue 单页应用与多页应用的区别</h3><p><strong>概念：</strong></p>\n<ul>\n<li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li>\n<li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li>\n</ul>\n<p><strong>区别：</strong> <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2115638a65a4e6eb0f09741cd7fd61f~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"775316ebb4c727f7c8771cc2c06e06dd.jpg\"></p>\n<h3 id=\"22-Vue-template-到-render-的过程\"><a href=\"#22-Vue-template-到-render-的过程\" class=\"headerlink\" title=\"22. Vue template 到 render 的过程\"></a>22. Vue template 到 render 的过程</h3><p>vue的模版编译过程主要如下：<strong>template -&gt; ast -&gt; render函数</strong></p>\n<p>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 将模板编译为render函数const &#123; render, staticRenderFns &#125; &#x3D; compileToFunctions(template,options&#x2F;&#x2F;省略&#125;, this)\n复制代码</code></pre>\n\n<p>CompileToFunctions中的主要逻辑如下∶ <strong>（1）调用parse方法将template转化为ast（抽象语法树）</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">constast &#x3D; parse(template.trim(), options)\n复制代码</code></pre>\n\n<ul>\n<li><strong>parse的目标</strong>：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</li>\n<li><strong>解析过程</strong>：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</li>\n</ul>\n<p>AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本</p>\n<p><strong>（2）对静态节点做优化</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">optimize(ast,options)\n复制代码</code></pre>\n\n<p>这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化</p>\n<p>深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</p>\n<p><strong>（3）生成代码</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const code &#x3D; generate(ast, options)\n复制代码</code></pre>\n\n<p>generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 <code>new Function(`` render``)</code> 生成render函数。</p>\n<h3 id=\"23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？\"><a href=\"#23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？\" class=\"headerlink\" title=\"23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？\"></a>23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>\n<p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p>\n<h3 id=\"24-简述-mixin、extends-的覆盖逻辑\"><a href=\"#24-简述-mixin、extends-的覆盖逻辑\" class=\"headerlink\" title=\"24. 简述 mixin、extends 的覆盖逻辑\"></a>24. 简述 mixin、extends 的覆盖逻辑</h3><p><strong>（1）mixin 和 extends</strong> mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p>\n<ul>\n<li>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li>\n<li>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29bcf5ee9e3e492ea8bb72f95619101b~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"bb253b1d177f421741af0e7dd0f52b5e.jpg\"> <strong>（2）mergeOptions 的执行过程</strong></p>\n<ul>\n<li>规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</li>\n<li>对未合并的选项，进行判断</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">if(!child._base) &#123;    if(child.extends) &#123;        parent &#x3D; mergeOptions(parent, child.extends, vm)    &#125;    if(child.mixins) &#123;        for(let i &#x3D; 0, l &#x3D; child.mixins.length; i &lt; l; i++)&#123;            parent &#x3D; mergeOptions(parent, child.mixins[i], vm)        &#125;    &#125;&#125;\n复制代码</code></pre>\n\n<ul>\n<li>合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</li>\n<li>返回合并结果 options。</li>\n</ul>\n<h3 id=\"25-描述下Vue自定义指令\"><a href=\"#25-描述下Vue自定义指令\" class=\"headerlink\" title=\"25. 描述下Vue自定义指令\"></a>25. 描述下Vue自定义指令</h3><p>在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;</p>\n<p><strong>（1）自定义指令基本内容</strong></p>\n<ul>\n<li><p>全局定义：<code>Vue.directive(&quot;focus&quot;,&#123;&#125;)</code></p>\n</li>\n<li><p>局部定义：<code>directives:&#123;focus:&#123;&#125;&#125;</code></p>\n</li>\n<li><p>钩子函数：指令定义对象提供钩子函数</p>\n<p>o bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>\n<p>o inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p>\n<p>o update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。</p>\n<p>o ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。</p>\n<p>o unbind：只调用一次，指令与元素解绑时调用。</p>\n</li>\n<li><p>钩子函数参数 o el：绑定元素</p>\n<p>o bing： 指令核心对象，描述指令全部信息属性</p>\n<p>o name</p>\n<p>o value</p>\n<p>o oldValue</p>\n<p>o expression</p>\n<p>o arg</p>\n<p>o modifers</p>\n<p>o vnode 虚拟节点</p>\n<p>o oldVnode：上一个虚拟节点（更新钩子函数中才有用）</p>\n</li>\n</ul>\n<p><strong>（2）使用场景</strong></p>\n<ul>\n<li>普通DOM元素进行底层操作的时候，可以使用自定义指令</li>\n<li>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</li>\n</ul>\n<p><strong>（3）使用案例</strong></p>\n<p>初级应用：</p>\n<ul>\n<li>鼠标聚焦</li>\n<li>下拉菜单</li>\n<li>相对时间转换</li>\n<li>滚动动画</li>\n</ul>\n<p>高级应用：</p>\n<ul>\n<li>自定义指令实现图片懒加载</li>\n<li>自定义指令集成第三方插件</li>\n</ul>\n<h3 id=\"26-子组件可以直接改变父组件的数据吗？\"><a href=\"#26-子组件可以直接改变父组件的数据吗？\" class=\"headerlink\" title=\"26. 子组件可以直接改变父组件的数据吗？\"></a>26. 子组件可以直接改变父组件的数据吗？</h3><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p>\n<p>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p>\n<p><strong>只能通过 <strong><code>$emit</code></strong> 派发一个自定义事件，父组件接收到后，由父组件修改。</strong></p>\n<h3 id=\"27-Vue是如何收集依赖的？\"><a href=\"#27-Vue是如何收集依赖的？\" class=\"headerlink\" title=\"27. Vue是如何收集依赖的？\"></a>27. Vue是如何收集依赖的？</h3><p>在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function defieneReactive (obj, key, val)&#123;\n  const dep &#x3D; new Dep();\n  ...\n  Object.defineProperty(obj, key, &#123;\n    ...\n    get: function reactiveGetter () &#123;\n      if(Dep.target)&#123;\n        dep.depend();\n        ...\n      &#125;\n      return val\n    &#125;\n    ...\n  &#125;)\n&#125;\n复制代码</code></pre>\n\n<p>以上只保留了关键代码，主要就是 <code>const dep = new Dep()</code>实例化一个 Dep 的实例，然后在 get 函数中通过 <code>dep.depend()</code> 进行依赖收集。 <strong>（1）Dep</strong> Dep是整个依赖收集的核心，其关键代码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Dep &#123;\n  static target;\n  subs;\n\n  constructor () &#123;\n    ...\n    this.subs &#x3D; [];\n  &#125;\n  addSub (sub) &#123;\n    this.subs.push(sub)\n  &#125;\n  removeSub (sub) &#123;\n    remove(this.sub, sub)\n  &#125;\n  depend () &#123;\n    if(Dep.target)&#123;\n      Dep.target.addDep(this)\n    &#125;\n  &#125;\n  notify () &#123;\n    const subs &#x3D; this.subds.slice();\n    for(let i &#x3D; 0;i &lt; subs.length; i++)&#123;\n      subs[i].update()\n    &#125;\n  &#125;\n&#125;\n复制代码</code></pre>\n\n<p>Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶</p>\n<p><strong>（2）Watcher</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Watcher &#123;\n  getter;\n  ...\n  constructor (vm, expression)&#123;\n    ...\n    this.getter &#x3D; expression;\n    this.get();\n  &#125;\n  get () &#123;\n    pushTarget(this);\n    value &#x3D; this.getter.call(vm, vm)\n    ...\n    return value\n  &#125;\n  addDep (dep)&#123;\n        ...\n    dep.addSub(this)\n  &#125;\n  ...\n&#125;\nfunction pushTarget (_target) &#123;\n  Dep.target &#x3D; _target\n&#125;\n复制代码</code></pre>\n\n<p>Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。</p>\n<p><strong>（3）过程</strong></p>\n<p>在实例化 Vue 时，依赖收集的相关过程如下∶ 初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。 初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">updateComponent &#x3D; () &#x3D;&gt; &#123;\n  vm._update(vm._render())\n&#125;\nnew Watcher(vm, updateComponent)\n复制代码</code></pre>\n\n<p>get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。</p>\n<p>this.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。</p>\n<h3 id=\"28-对-React-和-Vue-的理解，它们的异同\"><a href=\"#28-对-React-和-Vue-的理解，它们的异同\" class=\"headerlink\" title=\"28. 对 React 和 Vue 的理解，它们的异同\"></a>28. 对 React 和 Vue 的理解，它们的异同</h3><p><strong>相似之处：</strong></p>\n<ul>\n<li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li>\n<li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li>\n<li>都使用了Virtual DOM（虚拟DOM）提高重绘性能；</li>\n<li>都有props的概念，允许组件间的数据传递；</li>\n<li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li>\n</ul>\n<p><strong>不同之处 ：</strong></p>\n<p><strong>1）数据流</strong></p>\n<p>Vue默认支持数据双向绑定，而React一直提倡单向数据流</p>\n<p><strong>2）虚拟DOM</strong></p>\n<p>Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。</p>\n<ul>\n<li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li>\n<li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent&#x2F;shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li>\n</ul>\n<p><strong>3）组件化</strong></p>\n<p>React与Vue最大的不同是模板的编写。</p>\n<ul>\n<li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li>\n<li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li>\n</ul>\n<p>具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。 <strong>4）监听数据变化的实现原理不同</strong></p>\n<ul>\n<li>Vue 通过 getter&#x2F;setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li>\n<li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent&#x2F;shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li>\n</ul>\n<p><strong>5）高阶组件</strong></p>\n<p>react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。</p>\n<p>高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。</p>\n<p><strong>6）构建工具</strong></p>\n<p>两者都有自己的构建工具：</p>\n<ul>\n<li>React &#x3D;&#x3D;&gt; Create React APP</li>\n<li>Vue &#x3D;&#x3D;&gt; vue-cli</li>\n</ul>\n<p><strong>7）跨平台</strong></p>\n<ul>\n<li>React &#x3D;&#x3D;&gt; React Native</li>\n<li>Vue &#x3D;&#x3D;&gt; Weex</li>\n</ul>\n<h3 id=\"29-Vue的优点\"><a href=\"#29-Vue的优点\" class=\"headerlink\" title=\"29. Vue的优点\"></a>29. Vue的优点</h3><ul>\n<li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 <code>kb</code> ；</li>\n<li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li>\n<li>双向数据绑定：保留了 <code>angular</code> 的特点，在数据操作方面更为简单；</li>\n<li>组件化：保留了 <code>react</code> 的优点，实现了 <code>html</code> 的封装和重用，在构建单页面应用方面有着独特的优势；</li>\n<li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li>\n<li>虚拟DOM：<code>dom</code> 操作是非常耗费性能的，不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作，但具体操作的还是 <code>dom</code> 不过是换了另一种方式；</li>\n<li>运行速度更快：相比较于 <code>react</code> 而言，同样是操作虚拟 <code>dom</code>，就性能而言， <code>vue</code> 存在很大的优势。</li>\n</ul>\n<h3 id=\"30-assets和static的区别\"><a href=\"#30-assets和static的区别\" class=\"headerlink\" title=\"30. assets和static的区别\"></a>30. assets和static的区别</h3><p><strong>相同点：</strong> <code>assets</code> 和 <code>static</code> 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p>\n<p><strong>不相同点：</strong> <code>assets</code> 中存放的静态资源文件在项目打包时，也就是运行 <code>npm run build</code> 时会将 <code>assets</code> 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器。<code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p>\n<p><strong>建议：</strong> 将项目中 <code>template</code>需要的样式文件js文件等都可以放置在 <code>assets</code> 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p>\n<h3 id=\"31-delete和Vue-delete删除数组的区别\"><a href=\"#31-delete和Vue-delete删除数组的区别\" class=\"headerlink\" title=\"31. delete和Vue.delete删除数组的区别\"></a>31. delete和Vue.delete删除数组的区别</h3><ul>\n<li><code>delete</code> 只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li>\n<li><code>Vue.delete</code> 直接删除了数组 改变了数组的键值。</li>\n</ul>\n<h3 id=\"32-vue如何监听对象或者数组某个属性的变化\"><a href=\"#32-vue如何监听对象或者数组某个属性的变化\" class=\"headerlink\" title=\"32. vue如何监听对象或者数组某个属性的变化\"></a>32. vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p>\n<p>解决方式：</p>\n<ul>\n<li>this.$set(你要改变的数组&#x2F;对象，你要改变的位置&#x2F;key，你要改成什么value)</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">this.$set(this.arr, 0, &quot;OBKoro1&quot;); &#x2F;&#x2F; 改变数组this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); &#x2F;&#x2F; 改变对象\n复制代码</code></pre>\n\n<ul>\n<li>调用以下几个数组的方法</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">splice()、 push()、pop()、shift()、unshift()、sort()、reverse()\n复制代码</code></pre>\n\n<p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除&#x2F;添加操作</p>\n<p>vm.<code>$set</code> 的实现原理是：</p>\n<ul>\n<li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li>\n<li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li>\n</ul>\n<h3 id=\"33-什么是-mixin-？\"><a href=\"#33-什么是-mixin-？\" class=\"headerlink\" title=\"33. 什么是 mixin ？\"></a>33. 什么是 mixin ？</h3><ul>\n<li>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li>\n<li>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li>\n<li>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li>\n</ul>\n<h3 id=\"34-Vue模版编译原理\"><a href=\"#34-Vue模版编译原理\" class=\"headerlink\" title=\"34. Vue模版编译原理\"></a>34. Vue模版编译原理</h3><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p>\n<ul>\n<li><strong>解析阶段</strong>：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li>\n<li><strong>优化阶段</strong>：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li>\n<li><strong>生成阶段</strong>：将最终的AST转化为render函数字符串。</li>\n</ul>\n<h3 id=\"35-对SSR的理解\"><a href=\"#35-对SSR的理解\" class=\"headerlink\" title=\"35. 对SSR的理解\"></a>35. 对SSR的理解</h3><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p>\n<p>SSR的优势：</p>\n<ul>\n<li>更好的SEO</li>\n<li>首屏加载速度更快</li>\n</ul>\n<p>SSR的缺点：</p>\n<ul>\n<li>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</li>\n<li>当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</li>\n<li>更多的服务端负载。</li>\n</ul>\n<h3 id=\"36-Vue的性能优化有哪些\"><a href=\"#36-Vue的性能优化有哪些\" class=\"headerlink\" title=\"36. Vue的性能优化有哪些\"></a>36. Vue的性能优化有哪些</h3><p><strong>（1）编码阶段</strong></p>\n<ul>\n<li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li>\n<li>v-if和v-for不能连用</li>\n<li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li>\n<li>SPA 页面采用keep-alive缓存组件</li>\n<li>在更多的情况下，使用v-if替代v-show</li>\n<li>key保证唯一</li>\n<li>使用路由懒加载、异步组件</li>\n<li>防抖、节流</li>\n<li>第三方模块按需导入</li>\n<li>长列表滚动到可视区域动态加载</li>\n<li>图片懒加载</li>\n</ul>\n<p><strong>（2）SEO优化</strong></p>\n<ul>\n<li>预渲染</li>\n<li>服务端渲染SSR</li>\n</ul>\n<p><strong>（3）打包优化</strong></p>\n<ul>\n<li>压缩代码</li>\n<li>Tree Shaking&#x2F;Scope Hoisting</li>\n<li>使用cdn加载第三方模块</li>\n<li>多线程打包happypack</li>\n<li>splitChunks抽离公共文件</li>\n<li>sourceMap优化</li>\n</ul>\n<p><strong>（4）用户体验</strong></p>\n<ul>\n<li>骨架屏</li>\n<li>PWA</li>\n<li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li>\n</ul>\n<h3 id=\"37-对-SPA-单页面的理解，它的优缺点分别是什么？\"><a href=\"#37-对-SPA-单页面的理解，它的优缺点分别是什么？\" class=\"headerlink\" title=\"37. 对 SPA 单页面的理解，它的优缺点分别是什么？\"></a>37. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>\n<li>基于上面一点，SPA 相对对服务器压力小；</li>\n<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>\n<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>\n<li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>\n</ul>\n<h3 id=\"38-template和jsx的有什么分别？\"><a href=\"#38-template和jsx的有什么分别？\" class=\"headerlink\" title=\"38. template和jsx的有什么分别？\"></a>38. template和jsx的有什么分别？</h3><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p>\n<p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p>\n<h3 id=\"39-vue初始化页面闪动问题\"><a href=\"#39-vue初始化页面闪动问题\" class=\"headerlink\" title=\"39. vue初始化页面闪动问题\"></a>39. vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。</p>\n<p>首先：在css里加上以下代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[v-cloak] &#123;    display: none;&#125;\n复制代码</code></pre>\n\n<p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;&#123;display: &#39;block&#39;&#125;&quot;</code></p>\n<h3 id=\"40-extend-有什么作用\"><a href=\"#40-extend-有什么作用\" class=\"headerlink\" title=\"40. extend 有什么作用\"></a>40. extend 有什么作用</h3><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 创建组件构造器let Component &#x3D; Vue.extend(&#123;  template: &#39;&lt;div&gt;test&lt;&#x2F;div&gt;&#39;&#125;)&#x2F;&#x2F; 挂载到 #app 上new Component().$mount(&#39;#app&#39;)&#x2F;&#x2F; 除了上面的方式，还可以用来扩展已有的组件let SuperComponent &#x3D; Vue.extend(Component)new SuperComponent(&#123;    created() &#123;        console.log(1)    &#125;&#125;)new SuperComponent().$mount(&#39;#app&#39;)\n复制代码</code></pre>\n\n<h3 id=\"42-MVVM的优缺点\"><a href=\"#42-MVVM的优缺点\" class=\"headerlink\" title=\"42. MVVM的优缺点?\"></a>42. <strong>MVVM</strong>的优缺点?</h3><p>优点:</p>\n<ul>\n<li>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑</li>\n<li>提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码</li>\n<li>⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的</li>\n<li>⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存</li>\n<li>对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。</li>\n</ul>\n<h2 id=\"二、生命周期\"><a href=\"#二、生命周期\" class=\"headerlink\" title=\"二、生命周期\"></a>二、生命周期</h2><h3 id=\"1-说一下Vue的生命周期\"><a href=\"#1-说一下Vue的生命周期\" class=\"headerlink\" title=\"1. 说一下Vue的生命周期\"></a>1. 说一下Vue的生命周期</h3><p>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。</p>\n<ol>\n<li><strong>beforeCreate（创建前）</strong> ：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event&#x2F;watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</li>\n<li><strong>created（创建后）</strong> ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 <code>$el</code> 属性。</li>\n<li><strong>beforeMount（挂载前）</strong> ：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。</li>\n<li><strong>mounted（挂载后）</strong> ：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。</li>\n<li><strong>beforeUpdate（更新前）</strong> ：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</li>\n<li><strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>\n<li><strong>beforeDestroy（销毁前）</strong> ：实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例。</li>\n<li><strong>destroyed（销毁后）</strong> ：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li>\n</ol>\n<p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>activated</code> 钩子函数。</p>\n<h3 id=\"2-Vue-子组件和父组件执行顺序\"><a href=\"#2-Vue-子组件和父组件执行顺序\" class=\"headerlink\" title=\"2. Vue 子组件和父组件执行顺序\"></a>2. Vue 子组件和父组件执行顺序</h3><p><strong>加载渲染过程：</strong></p>\n<ol>\n<li>父组件 beforeCreate</li>\n<li>父组件 created</li>\n<li>父组件 beforeMount</li>\n<li>子组件 beforeCreate</li>\n<li>子组件 created</li>\n<li>子组件 beforeMount</li>\n<li>子组件 mounted</li>\n<li>父组件 mounted</li>\n</ol>\n<p><strong>更新过程：</strong></p>\n<ol>\n<li>父组件 beforeUpdate</li>\n<li>子组件 beforeUpdate</li>\n<li>子组件 updated</li>\n<li>父组件 updated</li>\n</ol>\n<p><strong>销毁过程：</strong></p>\n<ol>\n<li>父组件 beforeDestroy</li>\n<li>子组件 beforeDestroy</li>\n<li>子组件 destroyed</li>\n<li>父组件 destoryed</li>\n</ol>\n<h3 id=\"3-created和mounted的区别\"><a href=\"#3-created和mounted的区别\" class=\"headerlink\" title=\"3. created和mounted的区别\"></a>3. created和mounted的区别</h3><ul>\n<li>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li>\n<li>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li>\n</ul>\n<h3 id=\"4-一般在哪个生命周期请求异步数据\"><a href=\"#4-一般在哪个生命周期请求异步数据\" class=\"headerlink\" title=\"4. 一般在哪个生命周期请求异步数据\"></a>4. 一般在哪个生命周期请求异步数据</h3><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。 ​</p>\n<p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>\n<ul>\n<li>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li>\n<li>SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</li>\n</ul>\n<h3 id=\"5-keep-alive-中的生命周期哪些\"><a href=\"#5-keep-alive-中的生命周期哪些\" class=\"headerlink\" title=\"5. keep-alive 中的生命周期哪些\"></a>5. keep-alive 中的生命周期哪些</h3><p>keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。</p>\n<p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p>\n<p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。</p>\n<h2 id=\"三、组件通信\"><a href=\"#三、组件通信\" class=\"headerlink\" title=\"三、组件通信\"></a>三、组件通信</h2><p>组件通信的方式如下：</p>\n<h3 id=\"（1）-props-x2F-emit\"><a href=\"#（1）-props-x2F-emit\" class=\"headerlink\" title=\"（1） props  &#x2F;   $emit\"></a>（1） props  &#x2F;   $emit</h3><p>父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信</p>\n<h5 id=\"1-父组件向子组件传值\"><a href=\"#1-父组件向子组件传值\" class=\"headerlink\" title=\"1. 父组件向子组件传值\"></a>1. 父组件向子组件传值</h5><ul>\n<li><code>props</code>只能是父组件向子组件进行传值，<code>props</code>使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。</li>\n<li><code>props</code> 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。</li>\n<li><code>props</code>属性名规则：若在<code>props</code>中使用驼峰形式，模板中需要使用短横线的形式</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 父组件\n&lt;template&gt;\n    &lt;div id&#x3D;&quot;father&quot;&gt;\n        &lt;son :msg&#x3D;&quot;msgData&quot; :fn&#x3D;&quot;myFunction&quot;&gt;&lt;&#x2F;son&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport son from &quot;.&#x2F;son.vue&quot;;\nexport default &#123;\n    name: father,\n    data() &#123;\n        msgData: &quot;父组件数据&quot;;\n    &#125;,\n    methods: &#123;\n        myFunction() &#123;\n            console.log(&quot;vue&quot;);\n        &#125;\n    &#125;,\n    components: &#123;\n        son\n    &#125;\n&#125;;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 子组件\n&lt;template&gt;\n    &lt;div id&#x3D;&quot;son&quot;&gt;\n        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;\n        &lt;button @click&#x3D;&quot;fn&quot;&gt;按钮&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n    name: &quot;son&quot;,\n    props: [&quot;msg&quot;, &quot;fn&quot;]\n&#125;;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<h5 id=\"2-子组件向父组件传值\"><a href=\"#2-子组件向父组件传值\" class=\"headerlink\" title=\"2. 子组件向父组件传值\"></a>2. 子组件向父组件传值</h5><ul>\n<li><code>$emit</code>绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过<code>v-on</code>监听并接收参数。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 父组件\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;section&quot;&gt;\n    &lt;com-article :articles&#x3D;&quot;articleList&quot; @onEmitIndex&#x3D;&quot;onEmitIndex&quot;&gt;&lt;&#x2F;com-article&gt;\n    &lt;p&gt;&#123;&#123;currentIndex&#125;&#125;&lt;&#x2F;p&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport comArticle from &#39;.&#x2F;test&#x2F;article.vue&#39;\nexport default &#123;\n  name: &#39;comArticle&#39;,\n  components: &#123; comArticle &#125;,\n  data() &#123;\n    return &#123;\n      currentIndex: -1,\n      articleList: [&#39;红楼梦&#39;, &#39;西游记&#39;, &#39;三国演义&#39;]\n    &#125;\n  &#125;,\n  methods: &#123;\n    onEmitIndex(idx) &#123;\n      this.currentIndex &#x3D; idx\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;子组件\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;div v-for&#x3D;&quot;(item, index) in articles&quot; :key&#x3D;&quot;index&quot; @click&#x3D;&quot;emitIndex(index)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  props: [&#39;articles&#39;],\n  methods: &#123;\n    emitIndex(index) &#123;\n      this.$emit(&#39;onEmitIndex&#39;, index) &#x2F;&#x2F; 触发父组件的方法，并传递参数index\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<h3 id=\"（2）eventBus事件总线（-emit-on）\"><a href=\"#（2）eventBus事件总线（-emit-on）\" class=\"headerlink\" title=\"（2）eventBus事件总线（$emit / $on）\"></a>（2）eventBus事件总线（<code>$emit / $on</code>）</h3><p><code>eventBus</code>事件总线适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，使用步骤如下： <strong>（1）创建事件中心管理组件之间的通信</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; event-bus.js\n\nimport Vue from &#39;vue&#39;\nexport const EventBus &#x3D; new Vue()\n复制代码</code></pre>\n\n<p><strong>（2）发送事件</strong> 假设有两个兄弟组件<code>firstCom</code>和<code>secondCom</code>：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;first-com&gt;&lt;&#x2F;first-com&gt;\n    &lt;second-com&gt;&lt;&#x2F;second-com&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport firstCom from &#39;.&#x2F;firstCom.vue&#39;\nimport secondCom from &#39;.&#x2F;secondCom.vue&#39;\nexport default &#123;\n  components: &#123; firstCom, secondCom &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<p>在<code>firstCom</code>组件中发送事件：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click&#x3D;&quot;add&quot;&gt;加法&lt;&#x2F;button&gt;    \n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123;EventBus&#125; from &#39;.&#x2F;event-bus.js&#39; &#x2F;&#x2F; 引入事件中心\n\nexport default &#123;\n  data()&#123;\n    return&#123;\n      num:0\n    &#125;\n  &#125;,\n  methods:&#123;\n    add()&#123;\n      EventBus.$emit(&#39;addition&#39;, &#123;\n        num:this.num++\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<p><strong>（3）接收事件</strong> 在<code>secondCom</code>组件中发送事件：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;template&gt;\n  &lt;div&gt;求和: &#123;&#123;count&#125;&#125;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; EventBus &#125; from &#39;.&#x2F;event-bus.js&#39;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      count: 0\n    &#125;\n  &#125;,\n  mounted() &#123;\n    EventBus.$on(&#39;addition&#39;, param &#x3D;&gt; &#123;\n      this.count &#x3D; this.count + param.num;\n    &#125;)\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<p>在上述代码中，这就相当于将<code>num</code>值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。</p>\n<p>虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</p>\n<h3 id=\"（3）依赖注入（provide-x2F-inject）\"><a href=\"#（3）依赖注入（provide-x2F-inject）\" class=\"headerlink\" title=\"（3）依赖注入（provide &#x2F; inject）\"></a>（3）依赖注入（provide &#x2F; inject）</h3><p>这种方式就是Vue中的<strong>依赖注入</strong>，该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。</p>\n<p><code>provide / inject</code>是Vue提供的两个钩子，和<code>data</code>、<code>methods</code>是同级的。并且<code>provide</code>的书写形式和<code>data</code>一样。</p>\n<ul>\n<li><code>provide</code> 钩子用来发送数据或方法</li>\n<li><code>inject</code>钩子用来接收数据或方法</li>\n</ul>\n<p>在父组件中：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">provide() &#123; \n    return &#123;     \n        num: this.num  \n    &#125;;\n&#125;\n复制代码</code></pre>\n\n<p>在子组件中：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">inject: [&#39;num&#39;]\n复制代码</code></pre>\n\n<p>还可以这样写，这样写就可以访问父组件中的所有属性：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">provide() &#123;\n return &#123;\n    app: this\n  &#125;;\n&#125;\ndata() &#123;\n return &#123;\n    num: 1\n  &#125;;\n&#125;\n\ninject: [&#39;app&#39;]\nconsole.log(this.app.num)\n复制代码</code></pre>\n\n<p><strong>注意：</strong> 依赖注入所提供的属性是<strong>非响应式</strong>的。</p>\n<h3 id=\"（3）ref-x2F-refs\"><a href=\"#（3）ref-x2F-refs\" class=\"headerlink\" title=\"（3）ref &#x2F; $refs\"></a>（3）ref &#x2F; $refs</h3><p>这种方式也是实现<strong>父子组件</strong>之间的通信。</p>\n<p><code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p>\n<p>在子组件中：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">export default &#123;\n  data () &#123;\n    return &#123;\n      name: &#39;JavaScript&#39;\n    &#125;\n  &#125;,\n  methods: &#123;\n    sayHello () &#123;\n      console.log(&#39;hello&#39;)\n    &#125;\n  &#125;\n&#125;\n复制代码</code></pre>\n\n<p>在父组件中：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;template&gt;\n  &lt;child ref&#x3D;&quot;child&quot;&gt;&lt;&#x2F;component-a&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\n  import child from &#39;.&#x2F;child.vue&#39;\n  export default &#123;\n    components: &#123; child &#125;,\n    mounted () &#123;\n      console.log(this.$refs.child.name);  &#x2F;&#x2F; JavaScript\n      this.$refs.child.sayHello();  &#x2F;&#x2F; hello\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<h3 id=\"（4）-parent-children\"><a href=\"#（4）-parent-children\" class=\"headerlink\" title=\"（4）$parent / $children\"></a>（4）<code>$parent / $children</code></h3><ul>\n<li>使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</li>\n<li>使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</li>\n</ul>\n<p>在子组件中：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;span&gt;\n    &lt;p&gt;获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;&lt;&#x2F;p&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      message: &#39;Vue&#39;\n    &#125;\n  &#125;,\n  computed:&#123;\n    parentVal()&#123;\n      return this.$parent.msg;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<p>在父组件中：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 父组件中\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;hello_world&quot;&gt;\n    &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;\n    &lt;child&gt;&lt;&#x2F;child&gt;\n    &lt;button @click&#x3D;&quot;change&quot;&gt;点击改变子组件值&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport child from &#39;.&#x2F;child.vue&#39;\nexport default &#123;\n  components: &#123; child &#125;,\n  data() &#123;\n    return &#123;\n      msg: &#39;Welcome&#39;\n    &#125;\n  &#125;,\n  methods: &#123;\n    change() &#123;\n      &#x2F;&#x2F; 获取到子组件\n      this.$children[0].message &#x3D; &#39;JavaScript&#39;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<p>在上面的代码中，子组件获取到了父组件的<code>parentVal</code>值，父组件改变了子组件中<code>message</code>的值。 <strong>需要注意：</strong></p>\n<ul>\n<li>通过<code>$parent</code>访问到的是上一级父组件的实例，可以使用<code>$root</code>来访问根组件的实例</li>\n<li>在组件中使用<code>$children</code>拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li>\n<li>在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组</li>\n<li><code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></li>\n</ul>\n<h3 id=\"（5）-attrs-listeners\"><a href=\"#（5）-attrs-listeners\" class=\"headerlink\" title=\"（5）$attrs / $listeners\"></a>（5）<code>$attrs / $listeners</code></h3><p>考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？</p>\n<p>如果是用<code>props/$emit</code>来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。</p>\n<p>针对上述情况，Vue引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。</p>\n<p>先来看一下<code>inheritAttrs</code>，它的默认值true，继承所有的父组件属性除<code>props</code>之外的所有属性；<code>inheritAttrs：false</code> 只继承class属性 。</p>\n<ul>\n<li><code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li>\n<li><code>$listeners</code>：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li>\n</ul>\n<p>A组件（<code>APP.vue</code>）：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;template&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n        &#x2F;&#x2F;此处监听了两个事件，可以在B组件或者C组件中直接触发 \n        &lt;child1 :p-child1&#x3D;&quot;child1&quot; :p-child2&#x3D;&quot;child2&quot; @test1&#x3D;&quot;onTest1&quot; @test2&#x3D;&quot;onTest2&quot;&gt;&lt;&#x2F;child1&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nimport Child1 from &#39;.&#x2F;Child1.vue&#39;;\nexport default &#123;\n    components: &#123; Child1 &#125;,\n    methods: &#123;\n        onTest1() &#123;\n            console.log(&#39;test1 running&#39;);\n        &#125;,\n        onTest2() &#123;\n            console.log(&#39;test2 running&#39;);\n        &#125;\n    &#125;\n&#125;;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<p>B组件（<code>Child1.vue</code>）：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;template&gt;\n    &lt;div class&#x3D;&quot;child-1&quot;&gt;\n        &lt;p&gt;props: &#123;&#123;pChild1&#125;&#125;&lt;&#x2F;p&gt;\n        &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;&#x2F;p&gt;\n        &lt;child2 v-bind&#x3D;&quot;$attrs&quot; v-on&#x3D;&quot;$listeners&quot;&gt;&lt;&#x2F;child2&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nimport Child2 from &#39;.&#x2F;Child2.vue&#39;;\nexport default &#123;\n    props: [&#39;pChild1&#39;],\n    components: &#123; Child2 &#125;,\n    inheritAttrs: false,\n    mounted() &#123;\n        this.$emit(&#39;test1&#39;); &#x2F;&#x2F; 触发APP.vue中的test1方法\n    &#125;\n&#125;;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<p>C 组件 (<code>Child2.vue</code>)：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;template&gt;\n    &lt;div class&#x3D;&quot;child-2&quot;&gt;\n        &lt;p&gt;props: &#123;&#123;pChild2&#125;&#125;&lt;&#x2F;p&gt;\n        &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n    props: [&#39;pChild2&#39;],\n    inheritAttrs: false,\n    mounted() &#123;\n        this.$emit(&#39;test2&#39;);&#x2F;&#x2F; 触发APP.vue中的test2方法\n    &#125;\n&#125;;\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<p>在上述代码中：</p>\n<ul>\n<li>C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li>\n<li>在B组件中通过v-bind 绑定<code>$attrs</code>属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）</li>\n</ul>\n<h3 id=\"（6）总结\"><a href=\"#（6）总结\" class=\"headerlink\" title=\"（6）总结\"></a>（6）总结</h3><p><strong>（1）父子组件间通信</strong></p>\n<ul>\n<li>子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li>\n<li>通过 ref 属性给子组件设置一个名字。父组件通过 <code>$refs</code> 组件名来获得子组件，子组件通过 <code>$parent</code> 获得父组件，这样也可以实现通信。</li>\n<li>使用 provide&#x2F;inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。</li>\n</ul>\n<p><strong>（2）兄弟组件间通信</strong></p>\n<ul>\n<li>使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li>\n<li>通过 <code>$parent/$refs</code> 来获取到兄弟组件，也可以进行通信。</li>\n</ul>\n<p><strong>（3）任意组件之间</strong></p>\n<ul>\n<li>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li>\n</ul>\n<p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>\n","text":"一、Vue 基础1. Vue的基本原理当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter&#x2F;setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个...","link":"","photos":[],"count_time":{"symbolsCount":"45k","symbolsTime":"41 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81Vue-%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">一、Vue 基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Vue%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1. Vue的基本原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">2. 双向数据绑定的原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8-Object-defineProperty-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-MVVM%E3%80%81MVC%E3%80%81MVP%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4. MVVM、MVC、MVP的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Computed-%E5%92%8C-Watch-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">5. Computed 和 Watch 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-Computed-%E5%92%8C-Methods-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">6. Computed 和 Methods 的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-slot%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">7. slot是什么？有什么作用？原理是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">8. 过滤器的作用，如何实现一个过滤器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%BD%93%E5%89%8D%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">9. 如何保存页面的当前的状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">10. 常见的事件修饰符及其作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-v-if%E3%80%81v-show%E3%80%81v-html-%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">11. v-if、v-show、v-html 的原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-v-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">13. v-if和v-show的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-v-model-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E8%AF%AD%E6%B3%95%E7%B3%96%E5%AE%9E%E9%99%85%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">14. v-model 是如何实现的，语法糖实际是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-v-model-%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%94%A8%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E4%B8%8A%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%8F%AF%E4%BB%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F\"><span class=\"toc-text\">15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">16. data为什么是一个函数而不是对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E5%85%B7%E4%BD%93%E7%BC%93%E5%AD%98%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-nextTick-%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">18. $nextTick 原理及作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#19-Vue-%E4%B8%AD%E7%BB%99-data-%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B1%9E%E6%80%A7%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F\"><span class=\"toc-text\">19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-Vue%E4%B8%AD%E5%B0%81%E8%A3%85%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%85%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">20. Vue中封装的数组方法有哪些，其如何实现页面更新</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#21-Vue-%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%B8%8E%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">21. Vue 单页应用与多页应用的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#22-Vue-template-%E5%88%B0-render-%E7%9A%84%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">22. Vue template 到 render 的过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#23-Vue-data-%E4%B8%AD%E6%9F%90%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98%E5%90%8E%EF%BC%8C%E8%A7%86%E5%9B%BE%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#24-%E7%AE%80%E8%BF%B0-mixin%E3%80%81extends-%E7%9A%84%E8%A6%86%E7%9B%96%E9%80%BB%E8%BE%91\"><span class=\"toc-text\">24. 简述 mixin、extends 的覆盖逻辑</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#25-%E6%8F%8F%E8%BF%B0%E4%B8%8BVue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">25. 描述下Vue自定义指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#26-%E5%AD%90%E7%BB%84%E4%BB%B6%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%94%B9%E5%8F%98%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F\"><span class=\"toc-text\">26. 子组件可以直接改变父组件的数据吗？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#27-Vue%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E4%BE%9D%E8%B5%96%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">27. Vue是如何收集依赖的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#28-%E5%AF%B9-React-%E5%92%8C-Vue-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%BC%82%E5%90%8C\"><span class=\"toc-text\">28. 对 React 和 Vue 的理解，它们的异同</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#29-Vue%E7%9A%84%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">29. Vue的优点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#30-assets%E5%92%8Cstatic%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">30. assets和static的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#31-delete%E5%92%8CVue-delete%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">31. delete和Vue.delete删除数组的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#32-vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E6%88%96%E8%80%85%E6%95%B0%E7%BB%84%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%98%E5%8C%96\"><span class=\"toc-text\">32. vue如何监听对象或者数组某个属性的变化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#33-%E4%BB%80%E4%B9%88%E6%98%AF-mixin-%EF%BC%9F\"><span class=\"toc-text\">33. 什么是 mixin ？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#34-Vue%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">34. Vue模版编译原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#35-%E5%AF%B9SSR%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">35. 对SSR的理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#36-Vue%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">36. Vue的性能优化有哪些</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#37-%E5%AF%B9-SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">37. 对 SPA 单页面的理解，它的优缺点分别是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#38-template%E5%92%8Cjsx%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%88%86%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">38. template和jsx的有什么分别？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#39-vue%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5%E9%9D%A2%E9%97%AA%E5%8A%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">39. vue初始化页面闪动问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#40-extend-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">40. extend 有什么作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#42-MVVM%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">42. MVVM的优缺点?</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">二、生命周期</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%AF%B4%E4%B8%80%E4%B8%8BVue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">1. 说一下Vue的生命周期</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Vue-%E5%AD%90%E7%BB%84%E4%BB%B6%E5%92%8C%E7%88%B6%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">2. Vue 子组件和父组件执行顺序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-created%E5%92%8Cmounted%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">3. created和mounted的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%B8%80%E8%88%AC%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%B7%E6%B1%82%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">4. 一般在哪个生命周期请求异步数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-keep-alive-%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">5. keep-alive 中的生命周期哪些</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">三、组件通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89-props-x2F-emit\"><span class=\"toc-text\">（1） props  &#x2F;   $emit</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC\"><span class=\"toc-text\">1. 父组件向子组件传值</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC\"><span class=\"toc-text\">2. 子组件向父组件传值</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89eventBus%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%EF%BC%88-emit-on%EF%BC%89\"><span class=\"toc-text\">（2）eventBus事件总线（$emit &#x2F; $on）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88provide-x2F-inject%EF%BC%89\"><span class=\"toc-text\">（3）依赖注入（provide &#x2F; inject）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89ref-x2F-refs\"><span class=\"toc-text\">（3）ref &#x2F; $refs</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%884%EF%BC%89-parent-children\"><span class=\"toc-text\">（4）$parent &#x2F; $children</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%885%EF%BC%89-attrs-listeners\"><span class=\"toc-text\">（5）$attrs &#x2F; $listeners</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EF%BC%886%EF%BC%89%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">（6）总结</span></a></li></ol></li></ol>","author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"面试题笔记——VUE篇(下)","uid":"eb0bae97b5766c0795d8d777051a13ca","slug":"面试题笔记——VUE篇(下)","date":"2021-06-24T12:41:13.000Z","updated":"2023-04-21T08:36:21.355Z","comments":true,"path":"api/articles/面试题笔记——VUE篇(下).json","keywords":null,"cover":null,"text":"四、路由 Vue-Router 的懒加载如何实现非懒加载：import List from ‘@&#x2F;components&#x2F;list.vue’const router &#x3D; new VueRouter({ routes: [ { path: ‘&#x2F;...","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"面试题笔记——JS篇(下)","uid":"2fdea5cb1f84778b4d76cd27c9ba53f7","slug":"面试题笔记——JS篇(下)","date":"2021-06-21T13:57:16.000Z","updated":"2023-04-21T08:28:10.595Z","comments":true,"path":"api/articles/面试题笔记——JS篇(下).json","keywords":null,"cover":[],"text":"六、this&#x2F;call&#x2F;apply&#x2F;bind1. 对this对象的理解this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。 第一种是函数调用模式，当一个函数不是一个对象的属性...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}