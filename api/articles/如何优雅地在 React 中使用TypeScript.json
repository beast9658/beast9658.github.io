{"title":"如何优雅地在 React 中使用TypeScript","uid":"045012ff9de07809836ee76fe6879635","slug":"如何优雅地在 React 中使用TypeScript","date":"2021-12-18T13:48:34.000Z","updated":"2023-04-21T09:26:55.667Z","comments":true,"path":"api/articles/如何优雅地在 React 中使用TypeScript.json","keywords":null,"cover":[],"content":"<h2 id=\"一、组件声明\"><a href=\"#一、组件声明\" class=\"headerlink\" title=\"一、组件声明\"></a>一、组件声明</h2><p>在React中，组件的声明方式有两种：<strong>函数组件</strong>和<strong>类组件，</strong> 来看看这两种类型的组件声明时是如何定义TS类型的。</p>\n<h3 id=\"1-类组件\"><a href=\"#1-类组件\" class=\"headerlink\" title=\"1. 类组件\"></a>1. 类组件</h3><p>类组件的定义形式有两种：<code>React.Component&lt;P, S=&#123;&#125;&gt;</code> 和 <code>React.PureComponent&lt;P, S=&#123;&#125; SS=&#123;&#125;&gt;</code>，它们都是泛型接口，接收两个参数，第一个是props类型的定义，第二个是state类型的定义，这两个参数都不是必须的，没有时可以省略：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IProps &#123;\n  name: string;\n&#125;\n\ninterface IState &#123;\n  count: number;\n&#125;\n\nclass App extends React.Component&lt;IProps, IState&gt; &#123;\n  state &#x3D; &#123;\n    count: 0\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &#123;this.state.count&#125;\n        &#123;this.props.name&#125;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n复制代码</code></pre>\n\n<p><code>React.PureComponent&lt;P, S=&#123;&#125; SS=&#123;&#125;&gt;</code> 也是差不多的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class App extends React.PureComponent&lt;IProps, IState&gt; &#123;&#125;\n复制代码</code></pre>\n\n<p><code>React.PureComponent</code>是有第三个参数的，它表示<code>getSnapshotBeforeUpdate</code>的返回值。</p>\n<p>那PureComponent和Component 的区别是什么呢？它们的主要区别是PureComponent中的shouldComponentUpdate 是由自身进行处理的，不需要我们自己处理，所以PureComponent可以在一定程度上提升性能。</p>\n<p>有时候可能会见到这种写法，实际上和上面的效果是一样的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import React, &#123;PureComponent, Component&#125; from &quot;react&quot;;\n\nclass App extends PureComponent&lt;IProps, IState&gt; &#123;&#125;\n\nclass App extends Component&lt;IProps, IState&gt; &#123;&#125;\n复制代码</code></pre>\n\n<p>那如果定义时候我们不知道组件的props的类型，只有在调用时才知道组件类型，该怎么办呢？这时泛型就发挥作用了：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 定义组件\nclass MyComponent&lt;P&gt; extends React.Component&lt;P&gt; &#123;\n  internalProp: P;\n  constructor(props: P) &#123;\n    super(props);\n    this.internalProp &#x3D; props;\n  &#125;\n  render() &#123;\n    return (\n    \t &lt;span&gt;hello world&lt;&#x2F;span&gt;\n    );\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用组件\ntype IProps &#x3D; &#123; name: string; age: number; &#125;;\n\n&lt;MyComponent&lt;IProps&gt; name&#x3D;&quot;React&quot; age&#x3D;&#123;18&#125; &#x2F;&gt;;          &#x2F;&#x2F; Success\n&lt;MyComponent&lt;IProps&gt; name&#x3D;&quot;TypeScript&quot; age&#x3D;&quot;hello&quot; &#x2F;&gt;;  &#x2F;&#x2F; Error\n复制代码</code></pre>\n\n<h3 id=\"2-函数组件\"><a href=\"#2-函数组件\" class=\"headerlink\" title=\"2. 函数组件\"></a>2. 函数组件</h3><p>通常情况下，函数组件我是这样写的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IProps &#123;\n  name: string\n&#125;\n\nconst App &#x3D; (props: IProps) &#x3D;&gt; &#123;\n  const &#123;name&#125; &#x3D; props;\n\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;h1&gt;hello world&lt;&#x2F;h1&gt;\n      &lt;h2&gt;&#123;name&#125;&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nexport default App;\n复制代码</code></pre>\n\n<p>除此之外，函数类型还可以使用<code>React.FunctionComponent&lt;P=&#123;&#125;&gt;</code>来定义，也可以使用其简写<code>React.FC&lt;P=&#123;&#125;&gt;</code>，两者效果是一样的。它是一个泛型接口，可以接收一个参数，参数表示props的类型，这个参数不是必须的。它们就相当于这样：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type React.FC&lt;P &#x3D; &#123;&#125;&gt; &#x3D; React.FunctionComponent&lt;P&gt;\n复制代码</code></pre>\n\n<p>最终的定义形式如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IProps &#123;\n  name: string\n&#125;\n\nconst App: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const &#123;name&#125; &#x3D; props;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;h1&gt;hello world&lt;&#x2F;h1&gt;\n      &lt;h2&gt;&#123;name&#125;&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nexport default App;\n复制代码</code></pre>\n\n<p>当使用这种形式来定义函数组件时，props中默认会带有children属性，它表示该组件在调用时，其内部的元素，来看一个例子，首先定义一个组件，组件中引入了Child1和Child2组件：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import Child1 from &quot;.&#x2F;child1&quot;;\nimport Child2 from &quot;.&#x2F;child2&quot;;\n\ninterface IProps &#123;\n  name: string;\n&#125;\nconst App: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const &#123; name &#125; &#x3D; props;\n  return (\n    &lt;Child1 name&#x3D;&#123;name&#125;&gt;\n      &lt;Child2 name&#x3D;&#123;name&#125; &#x2F;&gt;\n      TypeScript\n    &lt;&#x2F;Child1&gt;\n  );\n&#125;;\n\nexport default App;\n复制代码</code></pre>\n\n<p>Child1组件结构如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IProps &#123;\n  name: string;\n&#125;\nconst Child1: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const &#123; name, children &#125; &#x3D; props;\n  console.log(children);\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;h1&gt;hello child1&lt;&#x2F;h1&gt;\n      &lt;h2&gt;&#123;name&#125;&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\nexport default Child1;\n复制代码</code></pre>\n\n<p>我们在Child1组件中打印了children属性，它的值是一个数组，包含Child2对象和后面的文本：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2a5c21d249e41b0b73abbc4a828a6c8~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>使用 React.FC 声明函数组件和普通声明的区别如下：</p>\n<ul>\n<li>React.FC 显式地定义了返回类型，其他方式是隐式推导的；</li>\n<li>React.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全；</li>\n<li>React.FC 为 children 提供了隐式的类型（ReactElement | null）。</li>\n</ul>\n<p>那如果我们在定义组件时不知道props的类型，只有调用时才知道，那就还是用泛型来定义props的类型。对于使用function定义的函数组件：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 定义组件\nfunction MyComponent&lt;P&gt;(props: P) &#123;\n  return (\n  \t&lt;span&gt;\n    \t&#123;props&#125;\n    &lt;&#x2F;span&gt;\n  );\n&#125;\n\n&#x2F;&#x2F; 使用组件\ntype IProps &#x3D; &#123; name: string; age: number; &#125;;\n\n&lt;MyComponent&lt;IProps&gt; name&#x3D;&quot;React&quot; age&#x3D;&#123;18&#125; &#x2F;&gt;;          &#x2F;&#x2F; Success\n&lt;MyComponent&lt;IProps&gt; name&#x3D;&quot;TypeScript&quot; age&#x3D;&quot;hello&quot; &#x2F;&gt;;  &#x2F;&#x2F; Error\n复制代码</code></pre>\n\n<p>如果使用箭头函数定义的函数组件，直接这样调用时错误的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const MyComponent &#x3D; &lt;P&gt;(props: P) &#123;\n  return (\n  \t&lt;span&gt;\n    \t&#123;props&#125;\n    &lt;&#x2F;span&gt;\n  );\n&#125;\n复制代码</code></pre>\n\n<p>必须使用extends关键字来定义泛型参数才能被成功解析：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const MyComponent &#x3D; &lt;P extends any&gt;(props: P) &#123;\n  return (\n  \t&lt;span&gt;\n    \t&#123;props&#125;\n    &lt;&#x2F;span&gt;\n  );\n&#125;\n复制代码</code></pre>\n\n<h2 id=\"二、React内置类型\"><a href=\"#二、React内置类型\" class=\"headerlink\" title=\"二、React内置类型\"></a>二、React内置类型</h2><h3 id=\"1-JSX-Element\"><a href=\"#1-JSX-Element\" class=\"headerlink\" title=\"1. JSX.Element\"></a>1. JSX.Element</h3><p>先来看看JSX.Element类型的声明：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">declare global &#123;\n  namespace JSX &#123;\n    interface Element extends React.ReactElement&lt;any, any&gt; &#123; &#125;\n  &#125;\n&#125;\n复制代码</code></pre>\n\n<p>可以看到，JSX.Element是ReactElement的子类型，它没有增加属性，两者是等价的。也就是说两种类型的变量可以相互赋值。 ​</p>\n<p>JSX.Element 可以通过执行 React.createElement 或是转译 JSX 获得：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const jsx &#x3D; &lt;div&gt;hello&lt;&#x2F;div&gt;\nconst ele &#x3D; React.createElement(&quot;div&quot;, null, &quot;hello&quot;);\n复制代码</code></pre>\n\n<h3 id=\"2-React-ReactElement\"><a href=\"#2-React-ReactElement\" class=\"headerlink\" title=\"2. React.ReactElement\"></a>2. React.ReactElement</h3><p>React 的类型声明文件中提供了 React.ReactElement＜T＞，它可以让我们通过传入＜T&#x2F;＞来注解类组件的实例化，它在声明文件中的定义如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface ReactElement&lt;P &#x3D; any, T extends string | JSXElementConstructor&lt;any&gt; &#x3D; string | JSXElementConstructor&lt;any&gt;&gt; &#123;\n   type: T;\n   props: P;\n   key: Key | null;\n&#125;\n复制代码</code></pre>\n\n<p>ReactElement是一个接口，包含type,props,key三个属性值。该类型的变量值只能是两种： null 和 ReactElement实例。 ​</p>\n<p>通常情况下，函数组件返回ReactElement（JXS.Element）的值。</p>\n<h3 id=\"3-React-ReactNode\"><a href=\"#3-React-ReactNode\" class=\"headerlink\" title=\"3. React.ReactNode\"></a>3. React.ReactNode</h3><p>ReactNode类型的声明如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type ReactText &#x3D; string | number;\ntype ReactChild &#x3D; ReactElement | ReactText;\n\ninterface ReactNodeArray extends Array&lt;ReactNode&gt; &#123;&#125;\ntype ReactFragment &#x3D; &#123;&#125; | ReactNodeArray;\ntype ReactNode &#x3D; ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;\n复制代码</code></pre>\n\n<p>可以看到，ReactNode是一个联合类型，它可以是string、number、ReactElement、null、boolean、ReactNodeArray。由此可知。ReactElement类型的变量可以直接赋值给ReactNode类型的变量，但反过来是不行的。</p>\n<p>类组件的 render 成员函数会返回 ReactNode 类型的值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class MyComponent extends React.Component &#123;\n\trender() &#123;\n    \treturn &lt;div&gt;hello world&lt;&#x2F;div&gt;\n    &#125;\n&#125;\n&#x2F;&#x2F; 正确\nconst component: React.ReactNode&lt;MyComponent&gt; &#x3D; &lt;MyComponent &#x2F;&gt;;\n&#x2F;&#x2F; 错误\nconst component: React.ReactNode&lt;MyComponent&gt; &#x3D; &lt;OtherComponent &#x2F;&gt;;\n复制代码</code></pre>\n\n<p>上面的代码中，给component变量设置了类型是Mycomponent类型的react实例，这时只能给其赋值其为MyComponent的实例组件。 ​</p>\n<p>通常情况下，类组件通过 render() 返回 ReactNode的值。</p>\n<h3 id=\"4-CSSProperties\"><a href=\"#4-CSSProperties\" class=\"headerlink\" title=\"4. CSSProperties\"></a>4. CSSProperties</h3><p>先来看看React的声明文件中对CSSProperties 的定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">export interface CSSProperties extends CSS.Properties&lt;string | number&gt; &#123;\n  &#x2F;**\n   * The index signature was removed to enable closed typing for style\n   * using CSSType. You&#39;re able to use type assertion or module augmentation\n   * to add properties or an index signature of your own.\n   *\n   * For examples and more information, visit:\n   * https:&#x2F;&#x2F;github.com&#x2F;frenic&#x2F;csstype#what-should-i-do-when-i-get-type-errors\n   *&#x2F;\n&#125;\n复制代码</code></pre>\n\n<p>React.CSSProperties是React基于TypeScript定义的CSS属性类型，可以将一个方法的返回值设置为该类型：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import * as React from &quot;react&quot;;\n\nconst classNames &#x3D; require(&quot;.&#x2F;sidebar.css&quot;);\n\ninterface Props &#123;\n  isVisible: boolean;\n&#125;\n\nconst divStyle &#x3D; (props: Props): React.CSSProperties &#x3D;&gt; (&#123;\n  width: props.isVisible ? &quot;23rem&quot; : &quot;0rem&quot;\n&#125;);\n\nexport const SidebarComponent: React.StatelessComponent&lt;Props&gt; &#x3D; props &#x3D;&gt; (\n  &lt;div id&#x3D;&quot;mySidenav&quot; className&#x3D;&#123;classNames.sidenav&#125; style&#x3D;&#123;divStyle(props)&#125;&gt;\n    &#123;props.children&#125;\n  &lt;&#x2F;div&gt;\n);\n复制代码</code></pre>\n\n<p>这里divStyle组件的返回值就是React.CSSProperties类型。</p>\n<p>我们还可以定义一个CSSProperties类型的变量：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const divStyle: React.CSSProperties &#x3D; &#123;\n    width: &quot;11rem&quot;,\n    height: &quot;7rem&quot;,\n    backgroundColor: &#96;rgb($&#123;props.color.red&#125;,$&#123;props.color.green&#125;, $&#123;props.color.blue&#125;)&#96;\n&#125;;\n复制代码</code></pre>\n\n<p>这个变量可以在HTML标签的style属性上使用：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;div style&#x3D;&#123;divStyle&#125; &#x2F;&gt;\n复制代码</code></pre>\n\n<p>在React的类型声明文件中，style属性的类型如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">style?: CSSProperties | undefined;\n复制代码</code></pre>\n\n<h2 id=\"三、React-Hooks\"><a href=\"#三、React-Hooks\" class=\"headerlink\" title=\"三、React Hooks\"></a>三、React Hooks</h2><h3 id=\"1-useState\"><a href=\"#1-useState\" class=\"headerlink\" title=\"1. useState\"></a>1. useState</h3><p>默认情况下，React会为根据设置的state的初始值来自动推导state以及更新函数的类型：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2407d1758d0a40a59a3df3cd38ae63c0~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>如果已知state 的类型，可以通过以下形式来自定义state的类型：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const [count, setCount] &#x3D; useState&lt;number&gt;(1)\n复制代码</code></pre>\n\n<p>如果初始值为null，需要显式地声明 state 的类型：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const [count, setCount] &#x3D; useState&lt;number | null&gt;(null); \n复制代码</code></pre>\n\n<p>如果state是一个对象，想要初始化一个空对象，可以使用断言来处理：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const [user, setUser] &#x3D; React.useState&lt;IUser&gt;(&#123;&#125; as IUser);\n复制代码</code></pre>\n\n<p>实际上，这里将空对象{}断言为IUser接口就是欺骗了TypeScript的编译器，由于后面的代码可能会依赖这个对象，所以应该在使用前及时初始化 user 的值，否则就会报错。</p>\n<p>下面是声明文件中 useState 的定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function useState&lt;S&gt;(initialState: S | (() &#x3D;&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];\n&#x2F;&#x2F; convenience overload when first argument is omitted\n\t&#x2F;**\n\t * Returns a stateful value, and a function to update it.\n   *\n   * @version 16.8.0\n   * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#usestate\n   *&#x2F;\n    \nfunction useState&lt;S &#x3D; undefined&gt;(): [S | undefined, Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;];\n  &#x2F;**\n   * An alternative to &#96;useState&#96;.\n   *\n   * &#96;useReducer&#96; is usually preferable to &#96;useState&#96; when you have complex state logic that involves\n   * multiple sub-values. It also lets you optimize performance for components that trigger deep\n   * updates because you can pass &#96;dispatch&#96; down instead of callbacks.\n   *\n   * @version 16.8.0\n   * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#usereducer\n   *&#x2F;\n复制代码</code></pre>\n\n<p>可以看到，这里定义两种形式，分别是有初始值和没有初始值的形式。</p>\n<h3 id=\"2-useEffect\"><a href=\"#2-useEffect\" class=\"headerlink\" title=\"2. useEffect\"></a>2. useEffect</h3><p>useEffect的主要作用就是处理副作用，它的第一个参数是一个函数，表示要清除副作用的操作，第二个参数是一组值，当这组值改变时，第一个参数的函数才会执行，这让我们可以控制何时运行函数来处理副作用：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">useEffect(\n  () &#x3D;&gt; &#123;\n    const subscription &#x3D; props.source.subscribe();\n    return () &#x3D;&gt; &#123;\n      subscription.unsubscribe();\n    &#125;;\n  &#125;,\n  [props.source]\n);\n复制代码</code></pre>\n\n<p>当函数的返回值不是函数或者effect函数中未定义的内容时，如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">useEffect(\n    () &#x3D;&gt; &#123;\n      subscribe();\n      return null; \n    &#125;\n);\n复制代码</code></pre>\n\n<p>TypeScript就会报错：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ed84a96cd5c403a96b55435855b5f2e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>来看看useEffect在类型声明文件中的定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; Destructors are only allowed to return void.\ntype Destructor &#x3D; () &#x3D;&gt; void | &#123; [UNDEFINED_VOID_ONLY]: never &#125;;\n\n&#x2F;&#x2F; NOTE: callbacks are _only_ allowed to return either void, or a destructor.\ntype EffectCallback &#x3D; () &#x3D;&gt; (void | Destructor);\n\n&#x2F;&#x2F; TODO (TypeScript 3.0): ReadonlyArray&lt;unknown&gt;\ntype DependencyList &#x3D; ReadonlyArray&lt;any&gt;;\n\nfunction useEffect(effect: EffectCallback, deps?: DependencyList): void;\n&#x2F;&#x2F; NOTE: this does not accept strings, but this will have to be fixed by removing strings from type Ref&lt;T&gt;\n  &#x2F;**\n   * &#96;useImperativeHandle&#96; customizes the instance value that is exposed to parent components when using\n   * &#96;ref&#96;. As always, imperative code using refs should be avoided in most cases.\n   *\n   * &#96;useImperativeHandle&#96; should be used with &#96;React.forwardRef&#96;.\n   *\n   * @version 16.8.0\n   * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#useimperativehandle\n   *&#x2F;\n复制代码</code></pre>\n\n<p>可以看到，useEffect的第一个参数只允许返回一个函数。</p>\n<h3 id=\"3-useRef\"><a href=\"#3-useRef\" class=\"headerlink\" title=\"3. useRef\"></a>3. useRef</h3><p>当使用 useRef 时，我们可以访问一个可变的引用对象。可以将初始值传递给 useRef，它用于初始化可变 ref 对象公开的当前属性。当我们使用useRef时，需要给其指定类型：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const nameInput &#x3D; React.useRef&lt;HTMLInputElement&gt;(null)\n复制代码</code></pre>\n\n<p>这里给实例的类型指定为了input输入框类型。 ​</p>\n<p>当useRef的初始值为null时，有两种创建的形式，第一种：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const nameInput &#x3D; React.useRef&lt;HTMLInputElement&gt;(null)\nnameInput.current.innerText &#x3D; &quot;hello world&quot;;\n复制代码</code></pre>\n\n<p>这种形式下，ref1.current是只读的（read-only），所以当我们将它的innerText属性重新赋值时会报以下错误：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Cannot assign to &#39;current&#39; because it is a read-only property.\n复制代码</code></pre>\n\n<p>那该怎么将current属性变为动态可变得的，先来看看类型声明文件中 useRef 是如何定义的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> function useRef&lt;T&gt;(initialValue: T): MutableRefObject&lt;T&gt;;\n &#x2F;&#x2F; convenience overload for refs given as a ref prop as they typically start with a null value\n &#x2F;**\n   * &#96;useRef&#96; returns a mutable ref object whose &#96;.current&#96; property is initialized to the passed argument\n   * (&#96;initialValue&#96;). The returned object will persist for the full lifetime of the component.\n   *\n   * Note that &#96;useRef()&#96; is useful for more than the &#96;ref&#96; attribute. It’s handy for keeping any mutable\n   * value around similar to how you’d use instance fields in classes.\n   *\n   * Usage note: if you need the result of useRef to be directly mutable, include &#96;| null&#96; in the type\n   * of the generic argument.\n   *\n   * @version 16.8.0\n   * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#useref\n   *&#x2F;\n复制代码</code></pre>\n\n<p>这段代码的第十行的告诉我们，如果需要useRef的直接可变，就需要在泛型参数中包含’| null’，所以这就是当初始值为null的第二种定义形式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const nameInput &#x3D; React.useRef&lt;HTMLInputElement | null&gt;(null);\n复制代码</code></pre>\n\n<p>这种形式下，nameInput.current就是可写的。不过两种类型在使用时都需要做类型检查：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">nameInput.current?.innerText &#x3D; &quot;hello world&quot;;\n复制代码</code></pre>\n\n<p>那么问题来了，为什么第一种写法在没有操作current时没有报错呢？因为useRef在类型定义式具有多个重载声明，第一种方式就是执行的以下函数重载：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function useRef&lt;T&gt;(initialValue: T|null): RefObject&lt;T&gt;;\n&#x2F;&#x2F; convenience overload for potentially undefined initialValue &#x2F; call with 0 arguments\n&#x2F;&#x2F; has a default to stop it from defaulting to &#123;&#125; instead\n&#x2F;**\n  * &#96;useRef&#96; returns a mutable ref object whose &#96;.current&#96; property is initialized to the passed argument\n  * (&#96;initialValue&#96;). The returned object will persist for the full lifetime of the component.\n  *\n  * Note that &#96;useRef()&#96; is useful for more than the &#96;ref&#96; attribute. It’s handy for keeping any mutable\n  * value around similar to how you’d use instance fields in classes.\n  *\n  * @version 16.8.0\n  * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#useref\n  *&#x2F;\n复制代码</code></pre>\n\n<p>从上useRef的声明中可以看到，function useRef的返回值类型化是MutableRefObject，这里面的T就是参数的类型T，所以最终nameInput 的类型就是React.MutableRefObject。 ​</p>\n<p>注意，上面用到了HTMLInputElement类型，这是一个标签类型，这个操作就是用来访问DOM元素的。</p>\n<h3 id=\"4-useCallback\"><a href=\"#4-useCallback\" class=\"headerlink\" title=\"4. useCallback\"></a>4. useCallback</h3><p>先来看看类型声明文件中对useCallback的定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> function useCallback&lt;T extends (...args: any[]) &#x3D;&gt; any&gt;(callback: T, deps: DependencyList): T;\n &#x2F;**\n  * &#96;useMemo&#96; will only recompute the memoized value when one of the &#96;deps&#96; has changed.\n  *\n  * Usage note: if calling &#96;useMemo&#96; with a referentially stable function, also give it as the input in\n  * the second argument.\n  *\n  * &#96;&#96;&#96;ts\n  * function expensive () &#123; ... &#125;\n  *\n  * function Component () &#123;\n  *   const expensiveResult &#x3D; useMemo(expensive, [expensive])\n  *   return ...\n  * &#125;\n  * &#96;&#96;&#96;\n  *\n  * @version 16.8.0\n  * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#usememo\n  *&#x2F;\n复制代码</code></pre>\n\n<p>useCallback接收一个回调函数和一个依赖数组，只有当依赖数组中的值发生变化时才会重新执行回调函数。来看一个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const add &#x3D; (a: number, b: number) &#x3D;&gt; a + b;\n\nconst memoizedCallback &#x3D; useCallback(\n  (a) &#x3D;&gt; &#123;\n    add(a, b);\n  &#125;,\n  [b]\n);\n\n复制代码</code></pre>\n\n<p>这里我们没有给回调函数中的参数a定义类型，所以下面的调用方式都不会报错：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">memoizedCallback(&quot;hello&quot;);\nmemoizedCallback(5)\n复制代码</code></pre>\n\n<p>尽管add方法的两个参数都是number类型，但是上述调用都能够用执行。所以为了更加严谨，我们需要给回调函数定义具体的类型：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const memoizedCallback &#x3D; useCallback(\n  (a: number) &#x3D;&gt; &#123;\n    add(a, b);\n  &#125;,\n  [b]\n);\n复制代码</code></pre>\n\n<p>这时候如果再给回调函数传入字符串就会报错了：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f677e598d534e7495d45c941f2062c0~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"> 所有，需要注意，在使用useCallback时需要给回调函数的参数指定类型。</p>\n<h3 id=\"5-useMemo\"><a href=\"#5-useMemo\" class=\"headerlink\" title=\"5. useMemo\"></a>5. useMemo</h3><p>先来看看类型声明文件中对useMemo的定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function useMemo&lt;T&gt;(factory: () &#x3D;&gt; T, deps: DependencyList | undefined): T;\n   &#x2F;**\n    * &#96;useDebugValue&#96; can be used to display a label for custom hooks in React DevTools.\n    *\n    * NOTE: We don’t recommend adding debug values to every custom hook.\n    * It’s most valuable for custom hooks that are part of shared libraries.\n    *\n    * @version 16.8.0\n    * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#usedebugvalue\n    *&#x2F;\n复制代码</code></pre>\n\n<p>useMemo和useCallback是非常类似的，但是它返回的是一个值，而不是函数。所以在定义useMemo时需要定义返回值的类型：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">let a &#x3D; 1;\nsetTimeout(() &#x3D;&gt; &#123;\n  a +&#x3D; 1;\n&#125;, 1000);\n\nconst calculatedValue &#x3D; useMemo&lt;number&gt;(() &#x3D;&gt; a ** 2, [a]);\n复制代码</code></pre>\n\n<p>如果返回值不一致，就会报错：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const calculatedValue &#x3D; useMemo&lt;number&gt;(() &#x3D;&gt; a + &quot;hello&quot;, [a]);\n&#x2F;&#x2F; 类型“() &#x3D;&gt; string”的参数不能赋给类型“() &#x3D;&gt; number”的参数\n复制代码</code></pre>\n\n<h3 id=\"6-useContext\"><a href=\"#6-useContext\" class=\"headerlink\" title=\"6. useContext\"></a>6. useContext</h3><p>useContext需要提供一个上下文对象，并返回所提供的上下文的值，当提供者更新上下文对象时，引用这些上下文对象的组件就会重新渲染：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const ColorContext &#x3D; React.createContext(&#123; color: &quot;green&quot; &#125;);\n\nconst Welcome &#x3D; () &#x3D;&gt; &#123;\n  const &#123; color &#125; &#x3D; useContext(ColorContext);\n  return &lt;div style&#x3D;&#123;&#123; color &#125;&#125;&gt;hello world&lt;&#x2F;div&gt;;\n&#125;;\n复制代码</code></pre>\n\n<p>在使用useContext时，会自动推断出提供的上下文对象的类型，所以并不需要我们手动设置context的类型。当前，我们也可以使用泛型来设置context的类型：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IColor &#123;\n\tcolor: string;\n&#125;\n\nconst ColorContext &#x3D; React.createContext&lt;IColor&gt;(&#123; color: &quot;green&quot; &#125;);\n复制代码</code></pre>\n\n<p>下面是useContext在类型声明文件中的定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function useContext&lt;T&gt;(context: Context&lt;T&gt;&#x2F;*, (not public API) observedBits?: number|boolean *&#x2F;): T;\n&#x2F;**\n  * Returns a stateful value, and a function to update it.\n  *\n  * @version 16.8.0\n  * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#usestate\n  *&#x2F;\n复制代码</code></pre>\n\n<h3 id=\"7-useReducer\"><a href=\"#7-useReducer\" class=\"headerlink\" title=\"7. useReducer\"></a>7. useReducer</h3><p>有时我们需要处理一些复杂的状态，并且可能取决于之前的状态。这时候就可以使用useReducer，它接收一个函数，这个函数会根据之前的状态来计算一个新的state。其语法如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const [state, dispatch] &#x3D; useReducer(reducer, initialArg, init);\n复制代码</code></pre>\n\n<p>来看下面的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const reducer &#x3D; (state, action) &#x3D;&gt; &#123;\n  switch (action.type) &#123;\n    case &#39;increment&#39;:\n      return &#123;count: state.count + 1&#125;;\n    case &#39;decrement&#39;:\n      return &#123;count: state.count - 1&#125;;\n    default:\n      throw new Error();\n  &#125;\n&#125;\n\nconst Counter &#x3D; () &#x3D;&gt; &#123;\n  const initialState &#x3D; &#123;count: 0&#125;\n  const [state, dispatch] &#x3D; useReducer(reducer, initialState);\n  \n  return (\n    &lt;&gt;\n      Count: &#123;state.count&#125;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码</code></pre>\n\n<p>当前的状态是无法推断出来的，可以给reducer函数添加类型，通过给reducer函数定义state和action来推断 useReducer 的类型，下面来修改上面的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type ActionType &#x3D; &#123;\n  type: &#39;increment&#39; | &#39;decrement&#39;;\n&#125;;\n\ntype State &#x3D; &#123; count: number &#125;;\n\nconst initialState: State &#x3D; &#123;count: 0&#125;\nconst reducer &#x3D; (state: State, action: ActionType) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; ...\n&#125;\n复制代码</code></pre>\n\n<p>这样，在Counter函数中就可以推断出类型。当我们视图使用一个不存在的类型时，就会报错：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">dispatch(&#123;type: &#39;reset&#39;&#125;);\n&#x2F;&#x2F; Error! type &#39;&quot;reset&quot;&#39; is not assignable to type &#39;&quot;increment&quot; | &quot;decrement&quot;&#39;\n复制代码</code></pre>\n\n<p>除此之外，还可以使用泛型的形式来实现reducer函数的类型定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type ActionType &#x3D; &#123;\n  type: &#39;increment&#39; | &#39;decrement&#39;;\n&#125;;\n\ntype State &#x3D; &#123; count: number &#125;;\n\nconst reducer: React.Reducer&lt;State, ActionType&gt; &#x3D; (state, action) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; ...\n&#125;\n复制代码</code></pre>\n\n<p>其实dispatch方法也是有类型的：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47a84cb6841b48c68a8974792fbf5614~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>可以看到，dispatch的类型是：React.Dispatch，上面示例的完整代码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import React, &#123; useReducer &#125; from &quot;react&quot;;\n\ntype ActionType &#x3D; &#123;\n  type: &quot;increment&quot; | &quot;decrement&quot;;\n&#125;;\n\ntype State &#x3D; &#123; count: number &#125;;\n\nconst Counter: React.FC &#x3D; () &#x3D;&gt; &#123;\n  const reducer: React.Reducer&lt;State, ActionType&gt; &#x3D; (state, action) &#x3D;&gt; &#123;\n    switch (action.type) &#123;\n      case &quot;increment&quot;:\n        return &#123; count: state.count + 1 &#125;;\n      case &quot;decrement&quot;:\n        return &#123; count: state.count - 1 &#125;;\n      default:\n        throw new Error();\n    &#125;\n  &#125;;\n\n  const initialState: State &#x3D; &#123;count: 0&#125;\n  const [state, dispatch] &#x3D; useReducer(reducer, initialState);\n\n  return (\n    &lt;&gt;\n      Count: &#123;state.count&#125;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &quot;increment&quot; &#125;)&#125;&gt;+&lt;&#x2F;button&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &quot;decrement&quot; &#125;)&#125;&gt;-&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;\n\nexport default Counter;\n\n复制代码</code></pre>\n\n<h2 id=\"四、事件处理\"><a href=\"#四、事件处理\" class=\"headerlink\" title=\"四、事件处理\"></a>四、事件处理</h2><h3 id=\"1-Event-事件类型\"><a href=\"#1-Event-事件类型\" class=\"headerlink\" title=\"1. Event 事件类型\"></a>1. Event 事件类型</h3><p>在开发中我们会经常在事件处理函数中使用event事件对象，比如在input框输入时实时获取输入的值；使用鼠标事件时，通过 clientX、clientY 获取当前指针的坐标等等。 ​</p>\n<p>我们知道，Event是一个对象，并且有很多属性，这时很多人就会把 event 类型定义为any，这样的话TypeScript就失去了它的意义，并不会对event事件进行静态检查，如果一个键盘事件触发了下面的方法，也不会报错：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const handleEvent &#x3D; (e: any) &#x3D;&gt; &#123;\n    console.log(e.clientX, e.clientY)\n&#125;\n复制代码</code></pre>\n\n<p>由于Event事件对象中有很多的属性，所以我们也不方便把所有属性及其类型定义在一个interface中，所以React在声明文件中给我们提供了Event事件对象的类型声明。</p>\n<p>常见的Event 事件对象如下：</p>\n<ul>\n<li><strong>剪切板事件对象</strong>：ClipboardEvent&lt;T &#x3D; Element&gt;</li>\n<li><strong>拖拽事件对象</strong>：DragEvent&lt;T &#x3D; Element&gt;</li>\n<li><strong>焦点事件对象</strong>：FocusEvent&lt;T &#x3D; Element&gt;</li>\n<li><strong>表单事件对象</strong>：FormEvent&lt;T &#x3D; Element&gt;</li>\n<li><strong>Change事件对象</strong>：ChangeEvent&lt;T &#x3D; Element&gt;</li>\n<li><strong>键盘事件对象</strong>：KeyboardEvent&lt;T &#x3D; Element&gt;</li>\n<li><strong>鼠标事件对象</strong>：MouseEvent&lt;T &#x3D; Element, E &#x3D; NativeMouseEvent&gt;</li>\n<li><strong>触摸事件对象</strong>：TouchEvent&lt;T &#x3D; Element&gt;</li>\n<li><strong>滚轮事件对象</strong>：WheelEvent&lt;T &#x3D; Element&gt;</li>\n<li><strong>动画事件对象</strong>：AnimationEvent&lt;T &#x3D; Element&gt;</li>\n<li><strong>过渡事件对象</strong>：TransitionEvent&lt;T &#x3D; Element&gt;</li>\n</ul>\n<p>可以看到，这些Event事件对象的泛型中都会接收一个Element元素的类型，这个类型就是我们绑定这个事件的标签元素的类型，标签元素类型将在下面的第五部分介绍。</p>\n<p>来看一个简单的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type State &#x3D; &#123;\n  text: string;\n&#125;;\n\nconst App: React.FC &#x3D; () &#x3D;&gt; &#123;  \n  const [text, setText] &#x3D; useState&lt;string&gt;(&quot;&quot;)\n\n  const onChange &#x3D; (e: React.FormEvent&lt;HTMLInputElement&gt;): void &#x3D;&gt; &#123;\n    setText(e.currentTarget.value);\n  &#125;;\n  \n  return (\n    &lt;div&gt;\n      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;text&#125; onChange&#x3D;&#123;onChange&#125; &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n复制代码</code></pre>\n\n<p>这里就给onChange方法的事件对象定义为了FormEvent类型，并且作用的对象时一个HTMLInputElement类型的标签（input标签） ​</p>\n<p>可以来看下MouseEvent事件对象和ChangeEvent事件对象的类型声明，其他事件对象的声明形似也类似：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface MouseEvent&lt;T &#x3D; Element, E &#x3D; NativeMouseEvent&gt; extends UIEvent&lt;T, E&gt; &#123;\n  altKey: boolean;\n  button: number;\n  buttons: number;\n  clientX: number;\n  clientY: number;\n  ctrlKey: boolean;\n  &#x2F;**\n    * See [DOM Level 3 Events spec](https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;uievents-key&#x2F;#keys-modifier). for a list of valid (case-sensitive) arguments to this method.\n    *&#x2F;\n  getModifierState(key: string): boolean;\n  metaKey: boolean;\n  movementX: number;\n  movementY: number;\n  pageX: number;\n  pageY: number;\n  relatedTarget: EventTarget | null;\n  screenX: number;\n  screenY: number;\n  shiftKey: boolean;\n&#125;\n\ninterface ChangeEvent&lt;T &#x3D; Element&gt; extends SyntheticEvent&lt;T&gt; &#123;\n  target: EventTarget &amp; T;\n&#125;\n复制代码</code></pre>\n\n<p>在很多事件对象的声明文件中都可以看到 EventTarget 的身影。这是因为，DOM的事件操作（监听和触发），都定义在EventTarget接口上。EventTarget 的类型声明如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\ninterface EventTarget &#123;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject | null, options?: boolean | AddEventListenerOptions): void;\n    dispatchEvent(evt: Event): boolean;\n    removeEventListener(type: string, listener?: EventListenerOrEventListenerObject | null, options?: EventListenerOptions | boolean): void;\n&#125;\n复制代码</code></pre>\n\n<p>比如在change事件中，会使用的e.target来获取当前的值，它的的类型就是EventTarget。来看下面的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;input\n\tonChange&#x3D;&#123;e &#x3D;&gt; onSourceChange(e)&#125;\n\tplaceholder&#x3D;&quot;最多30个字&quot;\n&#x2F;&gt;\n\nconst onSourceChange &#x3D; (e: React.ChangeEvent&lt;HTMLInputElement&gt;) &#x3D;&gt; &#123;\n    if (e.target.value.length &gt; 30) &#123;\n      message.error(&#39;请长度不能超过30个字，请重新输入&#39;);\n      return;\n    &#125;\n    setSourceInput(e.target.value);\n&#125;;\n复制代码</code></pre>\n\n<p>这里定义了一个input输入框，当触发onChange事件时，会调用onSourceChange方法，该方法的参数e的类型就是：React.ChangeEvent，而e.target的类型就是EventTarget：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fe5bd1f9e6745aa8c7b38457e58b672~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>在来看一个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">questionList.map(item &#x3D;&gt; (\n    &lt;div\n    \tkey&#x3D;&#123;item.id&#125;\n  \trole&#x3D;&quot;button&quot;\n  \tonClick&#x3D;&#123;e &#x3D;&gt; handleChangeCurrent(item, e)&#125;\n    &gt;\n    &#x2F;&#x2F; 组件内容...\n    &lt;&#x2F;div&gt;\n)\n\nconst handleChangeCurrent &#x3D; (item: IData, e: React.MouseEvent&lt;HTMLDivElement&gt;) &#x3D;&gt; &#123;\n    e.stopPropagation();\n    setCurrent(item);\n&#125;;\n复制代码</code></pre>\n\n<p>这点代码中，点击某个盒子，就将它设置为当前的盒子，方便执行其他操作。当鼠标点击盒子时，会触发handleChangeCurren方法，该方法有两个参数，第二个参数是event对象，在方法中执行了e.stopPropagation();是为了阻止冒泡事件，这里的stopPropagation()实际上并不是鼠标事件MouseEvent的属性，它是合成事件上的属性，来看看声明文件中的定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface MouseEvent&lt;T &#x3D; Element, E &#x3D; NativeMouseEvent&gt; extends UIEvent&lt;T, E&gt; &#123;\n  &#x2F;&#x2F;...     \n&#125;\n\ninterface UIEvent&lt;T &#x3D; Element, E &#x3D; NativeUIEvent&gt; extends SyntheticEvent&lt;T, E&gt; &#123;\n  &#x2F;&#x2F;...\n&#125;\n\ninterface SyntheticEvent&lt;T &#x3D; Element, E &#x3D; Event&gt; extends BaseSyntheticEvent&lt;E, EventTarget &amp; T, EventTarget&gt; &#123;&#125;\n\ninterface BaseSyntheticEvent&lt;E &#x3D; object, C &#x3D; any, T &#x3D; any&gt; &#123;\n  nativeEvent: E;\n  currentTarget: C;\n  target: T;\n  bubbles: boolean;\n  cancelable: boolean;\n  defaultPrevented: boolean;\n  eventPhase: number;\n  isTrusted: boolean;\n  preventDefault(): void;\n  isDefaultPrevented(): boolean;\n  stopPropagation(): void;\n  isPropagationStopped(): boolean;\n  persist(): void;\n  timeStamp: number;\n  type: string;\n&#125;\n复制代码</code></pre>\n\n<p>可以看到，这里的stopPropagation()是一层层的继承来的，最终来自于BaseSyntheticEvent合成事件类型。原生的事件集合SyntheticEvent就是继承自合成时间类型。SyntheticEvent&lt;T &#x3D; Element, E &#x3D; Event&gt;泛型接口接收当前的元素类型和事件类型，如果不介意这两个参数的类型，完全可以这样写：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;input \n  onChange&#x3D;&#123;(e: SyntheticEvent&lt;Element, Event&gt;)&#x3D;&gt;&#123;\n    &#x2F;&#x2F;... \n  &#125;&#125;\n&#x2F;&gt;\n复制代码</code></pre>\n\n<h3 id=\"2-事件处理函数类型\"><a href=\"#2-事件处理函数类型\" class=\"headerlink\" title=\"2. 事件处理函数类型\"></a>2. 事件处理函数类型</h3><p>说完事件对象类型，再来看看事件处理函数的类型。React也为我们提供了贴心的提供了事件处理函数的类型声明，来看看所有的事件处理函数的类型声明：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type EventHandler&lt;E extends SyntheticEvent&lt;any&gt;&gt; &#x3D; &#123; bivarianceHack(event: E): void &#125;[&quot;bivarianceHack&quot;];\n\ntype ReactEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;SyntheticEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 剪切板事件处理函数\ntype ClipboardEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;ClipboardEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 复合事件处理函数\ntype CompositionEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;CompositionEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 拖拽事件处理函数\ntype DragEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;DragEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 焦点事件处理函数\ntype FocusEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;FocusEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 表单事件处理函数\ntype FormEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;FormEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; Change事件处理函数\ntype ChangeEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;ChangeEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 键盘事件处理函数\ntype KeyboardEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;KeyboardEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 鼠标事件处理函数\ntype MouseEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;MouseEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 触屏事件处理函数\ntype TouchEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;TouchEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 指针事件处理函数\ntype PointerEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;PointerEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 界面事件处理函数\ntype UIEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;UIEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 滚轮事件处理函数\ntype WheelEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;WheelEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 动画事件处理函数\ntype AnimationEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;AnimationEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 过渡事件处理函数\ntype TransitionEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;TransitionEvent&lt;T&gt;&gt;;\n复制代码</code></pre>\n\n<p>这里面的T的类型也都是Element，指的是触发该事件的HTML标签元素的类型，下面第五部分会介绍。 ​</p>\n<p>EventHandler会接收一个E，它表示事件处理函数中 Event 对象的类型。bivarianceHack 是事件处理函数的类型定义，函数接收一个 Event 对象，并且其类型为接收到的泛型变量 E 的类型, 返回值为 void。 ​</p>\n<p>还看上面的那个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type State &#x3D; &#123;\n  text: string;\n&#125;;\n\nconst App: React.FC &#x3D; () &#x3D;&gt; &#123;  \n  const [text, setText] &#x3D; useState&lt;string&gt;(&quot;&quot;)\n\n  const onChange: React.ChangeEventHandler&lt;HTMLInputElement&gt; &#x3D; (e) &#x3D;&gt; &#123;\n    setText(e.currentTarget.value);\n  &#125;;\n  \n  return (\n    &lt;div&gt;\n      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;text&#125; onChange&#x3D;&#123;onChange&#125; &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n复制代码</code></pre>\n\n<p>这里给onChange方法定义了方法的类型，它是一个ChangeEventHandler的类型，并且作用的对象时一个HTMLImnputElement类型的标签（input标签）。</p>\n<h2 id=\"五、HTML标签类型\"><a href=\"#五、HTML标签类型\" class=\"headerlink\" title=\"五、HTML标签类型\"></a>五、HTML标签类型</h2><h3 id=\"1-常见标签类型\"><a href=\"#1-常见标签类型\" class=\"headerlink\" title=\"1. 常见标签类型\"></a>1. 常见标签类型</h3><p>在项目的依赖文件中可以找到HTML标签相关的类型声明文件：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/003a41c697f341a0a7279f5b8f55c62d~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>所有的HTML标签的类型都被定义在 intrinsicElements 接口中，常见的标签及其类型如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">a: HTMLAnchorElement;\nbody: HTMLBodyElement;\nbr: HTMLBRElement;\nbutton: HTMLButtonElement;\ndiv: HTMLDivElement;\nh1: HTMLHeadingElement;\nh2: HTMLHeadingElement;\nh3: HTMLHeadingElement;\nhtml: HTMLHtmlElement;\nimg: HTMLImageElement;\ninput: HTMLInputElement;\nul: HTMLUListElement;\nli: HTMLLIElement;\nlink: HTMLLinkElement;\np: HTMLParagraphElement;\nspan: HTMLSpanElement;\nstyle: HTMLStyleElement;\ntable: HTMLTableElement;\ntbody: HTMLTableSectionElement;\nvideo: HTMLVideoElement;\naudio: HTMLAudioElement;\nmeta: HTMLMetaElement;\nform: HTMLFormElement; \n复制代码</code></pre>\n\n<p>那什么时候会使用到标签类型呢，上面第四部分的Event事件类型和事件处理函数类型中都使用到了标签的类型。上面的很多的类型都需要传入一个ELement类型的泛型参数，这个泛型参数就是对应的标签类型值，可以根据标签来选择对应的标签类型。这些类型都继承自HTMLElement类型，如果使用时对类型类型要求不高，可以直接写HTMLELement。比如下面的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;Button\n\ttype&#x3D;&quot;text&quot;\n\tonClick&#x3D;&#123;(e: React.MouseEvent&lt;HTMLElement&gt;) &#x3D;&gt; &#123;\n  handleOperate();\n  e.stopPropagation();\n&#125;&#125;\n  &gt;\n    &lt;img\n\tsrc&#x3D;&#123;cancelChangeIcon&#125;\n\talt&#x3D;&quot;&quot;\n    &#x2F;&gt;\n    取消修改\n&lt;&#x2F;Button&gt;\n复制代码</code></pre>\n\n<p>其实，在直接操作DOM时也会用到标签类型，虽然我们现在通常会使用框架来开发，但是有时候也避免不了直接操作DOM。比如我在工作中，项目中的某一部分组件是通过npm来引入的其他组的组件，而在很多时候，我有需要动态的去个性化这个组件的样式，最直接的办法就是通过原生JavaScript获取到DOM元素，来进行样式的修改，这时候就会用到标签类型。 ​</p>\n<p>来看下面的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">document.querySelectorAll(&#39;.paper&#39;).forEach(item &#x3D;&gt; &#123;\n  const firstPageHasAddEle &#x3D; (item.firstChild as HTMLDivElement).classList.contains(&#39;add-ele&#39;);\n  \n  if (firstPageHasAddEle) &#123;\n    item.removeChild(item.firstChild as ChildNode);\n  &#125;\n&#125;)\n复制代码</code></pre>\n\n<p>这是我最近写的一段代码（略微删改），在第一页有个add-ele元素的时候就删除它。这里我们将item.firstChild断言成了HTMLDivElement类型，如果不断言，item.firstChild的类型就是ChildNode，而ChildNode类型中是不存在classList属性的，所以就就会报错，当我们把他断言成HTMLDivElement类型时，就不会报错了。很多时候，标签类型可以和断言（as）一起使用。 ​</p>\n<p>后面在removeChild时又使用了as断言，为什么呢？item.firstChild不是已经自动识别为ChildNode类型了吗？因为TS会认为，我们可能不能获取到类名为paper的元素，所以item.firstChild的类型就被推断为ChildNode | null，我们有时候比TS更懂我们定义的元素，知道页面一定存在paper 元素，所以可以直接将item.firstChild断言成ChildNode类型。</p>\n<h3 id=\"2-标签属性类型\"><a href=\"#2-标签属性类型\" class=\"headerlink\" title=\"2. 标签属性类型\"></a>2. 标签属性类型</h3><p>众所周知，每个HTML标签都有自己的属性，比如Input框就有value、width、placeholder、max-length等属性，下面是Input框的属性类型定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface InputHTMLAttributes&lt;T&gt; extends HTMLAttributes&lt;T&gt; &#123;\n  accept?: string | undefined;\n  alt?: string | undefined;\n  autoComplete?: string | undefined;\n  autoFocus?: boolean | undefined;\n  capture?: boolean | string | undefined;\n  checked?: boolean | undefined;\n  crossOrigin?: string | undefined;\n  disabled?: boolean | undefined;\n  enterKeyHint?: &#39;enter&#39; | &#39;done&#39; | &#39;go&#39; | &#39;next&#39; | &#39;previous&#39; | &#39;search&#39; | &#39;send&#39; | undefined;\n  form?: string | undefined;\n  formAction?: string | undefined;\n  formEncType?: string | undefined;\n  formMethod?: string | undefined;\n  formNoValidate?: boolean | undefined;\n  formTarget?: string | undefined;\n  height?: number | string | undefined;\n  list?: string | undefined;\n  max?: number | string | undefined;\n  maxLength?: number | undefined;\n  min?: number | string | undefined;\n  minLength?: number | undefined;\n  multiple?: boolean | undefined;\n  name?: string | undefined;\n  pattern?: string | undefined;\n  placeholder?: string | undefined;\n  readOnly?: boolean | undefined;\n  required?: boolean | undefined;\n  size?: number | undefined;\n  src?: string | undefined;\n  step?: number | string | undefined;\n  type?: string | undefined;\n  value?: string | ReadonlyArray&lt;string&gt; | number | undefined;\n  width?: number | string | undefined;\n\n  onChange?: ChangeEventHandler&lt;T&gt; | undefined;\n&#125;\n复制代码</code></pre>\n\n<p>如果我们需要直接操作DOM，就可能会用到元素属性类型，常见的元素属性类型如下：</p>\n<ul>\n<li>HTML属性类型：HTMLAttributes</li>\n<li>按钮属性类型：ButtonHTMLAttributes</li>\n<li>表单属性类型：FormHTMLAttributes</li>\n<li>图片属性类型：ImgHTMLAttributes</li>\n<li>输入框属性类型：InputHTMLAttributes</li>\n<li>链接属性类型：LinkHTMLAttributes</li>\n<li>meta属性类型：MetaHTMLAttributes</li>\n<li>选择框属性类型：SelectHTMLAttributes</li>\n<li>表格属性类型：TableHTMLAttributes</li>\n<li>输入区属性类型：TextareaHTMLAttributes</li>\n<li>视频属性类型：VideoHTMLAttributes</li>\n<li>SVG属性类型：SVGAttributes</li>\n<li>WebView属性类型：WebViewHTMLAttributes</li>\n</ul>\n<p>一般情况下，我们是很少需要在项目中显式的去定义标签属性的类型。如果子级去封装组件库的话，这些属性就能发挥它们的作用了。来看例子（来源于网络，仅供学习）：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import React from &#39;react&#39;;\nimport classNames from &#39;classnames&#39;\n\nexport enum ButtonSize &#123;\n    Large &#x3D; &#39;lg&#39;,\n    Small &#x3D; &#39;sm&#39;\n&#125;\n\nexport enum ButtonType &#123;\n    Primary &#x3D; &#39;primary&#39;,\n    Default &#x3D; &#39;default&#39;,\n    Danger &#x3D; &#39;danger&#39;,\n    Link &#x3D; &#39;link&#39;\n&#125;\n\ninterface BaseButtonProps &#123;\n    className?: string;\n    disabled?: boolean;\n    size?: ButtonSize;\n    btnType?: ButtonType;\n    children: React.ReactNode;\n    href?: string;    \n&#125;\n\ntype NativeButtonProps &#x3D; BaseButtonProps &amp; React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt; &#x2F;&#x2F; 使用 交叉类型（&amp;） 获得我们自己定义的属性和原生 button 的属性\ntype AnchorButtonProps &#x3D; BaseButtonProps &amp; React.AnchorHTMLAttributes&lt;HTMLAnchorElement&gt; &#x2F;&#x2F; 使用 交叉类型（&amp;） 获得我们自己定义的属性和原生 a标签 的属性\n\nexport type ButtonProps &#x3D; Partial&lt;NativeButtonProps &amp; AnchorButtonProps&gt; &#x2F;&#x2F;使用 Partial&lt;&gt; 使两种属性可选\n\nconst Button: React.FC&lt;ButtonProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n    const &#123; \n        disabled,\n        className, \n        size,\n        btnType,\n        children,\n        href,\n        ...restProps  \n    &#125; &#x3D; props;\n\n    const classes &#x3D; classNames(&#39;btn&#39;, className, &#123;\n        [&#96;btn-$&#123;btnType&#125;&#96;]: btnType,\n        [&#96;btn-$&#123;size&#125;&#96;]: size,\n        &#39;disabled&#39;: (btnType &#x3D;&#x3D;&#x3D; ButtonType.Link) &amp;&amp; disabled  &#x2F;&#x2F; 只有 a 标签才有 disabled 类名，button没有\n    &#125;)\n\n    if(btnType &#x3D;&#x3D;&#x3D; ButtonType.Link &amp;&amp; href) &#123;\n        return (\n            &lt;a \n            \tclassName&#x3D;&#123;classes&#125;\n            \thref&#x3D;&#123;href&#125;\n            \t&#123;...restProps&#125;\n            &gt;\n                &#123;children&#125;\n            &lt;&#x2F;a&gt;\n        )\n\n    &#125; else &#123;\n        return (\n            &lt;button \n            \tclassName&#x3D;&#123;classes&#125;\n            \tdisabled&#x3D;&#123;disabled&#125; &#x2F;&#x2F; button元素默认有disabled属性，所以即便没给他设置样式也会和普通button有一定区别\n\n            \t&#123;...restProps&#125;\n            &gt;\n                &#123;children&#125;\n            &lt;&#x2F;button&gt;\n        )\n    &#125;\n&#125;\n\nButton.defaultProps &#x3D; &#123;\n    disabled: false,\n    btnType: ButtonType.Default\n&#125;\n\nexport default Button;\n复制代码</code></pre>\n\n<p>这段代码就是用来封装一个buttom按钮，在button的基础上添加了一些自定义属性，比如上面将button的类型使用交叉类型（&amp;）获得自定义属性和原生 button 属性 ：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type NativeButtonProps &#x3D; BaseButtonProps &amp; React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt; \n复制代码</code></pre>\n\n<p>可以看到，标签属性类型在封装组件库时还是很有用的，更多用途可以自己探索~</p>\n<h2 id=\"六、工具泛型\"><a href=\"#六、工具泛型\" class=\"headerlink\" title=\"六、工具泛型\"></a>六、工具泛型</h2><p>在项目中使用一些工具泛型可以提高我们的开发效率，少写很多类型定义。下面来看看有哪些常见的工具泛型，以及其使用方式。</p>\n<h3 id=\"1-Partial\"><a href=\"#1-Partial\" class=\"headerlink\" title=\"1. Partial\"></a>1. Partial</h3><p>Partial 作用是<strong>将传入的属性变为可选项</strong>。适用于对类型结构不明确的情况。它使用了两个关键字：keyof和in，先来看看他们都是什么含义。keyof 可以用来取得接口的所有 key 值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IPerson &#123;\n  name: string;\n  age: number;\n  height: number;\n&#125;\ntype T &#x3D; keyof IPerson \n&#x2F;&#x2F; T 类型为： &quot;name&quot; | &quot;age&quot; | &quot;number&quot;\n复制代码</code></pre>\n\n<p>in关键字可以遍历枚举类型,：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type Person &#x3D; &quot;name&quot; | &quot;age&quot; | &quot;number&quot;\ntype Obj &#x3D;  &#123;\n  [p in Keys]: any\n&#125; \n&#x2F;&#x2F; Obj类型为： &#123; name: any, age: any, number: any &#125;\n复制代码</code></pre>\n\n<p>keyof 可以产生联合类型, in 可以遍历枚举类型, 所以经常一起使用, 下面是Partial工具泛型的定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Make all properties in T optional\n * 将T中的所有属性设置为可选\n *&#x2F;\ntype Partial&lt;T&gt; &#x3D; &#123;\n    [P in keyof T]?: T[P];\n&#125;;\n复制代码</code></pre>\n\n<p>这里，keyof T 获取 T 所有属性名, 然后使用 in 进行遍历, 将值赋给 P, 最后 T[P] 取得相应属性的值。中间的?就用来将属性设置为可选。</p>\n<p>使用示例如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IPerson &#123;\n  name: string;\n  age: number;\n  height: number;\n&#125;\n\nconst person: Partial&lt;IPerson&gt; &#x3D; &#123;\n  name: &quot;zhangsan&quot;;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"2-Required\"><a href=\"#2-Required\" class=\"headerlink\" title=\"2. Required\"></a>2. Required</h3><p>Required 的作用是将传入的属性变为必选项，和上面的工具泛型恰好相反，其声明如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Make all properties in T required\n * 将T中的所有属性设置为必选\n *&#x2F;\ntype Required&lt;T&gt; &#x3D; &#123;\n    [P in keyof T]-?: T[P];\n&#125;;\n复制代码</code></pre>\n\n<p>可以看到，这里使用-?将属性设置为必选，可以理解为减去问号。适用形式和上面的Partial差不多：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IPerson &#123;\n  name?: string;\n  age?: number;\n  height?: number;\n&#125;\n\nconst person: Required&lt;IPerson&gt; &#x3D; &#123;\n  name: &quot;zhangsan&quot;;\n  age: 18;\n  height: 180;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"3-Readonly\"><a href=\"#3-Readonly\" class=\"headerlink\" title=\"3. Readonly\"></a>3. Readonly</h3><p>将T类型的所有属性设置为只读（readonly），构造出来类型的属性不能被再次赋值。Readonly的声明形式如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Make all properties in T readonly\n *&#x2F;\ntype Readonly&lt;T&gt; &#x3D; &#123;\n    readonly [P in keyof T]: T[P];\n&#125;;\n复制代码</code></pre>\n\n<p>使用示例如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IPerson &#123;\n  name: string;\n  age: number;\n&#125;\n\nconst person: Readonly&lt;IPerson&gt; &#x3D; &#123;\n  name: &quot;zhangsan&quot;,\n  age: 18\n&#125;\n\nperson.age &#x3D; 20;  &#x2F;&#x2F;  Error: cannot reassign a readonly property\n复制代码</code></pre>\n\n<p>可以看到，通过 Readonly 将IPerson的属性转化成了只读，不能再进行赋值操作。</p>\n<h3 id=\"4-Pick-lt-T-K-extends-keyof-T-gt\"><a href=\"#4-Pick-lt-T-K-extends-keyof-T-gt\" class=\"headerlink\" title=\"4. Pick&lt;T, K extends keyof T&gt;\"></a>4. Pick&lt;T, K extends keyof T&gt;</h3><p>从T类型中挑选部分属性K来构造新的类型。它的声明形式如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * From T, pick a set of properties whose keys are in the union K\n *&#x2F;\ntype Pick&lt;T, K extends keyof T&gt; &#x3D; &#123;\n    [P in K]: T[P];\n&#125;;\n复制代码</code></pre>\n\n<p>使用示例如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IPerson &#123;\n  name: string;\n  age: number;\n  height: number;\n&#125;\n\nconst person: Pick&lt;IPerson, &quot;name&quot; | &quot;age&quot;&gt; &#x3D; &#123;\n  name: &quot;zhangsan&quot;,\n  age: 18\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"5-Record-lt-K-extends-keyof-any-T-gt\"><a href=\"#5-Record-lt-K-extends-keyof-any-T-gt\" class=\"headerlink\" title=\"5. Record&lt;K extends keyof any, T&gt;\"></a>5. Record&lt;K extends keyof any, T&gt;</h3><p>Record 用来构造一个类型，其属性名的类型为K，属性值的类型为T。这个工具泛型可用来将某个类型的属性映射到另一个类型上，下面是其声明形式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Construct a type with a set of properties K of type T\n *&#x2F;\ntype Record&lt;K extends keyof any, T&gt; &#x3D; &#123;\n    [P in K]: T;\n&#125;;\n复制代码</code></pre>\n\n<p>使用示例如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IPageinfo &#123;\n    title: string;\n&#125;\n\ntype IPage &#x3D; &#39;home&#39; | &#39;about&#39; | &#39;contact&#39;;\n\nconst page: Record&lt;IPage, IPageinfo&gt; &#x3D; &#123;\n    about: &#123;title: &#39;about&#39;&#125;,\n    contact: &#123;title: &#39;contact&#39;&#125;,\n    home: &#123;title: &#39;home&#39;&#125;,\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"6-Exclude-lt-T-U-gt\"><a href=\"#6-Exclude-lt-T-U-gt\" class=\"headerlink\" title=\"6. Exclude&lt;T, U&gt;\"></a>6. Exclude&lt;T, U&gt;</h3><p>Exclude 就是从一个联合类型中排除掉属于另一个联合类型的子集，下面是其声明的形式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Exclude from T those types that are assignable to U\n *&#x2F;\ntype Exclude&lt;T, U&gt; &#x3D; T extends U ? never : T;\n复制代码</code></pre>\n\n<p>使用示例如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IPerson &#123;\n  name: string;\n  age: number;\n  height: number;\n&#125;\n\nconst person: Exclude&lt;IPerson, &quot;age&quot; | &quot;sex&quot;&gt; &#x3D; &#123;\n  name: &quot;zhangsan&quot;;\n  height: 180;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"7-Omit-lt-T-K-extends-keyof-any-gt\"><a href=\"#7-Omit-lt-T-K-extends-keyof-any-gt\" class=\"headerlink\" title=\"7. Omit&lt;T, K extends keyof any&gt;\"></a>7. Omit&lt;T, K extends keyof any&gt;</h3><p>上面的Pick 和 Exclude 都是最基础基础的工具泛型，很多时候用 Pick 或者 Exclude 还不如直接写类型更直接。而 Omit 就基于这两个来做的一个更抽象的封装，它允许从一个对象中剔除若干个属性，剩下的就是需要的新类型。下面是它的声明形式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Construct a type with the properties of T except for those in type K.\n *&#x2F;\ntype Omit&lt;T, K extends keyof any&gt; &#x3D; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;\n复制代码</code></pre>\n\n<p>使用示例如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface IPerson &#123;\n  name: string;\n  age: number;\n  height: number;\n&#125;\n\nconst person: Omit&lt;IPerson, &quot;age&quot; | &quot;height&quot;&gt; &#x3D; &#123;\n  name: &quot;zhangsan&quot;;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"8-ReturnType\"><a href=\"#8-ReturnType\" class=\"headerlink\" title=\"8. ReturnType\"></a>8. ReturnType</h3><p>ReturnType会返回函数返回值的类型，其声明形式如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * Obtain the return type of a function type\n *&#x2F;\ntype ReturnType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (...args: any) &#x3D;&gt; infer R ? R : any;\n复制代码</code></pre>\n\n<p>使用示例如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function foo(type): boolean &#123;\n  return type &#x3D;&#x3D;&#x3D; 0\n&#125;\n\ntype FooType &#x3D; ReturnType&lt;typeof foo&gt;\n复制代码</code></pre>\n\n<p>这里使用 typeof 是为了获取 foo 的函数签名，等价于 (type: any) &#x3D;&gt; boolean。</p>\n<h2 id=\"七、Axios-封装\"><a href=\"#七、Axios-封装\" class=\"headerlink\" title=\"七、Axios 封装\"></a>七、Axios 封装</h2><p>在React项目中，我们经常使用Axios库进行数据请求，Axios 是基于 Promise 的 HTTP 库，可以在浏览器和 node.js 中使用。Axios 具备以下特性：</p>\n<ul>\n<li>从浏览器中创建 XMLHttpRequests；</li>\n<li>从 node.js 创建 HTTP 请求；</li>\n<li>支持 Promise API；</li>\n<li>拦截请求和响应；</li>\n<li>转换请求数据和响应数据；</li>\n<li>取消请求；</li>\n<li>自动转换 JSON 数据；</li>\n<li>客户端支持防御 XSRF。</li>\n</ul>\n<p>Axios的基本使用就不再多介绍了。为了更好地调用，做一些全局的拦截，通常会对Axios进行封装，下面就使用TypeScript对Axios进行简单封装，使其同时能够有很好的类型支持。Axios是自带声明文件的，所以我们无需额外的操作。 ​</p>\n<p>下面来看基本的封装：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import axios, &#123; AxiosInstance, AxiosRequestConfig, AxiosPromise,AxiosResponse &#125; from &#39;axios&#39;; &#x2F;&#x2F; 引入axios和定义在node_modules&#x2F;axios&#x2F;index.ts文件里的类型声明\n\n &#x2F;&#x2F; 定义接口请求类，用于创建axios请求实例\nclass HttpRequest &#123;\n  &#x2F;&#x2F; 接收接口请求的基本路径\n  constructor(public baseUrl: string) &#123; \n    this.baseUrl &#x3D; baseUrl;\n  &#125;\n  \n  &#x2F;&#x2F; 调用接口时调用实例的这个方法，返回AxiosPromise\n  public request(options: AxiosRequestConfig): AxiosPromise &#123; \n    &#x2F;&#x2F; 创建axios实例，它是函数，同时这个函数包含多个属性\n    const instance: AxiosInstance &#x3D; axios.create() \n    &#x2F;&#x2F; 合并基础路径和每个接口单独传入的配置，比如url、参数等\n    options &#x3D; this.mergeConfig(options) \n    &#x2F;&#x2F; 调用interceptors方法使拦截器生效\n    this.interceptors(instance, options.url) \n    &#x2F;&#x2F; 返回AxiosPromise\n    return instance(options) \n  &#125;\n  \n  &#x2F;&#x2F; 用于添加全局请求和响应拦截\n  private interceptors(instance: AxiosInstance, url?: string) &#123; \n    &#x2F;&#x2F; 请求和响应拦截\n  &#125;\n  \n  &#x2F;&#x2F; 用于合并基础路径配置和接口单独配置\n  private mergeConfig(options: AxiosRequestConfig): AxiosRequestConfig &#123; \n    return Object.assign(&#123; baseURL: this.baseUrl &#125;, options);\n  &#125;\n&#125;\nexport default HttpRequest;\n复制代码</code></pre>\n\n<p>通常baseUrl在开发环境的和生产环境的路径是不一样的，所以可以根据当前是开发环境还是生产环境做判断，应用不同的基础路径。这里要写在一个配置文件里：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">export default &#123;\n    api: &#123;\n        devApiBaseUrl: &#39;&#x2F;test&#x2F;api&#x2F;xxx&#39;,\n        proApiBaseUrl: &#39;&#x2F;api&#x2F;xxx&#39;,\n    &#125;,\n&#125;;\n复制代码</code></pre>\n\n<p>在上面的文件中引入这个配置：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import &#123; api: &#123; devApiBaseUrl, proApiBaseUrl &#125; &#125; from &#39;@&#x2F;config&#39;;\nconst apiBaseUrl &#x3D; env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? proApiBaseUrl : devApiBaseUrl;\n复制代码</code></pre>\n\n<p>之后就可以将apiBaseUrl作为默认值传入HttpRequest的参数：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class HttpRequest &#123; \n  constructor(public baseUrl: string &#x3D; apiBaseUrl) &#123; \n    this.baseUrl &#x3D; baseUrl;\n  &#125;\n复制代码</code></pre>\n\n<p>接下来可以完善一下拦截器类，在类中interceptors方法内添加请求拦截器和响应拦截器，实现对所有接口请求的统一处理：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private interceptors(instance: AxiosInstance, url?: string) &#123;\n  \t&#x2F;&#x2F; 请求拦截\n    instance.interceptors.request.use((config: AxiosRequestConfig) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 接口请求的所有配置，可以在axios.defaults修改配置\n      return config\n    &#125;,\n    (error) &#x3D;&gt; &#123;\n      return Promise.reject(error)\n    &#125;)\n \t\n  \t&#x2F;&#x2F; 响应拦截\n    instance.interceptors.response.use((res: AxiosResponse) &#x3D;&gt; &#123;\n      const &#123; data &#125; &#x3D; res \n      const &#123; code, msg &#125; &#x3D; data\n      if (code !&#x3D;&#x3D; 0) &#123;\n        console.error(msg) \n      &#125;\n      return res\n    &#125;,\n    (error) &#x3D;&gt; &#123; \n      return Promise.reject(error)\n    &#125;)\n  &#125;\n复制代码</code></pre>\n\n<p>到这里封装的就差不多了，一般服务端会将状态码、提示信息和数据封装在一起，然后作为数据返回，所以所有请求返回的数据格式都是一样的，所以就可以定义一个接口来指定返回的数据结构，可以定义一个接口：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">export interface ResponseData &#123;\n  code: number\n  data?: any\n  msg: string\n&#125;\n复制代码</code></pre>\n\n<p>接下来看看使用TypeScript封装的Axios该如何使用。可以先定义一个请求实例：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import HttpRequest from &#39;@&#x2F;utils&#x2F;axios&#39;\nexport * from &#39;@&#x2F;utils&#x2F;axios&#39;\nexport default new HttpRequest()\n复制代码</code></pre>\n\n<p>这里把请求类导入进来，默认导出这个类的实例。之后创建一个登陆接口请求方法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import axios, &#123; ResponseData &#125; from &#39;.&#x2F;index&#39;\nimport &#123; AxiosPromise &#125; from &#39;axios&#39;\n\ninterface ILogin &#123;\n  user: string;\n  password: number | string\n&#125;\n\nexport const loginReq &#x3D; (data: ILogin): AxiosPromise&lt;ResponseData&gt; &#x3D;&gt; &#123;\n  return axios.request(&#123;\n    url: &#39;&#x2F;api&#x2F;user&#x2F;login&#39;,\n    data,\n    method: &#39;POST&#39;\n  &#125;)\n&#125;\n复制代码</code></pre>\n\n<p>这里封装登录请求方法loginReq，他的参数必须是我们定义的ILogin接口的类型。这个方法返回一个类型为<code>AxiosPromise</code>的Promise，AxiosPromise是axios声明文件内置的类型，可以传入一个泛型变量参数，用于指定返回的结果中data字段的类型。 ​</p>\n<p>接下来可以调用一下这个登录的接口：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import &#123; loginReq &#125; from &#39;@&#x2F;api&#x2F;user&#39;\n\nconst Home: FC &#x3D; () &#x3D;&gt; &#123;\n  const login &#x3D; (params) &#x3D;&gt; &#123;\n  \tloginReq(params).then((res) &#x3D;&gt; &#123;\n    \tconsole.log(res.data.code)\n  \t&#125;)\t\n  &#125;  \n&#125;\n复制代码</code></pre>\n\n<p>通过这种方式，当我们调用loginReq接口时，就会提示我们，参数的类型是ILogin，需要传入几个参数。这样编写代码的体验就会好很多。</p>\n<h2 id=\"八-其他\"><a href=\"#八-其他\" class=\"headerlink\" title=\"八. 其他\"></a>八. 其他</h2><h3 id=\"1-import-React\"><a href=\"#1-import-React\" class=\"headerlink\" title=\"1. import React\"></a>1. import React</h3><p>在React项目中使用TypeScript时，普通组件文件后缀为.tsx，公共方法文件后缀为.ts。在. tsx 文件中导入 React 的方式如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import * as React from &#39;react&#39;\nimport * as ReactDOM from &#39;react-dom&#39;\n复制代码</code></pre>\n\n<p>这是一种面向未来的导入方式，如果想在项目中使用以下导入方式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import React from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\n复制代码</code></pre>\n\n<p>就需要在tsconfig.json配置文件中进行如下配置：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&quot;compilerOptions&quot;: &#123;\n    &#x2F;&#x2F; 允许默认从没有默认导出的模块导入。\n    &quot;allowSyntheticDefaultImports&quot;: true,\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"2-Types-or-Interfaces？\"><a href=\"#2-Types-or-Interfaces？\" class=\"headerlink\" title=\"2. Types or Interfaces？\"></a>2. Types or Interfaces？</h3><p>我们可以使用types或者Interfaces来定义类型吗，那么该如何选择他俩呢？建议如下：</p>\n<ul>\n<li>在定义公共 API 时(比如编辑一个库）使用 interface，这样可以方便使用者继承接口，这样允许使用最通过声明合并来扩展它们；</li>\n<li>在定义组件属性（Props）和状态（State）时，建议使用 type，因为 type 的约束性更强。</li>\n</ul>\n<p>interface 和 type 在 ts 中是两个不同的概念，但在 React 大部分使用的 case 中，interface 和 type 可以达到相同的功能效果，type 和 interface 最大的区别是：type 类型不能二次编辑，而 interface 可以随时扩展：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">interface Animal &#123;\n  name: string\n&#125;\n\n&#x2F;&#x2F; 可以继续在原属性基础上，添加新属性：color\ninterface Animal &#123;\n  color: string\n&#125;\n\ntype Animal &#x3D; &#123;\n  name: string\n&#125;\n&#x2F;&#x2F; type类型不支持属性扩展\n&#x2F;&#x2F; Error: Duplicate identifier &#39;Animal&#39;\ntype Animal &#x3D; &#123;\n  color: string\n&#125;\n复制代码</code></pre>\n\n<p>type对于联合类型是很有用的，比如：type Type &#x3D; TypeA | TypeB。而interface更适合声明字典类行，然后定义或者扩展它。</p>\n<h3 id=\"3-懒加载类型\"><a href=\"#3-懒加载类型\" class=\"headerlink\" title=\"3. 懒加载类型\"></a>3. 懒加载类型</h3><p>如果我们想在React router中使用懒加载，React也为我们提供了懒加载方法的类型，来看下面的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">export interface RouteType &#123;\n    pathname: string;\n    component: LazyExoticComponent&lt;any&gt;;\n    exact: boolean;\n    title?: string;\n    icon?: string;\n    children?: RouteType[];\n&#125;\nexport const AppRoutes: RouteType[] &#x3D; [\n    &#123;\n        pathname: &#39;&#x2F;login&#39;,\n        component: lazy(() &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Login&#x2F;Login&#39;)),\n        exact: true\n    &#125;,\n    &#123;\n        pathname: &#39;&#x2F;404&#39;,\n        component: lazy(() &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;404&#x2F;404&#39;)),\n        exact: true,\n    &#125;,\n    &#123;\n        pathname: &#39;&#x2F;&#39;,\n        exact: false,\n        component: lazy(() &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Admin&#x2F;Admin&#39;))\n    &#125;\n]\n\n复制代码</code></pre>\n\n<p>下面是懒加载类型和lazy方法在声明文件中的定义：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">type LazyExoticComponent&lt;T extends ComponentType&lt;any&gt;&gt; &#x3D; ExoticComponent&lt;ComponentPropsWithRef&lt;T&gt;&gt; &amp; &#123;\n  readonly _result: T;\n&#125;;\n\nfunction lazy&lt;T extends ComponentType&lt;any&gt;&gt;(\nfactory: () &#x3D;&gt; Promise&lt;&#123; default: T &#125;&gt;\n): LazyExoticComponent&lt;T&gt;;\n复制代码</code></pre>\n\n<h3 id=\"4-类型断言\"><a href=\"#4-类型断言\" class=\"headerlink\" title=\"4. 类型断言\"></a>4. 类型断言</h3><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。在React项目中，断言还是很有用的，。有时候推断出来的类型并不是真正的类型，很多时候我们可能会比TS更懂我们的代码，所以可以使用断言（使用as关键字）来定义一个值得类型。 ​</p>\n<p>来看下面的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const getLength &#x3D; (target: string | number): number &#x3D;&gt; &#123;\n  if (target.length) &#123; &#x2F;&#x2F; error 类型&quot;string | number&quot;上不存在属性&quot;length&quot;\n    return target.length; &#x2F;&#x2F; error  类型&quot;number&quot;上不存在属性&quot;length&quot;\n  &#125; else &#123;\n    return target.toString().length;\n  &#125;\n&#125;;\n复制代码</code></pre>\n\n<p>当TypeScript不确定一个联合类型的变量到底是哪个类型时，就只能访问此联合类型的所有类型里共有的属性或方法，所以现在加了对参数target和返回值的类型定义之后就会报错。这时就可以使用断言，将target的类型断言成string类型：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const getStrLength &#x3D; (target: string | number): number &#x3D;&gt; &#123;\n  if ((target as string).length) &#123;      \n    return (target as string).length; \n  &#125; else &#123;\n    return target.toString().length;\n  &#125;\n&#125;;\n复制代码</code></pre>\n\n<p>需要注意，类型断言并不是类型转换，断言成一个联合类型中不存在的类型是不允许的。 ​</p>\n<p>再来看一个例子，在调用一个方法时传入参数： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d7b74b5f9ff421082597c5cb3651368~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"> 这里就提示我们这个参数可能是undefined，而通过业务知道这个值是一定存在的，所以就可以将它断言成数字：<code>data?.subjectId as number</code> ​</p>\n<p>除此之外，上面所说的标签类型、组件类型、时间类型都可以使用断言来指定给一些数据，还是要根据实际的业务场景来使用。 ​</p>\n<p>感悟：使用类型断言真的能解决项目中的很多报错~</p>\n<h3 id=\"5-枚举类型\"><a href=\"#5-枚举类型\" class=\"headerlink\" title=\"5. 枚举类型\"></a>5. 枚举类型</h3><p>枚举类型在项目中的作用也是不可忽视的，使用枚举类型可以让代码的扩展性更好，当我想更改某属性值时，无需去全局更改这个属性，只要更改枚举中的值即可。通常情况下，最好新建一个文件专门来定义枚举值，便于引用。</p>\n","text":"一、组件声明在React中，组件的声明方式有两种：函数组件和类组件， 来看看这两种类型的组件声明时是如何定义TS类型的。 1. 类组件类组件的定义形式有两种：React.Component&lt;P, S=&#123;&#125;&gt; 和 React.PureComponen...","link":"","photos":[],"count_time":{"symbolsCount":"48k","symbolsTime":"44 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E7%BB%84%E4%BB%B6%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">一、组件声明</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%B1%BB%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">1. 类组件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">2. 函数组件</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81React%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">二、React内置类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-JSX-Element\"><span class=\"toc-text\">1. JSX.Element</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-React-ReactElement\"><span class=\"toc-text\">2. React.ReactElement</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-React-ReactNode\"><span class=\"toc-text\">3. React.ReactNode</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-CSSProperties\"><span class=\"toc-text\">4. CSSProperties</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81React-Hooks\"><span class=\"toc-text\">三、React Hooks</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-useState\"><span class=\"toc-text\">1. useState</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-useEffect\"><span class=\"toc-text\">2. useEffect</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-useRef\"><span class=\"toc-text\">3. useRef</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-useCallback\"><span class=\"toc-text\">4. useCallback</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-useMemo\"><span class=\"toc-text\">5. useMemo</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-useContext\"><span class=\"toc-text\">6. useContext</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-useReducer\"><span class=\"toc-text\">7. useReducer</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86\"><span class=\"toc-text\">四、事件处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Event-%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">1. Event 事件类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2. 事件处理函数类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81HTML%E6%A0%87%E7%AD%BE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">五、HTML标签类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%B8%B8%E8%A7%81%E6%A0%87%E7%AD%BE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">1. 常见标签类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2. 标签属性类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E5%B7%A5%E5%85%B7%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">六、工具泛型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Partial\"><span class=\"toc-text\">1. Partial</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Required\"><span class=\"toc-text\">2. Required</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Readonly\"><span class=\"toc-text\">3. Readonly</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Pick-lt-T-K-extends-keyof-T-gt\"><span class=\"toc-text\">4. Pick&lt;T, K extends keyof T&gt;</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Record-lt-K-extends-keyof-any-T-gt\"><span class=\"toc-text\">5. Record&lt;K extends keyof any, T&gt;</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-Exclude-lt-T-U-gt\"><span class=\"toc-text\">6. Exclude&lt;T, U&gt;</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-Omit-lt-T-K-extends-keyof-any-gt\"><span class=\"toc-text\">7. Omit&lt;T, K extends keyof any&gt;</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-ReturnType\"><span class=\"toc-text\">8. ReturnType</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81Axios-%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">七、Axios 封装</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AB-%E5%85%B6%E4%BB%96\"><span class=\"toc-text\">八. 其他</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-import-React\"><span class=\"toc-text\">1. import React</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Types-or-Interfaces%EF%BC%9F\"><span class=\"toc-text\">2. Types or Interfaces？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%87%92%E5%8A%A0%E8%BD%BD%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">3. 懒加载类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">4. 类型断言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">5. 枚举类型</span></a></li></ol></li></ol>","author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ahooks 整体架构源码解析","uid":"af425ac0390f0c4b127b06f565469692","slug":"ahooks 整体架构源码解析","date":"2022-01-13T14:06:14.000Z","updated":"2023-04-21T09:30:56.535Z","comments":true,"path":"api/articles/ahooks 整体架构源码解析.json","keywords":null,"cover":[],"text":"React hooks utils 库自从 React 16.8 版本推出 React hooks，越来越多的项目使用 Function Component。React hooks utils 库随即诞生，它主要解决的两个问题如下： 公共逻辑的抽象。 解决 React hooks...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"代码被revert,你pull了master,代码没了,咋找回来?","uid":"882b2e906d6e98c8bb89a8ff1e500dbe","slug":"代码被revert","date":"2021-11-21T13:36:54.000Z","updated":"2023-04-21T09:09:42.092Z","comments":true,"path":"api/articles/代码被revert.json","keywords":null,"cover":[],"text":"问题场景实际工作中，在上线时，你的新功能代码都是在gitlab上提交merge to master的请求，拥有merge权限的领导通过后，你的代码才合到master。好，QA开始上线了你的代码，这时 啪，啪，报警了，代码有问题。领导revert了你的代码以保证master分支的正...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}