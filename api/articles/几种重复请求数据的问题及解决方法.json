{"title":"几种重复请求数据的问题及解决方法","uid":"18ec0d2dffa6580aa03409c2b752705b","slug":"几种重复请求数据的问题及解决方法","date":"2022-11-20T08:41:18.000Z","updated":"2023-04-21T10:50:44.637Z","comments":true,"path":"api/articles/几种重复请求数据的问题及解决方法.json","keywords":null,"cover":[],"content":"<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be865f61c70743bf9bc374b426a1c1e1~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"几种重复请求数据的问题及解决方法\"></p>\n<p>最近封控在家，回顾问题解解闷。今天来讲讲重复请求的问题。</p>\n<h2 id=\"问题汇总\"><a href=\"#问题汇总\" class=\"headerlink\" title=\"问题汇总\"></a>问题汇总</h2><ol>\n<li>表单提交按钮重复点击</li>\n<li>查询按钮重复点击</li>\n<li>可能多个因素同时触发某个请求</li>\n<li>页面自动刷新数据（如：数据大屏）</li>\n<li>同一页面内有多个tab用同一个table，tab1下的数据量大，tab2下的数据量极小，tab1数据未获取到的时候切换到tab2，可能渲染的是tab1的数据</li>\n</ol>\n<h2 id=\"解决的是什么问题\"><a href=\"#解决的是什么问题\" class=\"headerlink\" title=\"解决的是什么问题\"></a>解决的是什么问题</h2><p>解决重复请求的问题本质上是解决这三类问题：</p>\n<ol>\n<li>用户体验</li>\n<li>页面性能</li>\n<li>数据正确且安全，关于这个问题，前端是无法完全杜绝的，必须后端进行兜底，这里不是今天的重点。</li>\n</ol>\n<h2 id=\"分类分析\"><a href=\"#分类分析\" class=\"headerlink\" title=\"分类分析\"></a>分类分析</h2><h3 id=\"提交按钮重复点击\"><a href=\"#提交按钮重复点击\" class=\"headerlink\" title=\"提交按钮重复点击\"></a>提交按钮重复点击</h3><p>这是最常见的问题，重复提交会造成多条数据入库。点击提交给个loading提示过渡，期间按钮不可再次触发就可以。</p>\n<h3 id=\"查询按钮重复点击\"><a href=\"#查询按钮重复点击\" class=\"headerlink\" title=\"查询按钮重复点击\"></a>查询按钮重复点击</h3><p>如果查询按钮点一下就设置loading，体验其实并不好，但是一直请求，数据不断重新渲染，又会影响性能。 我第一反应是用防抖，如果误触只请求最后一次就好了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 防抖\n&#x2F;&#x2F; fn: 回调函数\n&#x2F;&#x2F; delay: 延时时间\nexport const debounce &#x3D; (fn, delay &#x3D; 1000) &#x3D;&gt; &#123;\n  let timer &#x3D; null;\n  return function() &#123;\n    if (timer !&#x3D;&#x3D; null) &#123;\n      clearTimeout(timer);\n    &#125;\n    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n      fn.apply(this, arguments);\n    &#125;, 1000);\n  &#125;;\n&#125;;\n复制代码</code></pre>\n\n<p>直到我疯狂点击搜索引擎的搜索按钮，我发现人家用的不是防抖，我陷入沉思，如果我的用户像我一样，那防抖就会让他无法快速看到数据，所以我又觉得应该用节流。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 节流\nexport const throttle &#x3D; (fn, delay &#x3D; 1000) &#x3D;&gt; &#123;\n  let old &#x3D; 0;\n  return function() &#123;\n    let now &#x3D; new Date().valueOf();\n    if (now - old &gt; delay) &#123;\n      fn.apply(this, arguments);\n      old &#x3D; now;\n    &#125;\n  &#125;;\n&#125;;\n\n复制代码</code></pre>\n\n<h3 id=\"axios取消重复请求\"><a href=\"#axios取消重复请求\" class=\"headerlink\" title=\"axios取消重复请求\"></a>axios取消重复请求</h3><p>当多个因素瞬时一起触发某个请求，你会希望只处理最后一次请求，那么可以从axios入手，cancel掉多余的请求</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; axios.js\n\n……\n\nconst CANCEL_RETRANSMIT &#x3D; []; &#x2F;&#x2F; 这里存储需要处理重复请求的url\nlet s &#x3D; 1; &#x2F;&#x2F; 单位秒\nlet pending &#x3D; []; &#x2F;&#x2F; 声明一个数组用于存储每个请求的取消函数和axios标识\nlet cancelToken &#x3D; Axios.CancelToken;\nlet removePending &#x3D; config &#x3D;&gt; &#123;\n  pending &#x3D; pending.filter(i &#x3D;&gt; new Date().getTime() - i.t &lt; s * 1000); &#x2F;&#x2F; 保留s秒内发的请求\n  if (\n    pending.length &gt; 1 &amp;&amp;\n    pending[pending.length - 2].u &#x3D;&#x3D;&#x3D; config.url &amp;&amp;\n    pending[pending.length - 1].t - pending[pending.length - 2].t &lt; s * 1000\n  ) &#123;\n    pending[pending.length - 2].f(); &#x2F;&#x2F;执行取消操作\n    pending.splice(pending.length - 2, 1);\n  &#125;\n&#125;;\n\n……\n\n&#x2F;&#x2F; 请求拦截器内\naxios.interceptors.request.use(\n  async config &#x3D;&gt; &#123;\n    ……\n    const url &#x3D; config.url || &#39;&#39;;\n    &#x2F;&#x2F; 删除重复请求\n    if (CANCEL_RETRANSMIT.includes(config.url)) &#123;\n      config.cancelToken &#x3D; new cancelToken(c &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 用请求地址&amp;请求参数拼接的字符串\n        pending.push(&#123;\n          u: url,\n          t: new Date().getTime(),\n          f: c,\n        &#125;);\n      &#125;);\n      await removePending(config);\n    &#125;\n\n    return config;\n  &#125;,\n  ……\n);\n\n复制代码</code></pre>\n\n<p>这种方式只是让前端减少处理重复请求，但是后端依然会收到多个请求。</p>\n<h3 id=\"页面自动刷新数据\"><a href=\"#页面自动刷新数据\" class=\"headerlink\" title=\"页面自动刷新数据\"></a>页面自动刷新数据</h3><p>有些页面需要定时自动重复请求数据更新页面，比如：数据大屏、带状态信息的数据表格。 大多数前端仔看到定时任务第一反应就是setInterval。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">setInterval(function()&#123;\n    &#x2F;&#x2F;要执行的代码                    \n&#125;,200);\n\n复制代码</code></pre>\n\n<p>我们先复习一下setInterval的特点：</p>\n<ol>\n<li>会阻塞</li>\n<li>无论页面显示隐藏，都会执行</li>\n<li>退出需要清除定时器</li>\n<li>间隔时间可以任意定义</li>\n<li>浏览器兼容性极好</li>\n</ol>\n<p>那么有没有一种东西能解决setInterval的缺点？这个就是requestAnimationFrame，简称rAF。 rAF的特点：</p>\n<ol>\n<li>按浏览器帧执行，低阻塞。如果是动画则流畅度会更高。</li>\n<li>仅当页面显示时会执行，页面在后台不执行，这样可以减小CPU占用</li>\n<li>退出需要清除定时器</li>\n<li>间隔时间是每一帧的间隔时间，可以封装方法任意定义</li>\n<li>浏览器兼容比setInterval差点<br>用rAF封装出来的定时器如下</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">export const rafInterval &#x3D; (fn, delay &#x3D; 3000) &#x3D;&gt; &#123;\n  let start &#x3D; 0;\n  function fun() &#123;\n    const timestamp &#x3D; new Date().valueOf();\n    if (start &#x3D;&#x3D;&#x3D; undefined) start &#x3D; timestamp;\n    if (timestamp - start &gt; delay) &#123;\n      start &#x3D; timestamp;\n      fn.apply(this, arguments);\n    &#125;\n    requestAnimationFrame(fun);\n  &#125;\n  return function() &#123;\n    requestAnimationFrame(fun);\n  &#125;;\n&#125;;\n\n复制代码</code></pre>\n\n<p>前面提过requestAnimationFrame兼容性不够好，那么就加个判断</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var requestAnimFrame &#x3D; (function() &#123;\n  return (\n    window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    function(callback) &#123;\n      window.setTimeout(callback, 1000 &#x2F; 60);\n    &#125;\n  );\n&#125;)();\n\nexport const rafInterval &#x3D; (fn, delay &#x3D; 3000) &#x3D;&gt; &#123;\n    ……\n&#125;;\n复制代码</code></pre>\n\n<h3 id=\"同页面根据条件展示不同表格数据\"><a href=\"#同页面根据条件展示不同表格数据\" class=\"headerlink\" title=\"同页面根据条件展示不同表格数据\"></a>同页面根据条件展示不同表格数据</h3><p>实际场景：同一页面内有多个tab用同一个table组件，tab1下的数据量大，tab2下的数据量极小，tab1数据未获取到的时候切换到tab2，可能tab1的数据比tab2还晚返回，table渲染的就会是tab1的数据</p>\n<p>解决思路：</p>\n<ul>\n<li>如果是同一个url发出的请求，用axios的cancel方法，把存在的pending状态的请求cancel</li>\n<li>如果是不同url发出的请求，传个标记给后端，后端返回数据带给前端</li>\n</ul>\n","text":" 最近封控在家，回顾问题解解闷。今天来讲讲重复请求的问题。 问题汇总 表单提交按钮重复点击 查询按钮重复点击 可能多个因素同时触发某个请求 页面自动刷新数据（如：数据大屏） 同一页面内有多个tab用同一个table，tab1下的数据量大，tab2下的数据量极小，tab1数据未获取...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB\"><span class=\"toc-text\">问题汇总</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">解决的是什么问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E7%B1%BB%E5%88%86%E6%9E%90\"><span class=\"toc-text\">分类分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%90%E4%BA%A4%E6%8C%89%E9%92%AE%E9%87%8D%E5%A4%8D%E7%82%B9%E5%87%BB\"><span class=\"toc-text\">提交按钮重复点击</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E8%AF%A2%E6%8C%89%E9%92%AE%E9%87%8D%E5%A4%8D%E7%82%B9%E5%87%BB\"><span class=\"toc-text\">查询按钮重复点击</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#axios%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">axios取消重复请求</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E9%9D%A2%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">页面自动刷新数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8C%E9%A1%B5%E9%9D%A2%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E5%B1%95%E7%A4%BA%E4%B8%8D%E5%90%8C%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">同页面根据条件展示不同表格数据</span></a></li></ol></li></ol>","author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"vue2 与 vue3 的区别","uid":"c15a6a9dda465b3a99cae28e33ecb722","slug":"vue2 与 vue3 的区别","date":"2023-01-09T07:24:48.000Z","updated":"2023-04-21T10:53:16.629Z","comments":true,"path":"api/articles/vue2 与 vue3 的区别.json","keywords":null,"cover":null,"text":"vue2 与 vue3 的区别Vue 内部根据功能可以被分为三个大的模块：**响应性 reactivite、运行时 runtime、编辑器 compiler**，以及一些小的功能点。那么要说 vue2 与 vue3 的区别，我们需要从这三个方面加小的功能点进行说起。 首先先来说 ...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"webpack5三种mode默认配置对比","uid":"de3904e4fffd4a0033c6fe3d6902ae56","slug":"webpack5三种mode默认配置对比","date":"2022-10-21T14:49:27.000Z","updated":"2023-04-21T10:57:58.865Z","comments":true,"path":"api/articles/webpack5三种mode默认配置对比.json","keywords":null,"cover":null,"text":"虽然webpack的文档中已经给出了三种模式默认的配置项的配置，但是我还是好奇除了这些列出的配置，是否还有其他的配置之间的差异呢？ 导出三种模式的配置对象webpack的版本是V5.36.1，获取默认配置的源码路径为webpack/lib/WebpackOptionsDefaul...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"36 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}