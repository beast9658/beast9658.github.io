{"title":"分片加载超长列表渲染","uid":"22a53fdfd136fdbe0a4b16b8cca4b9ec","slug":"分片加载超长列表渲染","date":"2021-11-03T13:50:32.000Z","updated":"2023-04-21T09:05:05.486Z","comments":true,"path":"api/articles/分片加载超长列表渲染.json","keywords":null,"cover":null,"content":"<p>很早以前就有面试问超长列表如何优化，那时候觉得一般前端不会有这种功能，有也是分页，也就没有去关注。今天分享一个超长列表渲染的优化方法，分片加载，现在几乎也都不会用了，但是还是要知道这个东西。</p>\n<p>先明确eventloop的机制，js是单线程的，当你第一个主线程执行过程中，遇到宏任务就放到宏任务队列，遇到微任务就放到微任务队列，这一次主线程执行完了之后，会把微任务队列清空，接着GUI渲染页面，然后再去宏任务队列里面把到时的宏任务提取出来从主线程执行，一直循环。</p>\n<p>先明确，页面渲染是在清空微任务之后：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;ul id&#x3D;&quot;wrap&quot;&gt;&lt;&#x2F;ul&gt;\n\n&lt;script&gt;\n\n    let time;\n\nPromise.resolve().then(res &#x3D;&gt; &#123;\n\n    for (let i &#x3D; 0; i &lt; 10000000000; i++) &#123;&#125;\n\n    console.log(&#39;微任务执行完毕&#39;, new Date() - time);&#x2F;&#x2F;微任务执行完毕 11124\n\n&#125;)\n\ndocument.getElementById(&#39;wrap&#39;).innerHTML &#x3D; &#39;页面渲染了&#39;;\n\ntime &#x3D; new Date();\n\nconsole.log(&#39;页面渲染语句执行&#39;);\n\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<p>接着看看渲染十万条数据页面使用的时间和js执行的时间：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;ul id&#x3D;&quot;wrap&quot;&gt;&lt;&#x2F;ul&gt;\n\n&lt;script&gt;\n\n    let total &#x3D; 100000;\n\n    let time &#x3D; new Date();\n\n    for (let i &#x3D; 0; i &lt; total; i++) &#123;\n\n        let li &#x3D; document.createElement(&#39;li&#39;);\n\n        li.innerHTML &#x3D; i;\n\n        document.getElementById(&#39;wrap&#39;).appendChild(li);\n\n    &#125;\n\n    console.log(&#39;js执行时间&#39;, new Date() - time);&#x2F;&#x2F;js执行时间 710\n\n    setTimeout(function () &#123;\n\n        console.log(&#39;页面渲染时间&#39;, new Date() - time);&#x2F;&#x2F;页面渲染时间 4771\n\n    &#125;)\n\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<p>Js执行很快，但是页面渲染要将近5秒，如果是一百万条数据测试了一下将近一分钟。所以我们要分片渲染。</p>\n<p>分片渲染：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;ul id&#x3D;&quot;wrap&quot;&gt;&lt;&#x2F;ul&gt;\n\n&lt;script&gt;\n\n    let total &#x3D; 100000;\n\n    let time &#x3D; new Date();\n\n    let index &#x3D; 0;\n\n    let id &#x3D; 0;\n\n    function loadList() &#123;\n\n        index +&#x3D; 50;\n\n        if(index &lt; total)&#123;\n\n           setTimeout(function () &#123;\n\n               for (let i &#x3D; 0; i &lt; 50; i++) &#123;\n\n                   let li &#x3D; document.createElement(&#39;li&#39;);\n\n                   li.innerHTML &#x3D; id++;\n\n                   document.getElementById(&#39;wrap&#39;).appendChild(li);\n\n               &#125;\n\n               loadList();\n\n           &#125;)\n\n        &#125;\n\n    &#125;\n\n    loadList()\n\n&lt;&#x2F;script&gt;\n复制代码</code></pre>\n\n<p>分片渲染用的时间会比没分片长，好处就是不需要等所有渲染出来，可以直接看到数据，你拖动滚动条，还能看见页面还在加载。</p>\n<p>这边要注意一点，新版本浏览器对页面渲染做了优化，会等js执行完毕一次性更新页面，不会在for循环的时候执行一条插入一条，如果为了兼容ie，要用文档碎片进行渲染。也可以用requestAnimationFrame这个宏任务替代定时器，性能会稍微好一些。</p>\n<p>虽然分片渲染可以优化，但是这种方法，页面的dom还是过多了，所以这种方法现在也几乎不会用了，一般会使用虚拟列表方法去优化。</p>\n","text":"很早以前就有面试问超长列表如何优化，那时候觉得一般前端不会有这种功能，有也是分页，也就没有去关注。今天分享一个超长列表渲染的优化方法，分片加载，现在几乎也都不会用了，但是还是要知道这个东西。 先明确eventloop的机制，js是单线程的，当你第一个主线程执行过程中，遇到宏任务就...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"代码被revert,你pull了master,代码没了,咋找回来?","uid":"882b2e906d6e98c8bb89a8ff1e500dbe","slug":"代码被revert","date":"2021-11-21T13:36:54.000Z","updated":"2023-04-21T09:09:42.092Z","comments":true,"path":"api/articles/代码被revert.json","keywords":null,"cover":[],"text":"问题场景实际工作中，在上线时，你的新功能代码都是在gitlab上提交merge to master的请求，拥有merge权限的领导通过后，你的代码才合到master。好，QA开始上线了你的代码，这时 啪，啪，报警了，代码有问题。领导revert了你的代码以保证master分支的正...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Antv X6 绘制拖拽流程图","uid":"41fa294c894ff0de66f9b80c0c4a5c37","slug":"Antv X6 绘制拖拽流程图","date":"2021-10-20T09:21:06.000Z","updated":"2023-04-21T09:03:09.746Z","comments":true,"path":"api/articles/Antv X6 绘制拖拽流程图.json","keywords":null,"cover":[],"text":"使用antv x6 绘制拖拽流程图安装# npm $ npm install @antv&#x2F;x6 --save # yarn $ yarn add @antv&#x2F;x6 复制代码 使用创建容器 &lt;!-- 画布 --&gt; &lt;div class&#x3D...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}