{"title":"面试题笔记——代码输出结果篇","uid":"52a992a246e40d85d4ae950cdaebc053","slug":"面试题笔记——代码输出结果篇","date":"2022-06-25T10:41:12.000Z","updated":"2023-04-21T09:44:01.905Z","comments":true,"path":"api/articles/面试题笔记——代码输出结果篇.json","keywords":null,"cover":[],"content":"<h2 id=\"一、异步-amp-事件循环\"><a href=\"#一、异步-amp-事件循环\" class=\"headerlink\" title=\"一、异步&amp;事件循环\"></a>一、异步&amp;事件循环</h2><h3 id=\"1-代码输出结果\"><a href=\"#1-代码输出结果\" class=\"headerlink\" title=\"1. 代码输出结果\"></a>1. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  console.log(1);\n  console.log(2);\n&#125;);\npromise.then(() &#x3D;&gt; &#123;\n  console.log(3);\n&#125;);\nconsole.log(4);\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1 \n2 \n4\n复制代码</code></pre>\n\n<p>promise.then 是微任务，它会在所有的宏任务执行完之后才会执行，同时需要promise内部的状态发生变化，因为这里内部没有发生变化，一直处于pending状态，所以不输出3。</p>\n<h3 id=\"2-代码输出结果\"><a href=\"#2-代码输出结果\" class=\"headerlink\" title=\"2. 代码输出结果\"></a>2. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">const promise1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  console.log(&#39;promise1&#39;)\n  resolve(&#39;resolve1&#39;)\n&#125;)\nconst promise2 &#x3D; promise1.then(res &#x3D;&gt; &#123;\n  console.log(res)\n&#125;)\nconsole.log(&#39;1&#39;, promise1);\nconsole.log(&#39;2&#39;, promise2);\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">promise1\n1 Promise&#123;&lt;resolved&gt;: resolve1&#125;\n2 Promise&#123;&lt;pending&gt;&#125;\nresolve1\n复制代码</code></pre>\n\n<p>需要注意的是，直接打印promise1，会打印出它的状态值和参数。</p>\n<p>代码执行过程如下：</p>\n<ol>\n<li>script是一个宏任务，按照顺序执行这些代码；</li>\n<li>首先进入Promise，执行该构造函数中的代码，打印<code>promise1</code>；</li>\n<li>碰到<code>resolve</code>函数, 将<code>promise1</code>的状态改变为<code>resolved</code>, 并将结果保存下来；</li>\n<li>碰到<code>promise1.then</code>这个微任务，将它放入微任务队列；</li>\n<li><code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code>；</li>\n<li>执行同步代码1， 同时打印出<code>promise1</code>的状态是<code>resolved</code>；</li>\n<li>执行同步代码2，同时打印出<code>promise2</code>的状态是<code>pending</code>；</li>\n<li>宏任务执行完毕，查找微任务队列，发现<code>promise1.then</code>这个微任务且状态为<code>resolved</code>，执行它。</li>\n</ol>\n<h3 id=\"3-代码输出结果\"><a href=\"#3-代码输出结果\" class=\"headerlink\" title=\"3. 代码输出结果\"></a>3. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  console.log(1);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&quot;timerStart&quot;);\n    resolve(&quot;success&quot;);\n    console.log(&quot;timerEnd&quot;);\n  &#125;, 0);\n  console.log(2);\n&#125;);\npromise.then((res) &#x3D;&gt; &#123;\n  console.log(res);\n&#125;);\nconsole.log(4);\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1\n2\n4\ntimerStart\ntimerEnd\nsuccess\n复制代码</code></pre>\n\n<p>代码执行过程如下：</p>\n<ul>\n<li>首先遇到Promise构造函数，会先执行里面的内容，打印<code>1</code>；</li>\n<li>遇到定时器<code>steTimeout</code>，它是一个宏任务，放入宏任务队列；</li>\n<li>继续向下执行，打印出2；</li>\n<li>由于<code>Promise</code>的状态此时还是<code>pending</code>，所以<code>promise.then</code>先不执行；</li>\n<li>继续执行下面的同步任务，打印出4；</li>\n<li>此时微任务队列没有任务，继续执行下一轮宏任务，执行<code>steTimeout</code>；</li>\n<li>首先执行<code>timerStart</code>，然后遇到了<code>resolve</code>，将<code>promise</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise.then</code>推入微任务队列，再执行<code>timerEnd</code>；</li>\n<li>执行完这个宏任务，就去执行微任务<code>promise.then</code>，打印出<code>resolve</code>的结果。</li>\n</ul>\n<h3 id=\"4-代码输出结果\"><a href=\"#4-代码输出结果\" class=\"headerlink\" title=\"4. 代码输出结果\"></a>4. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">Promise.resolve().then(() &#x3D;&gt; &#123;\n  console.log(&#39;promise1&#39;);\n  const timer2 &#x3D; setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;timer2&#39;)\n  &#125;, 0)\n&#125;);\nconst timer1 &#x3D; setTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;timer1&#39;)\n  Promise.resolve().then(() &#x3D;&gt; &#123;\n    console.log(&#39;promise2&#39;)\n  &#125;)\n&#125;, 0)\nconsole.log(&#39;start&#39;);\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">start\npromise1\ntimer1\npromise2\ntimer2\n复制代码</code></pre>\n\n<p>代码执行过程如下：</p>\n<ol>\n<li>首先，<code>Promise.resolve().then</code>是一个微任务，加入微任务队列</li>\n<li>执行timer1，它是一个宏任务，加入宏任务队列</li>\n<li>继续执行下面的同步代码，打印出<code>start</code></li>\n<li>这样第一轮宏任务就执行完了，开始执行微任务<code>Promise.resolve().then</code>，打印出<code>promise1</code></li>\n<li>遇到<code>timer2</code>，它是一个宏任务，将其加入宏任务队列，此时宏任务队列有两个任务，分别是<code>timer1</code>、<code>timer2</code>；</li>\n<li>这样第一轮微任务就执行完了，开始执行第二轮宏任务，首先执行定时器<code>timer1</code>，打印<code>timer1</code>；</li>\n<li>遇到<code>Promise.resolve().then</code>，它是一个微任务，加入微任务队列</li>\n<li>开始执行微任务队列中的任务，打印<code>promise2</code>；</li>\n<li>最后执行宏任务<code>timer2</code>定时器，打印出<code>timer2</code>；</li>\n</ol>\n<h3 id=\"5-代码输出结果\"><a href=\"#5-代码输出结果\" class=\"headerlink\" title=\"5. 代码输出结果\"></a>5. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n    resolve(&#39;success1&#39;);\n    reject(&#39;error&#39;);\n    resolve(&#39;success2&#39;);\n&#125;);\npromise.then((res) &#x3D;&gt; &#123;\n    console.log(&#39;then:&#39;, res);\n&#125;).catch((err) &#x3D;&gt; &#123;\n    console.log(&#39;catch:&#39;, err);\n&#125;)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">then：success1\n复制代码</code></pre>\n\n<p>这个题目考察的就是<strong>Promise的状态在发生变化之后，就不会再发生变化</strong>。开始状态由<code>pending</code>变为<code>resolve</code>，说明已经变为已完成状态，下面的两个状态的就不会再执行，同时下面的catch也不会捕获到错误。</p>\n<h3 id=\"6-代码输出结果\"><a href=\"#6-代码输出结果\" class=\"headerlink\" title=\"6. 代码输出结果\"></a>6. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">Promise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1\nPromise &#123;&lt;fulfilled&gt;: undefined&#125;\n复制代码</code></pre>\n\n<p>Promise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。</p>\n<p>then方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。</p>\n<h3 id=\"7-代码输出结果\"><a href=\"#7-代码输出结果\" class=\"headerlink\" title=\"7. 代码输出结果\"></a>7. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">const promise1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    resolve(&#39;success&#39;)\n  &#125;, 1000)\n&#125;)\nconst promise2 &#x3D; promise1.then(() &#x3D;&gt; &#123;\n  throw new Error(&#39;error!!!&#39;)\n&#125;)\nconsole.log(&#39;promise1&#39;, promise1)\nconsole.log(&#39;promise2&#39;, promise2)\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;promise1&#39;, promise1)\n  console.log(&#39;promise2&#39;, promise2)\n&#125;, 2000)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">promise1 Promise &#123;&lt;pending&gt;&#125;\npromise2 Promise &#123;&lt;pending&gt;&#125;\n\nUncaught (in promise) Error: error!!!\npromise1 Promise &#123;&lt;fulfilled&gt;: &quot;success&quot;&#125;\npromise2 Promise &#123;&lt;rejected&gt;: Error: error!!&#125;\n复制代码</code></pre>\n\n<h3 id=\"8-代码输出结果\"><a href=\"#8-代码输出结果\" class=\"headerlink\" title=\"8. 代码输出结果\"></a>8. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">Promise.resolve(1)\n  .then(res &#x3D;&gt; &#123;\n    console.log(res);\n    return 2;\n  &#125;)\n  .catch(err &#x3D;&gt; &#123;\n    return 3;\n  &#125;)\n  .then(res &#x3D;&gt; &#123;\n    console.log(res);\n  &#125;);\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1   \n2\n复制代码</code></pre>\n\n<p>Promise是可以链式调用的，由于每次调用 <code>.then</code> 或者 <code>.catch</code> 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般任务的链式调用一样return this。</p>\n<p>上面的输出结果之所以依次打印出1和2，是因为<code>resolve(1)</code>之后走的是第一个then方法，并没有进catch里，所以第二个then中的res得到的实际上是第一个then的返回值。并且return 2会被包装成<code>resolve(2)</code>，被最后的then打印输出2。</p>\n<h3 id=\"9-代码输出结果\"><a href=\"#9-代码输出结果\" class=\"headerlink\" title=\"9. 代码输出结果\"></a>9. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">Promise.resolve().then(() &#x3D;&gt; &#123;\n  return new Error(&#39;error!!!&#39;)\n&#125;).then(res &#x3D;&gt; &#123;\n  console.log(&quot;then: &quot;, res)\n&#125;).catch(err &#x3D;&gt; &#123;\n  console.log(&quot;catch: &quot;, err)\n&#125;)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&quot;then: &quot; &quot;Error: error!!!&quot;\n复制代码</code></pre>\n\n<p>返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的<code>return new Error(&#39;error!!!&#39;)</code>也被包裹成了<code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code>，因此它会被then捕获而不是catch。</p>\n<h3 id=\"10-代码输出结果\"><a href=\"#10-代码输出结果\" class=\"headerlink\" title=\"10. 代码输出结果\"></a>10. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">const promise &#x3D; Promise.resolve().then(() &#x3D;&gt; &#123;\n  return promise;\n&#125;)\npromise.catch(console.err)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;\n复制代码</code></pre>\n\n<p>这里其实是一个坑，<code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。</p>\n<h3 id=\"11-代码输出结果\"><a href=\"#11-代码输出结果\" class=\"headerlink\" title=\"11. 代码输出结果\"></a>11. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">Promise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1\n复制代码</code></pre>\n\n<p>看到这个题目，好多的then，实际上只需要记住一个原则：<code>.then</code> 或<code>.catch</code> 的参数期望是函数，传入非函数则会发生<strong>值透传</strong>。</p>\n<p>第一个then和第二个then中传入的都不是函数，一个是数字，一个是对象，因此发生了透传，将<code>resolve(1)</code> 的值直接传到最后一个then里，直接打印出1。</p>\n<h3 id=\"12-代码输出结果\"><a href=\"#12-代码输出结果\" class=\"headerlink\" title=\"12. 代码输出结果\"></a>12. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">Promise.reject(&#39;err!!!&#39;)\n  .then((res) &#x3D;&gt; &#123;\n    console.log(&#39;success&#39;, res)\n  &#125;, (err) &#x3D;&gt; &#123;\n    console.log(&#39;error&#39;, err)\n  &#125;).catch(err &#x3D;&gt; &#123;\n    console.log(&#39;catch&#39;, err)\n  &#125;)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">error err!!!\n复制代码</code></pre>\n\n<p>我们知道，<code>.then</code>函数中的两个参数：</p>\n<ul>\n<li>第一个参数是用来处理Promise成功的函数</li>\n<li>第二个则是处理失败的函数</li>\n</ul>\n<p>也就是说<code>Promise.resolve(&#39;1&#39;)</code>的值会进入成功的函数，<code>Promise.reject(&#39;2&#39;)</code>的值会进入失败的函数。</p>\n<p>在这道题中，错误直接被<code>then</code>的第二个参数捕获了，所以就不会被<code>catch</code>捕获了，输出结果为：<code>error err!!!&#39;</code></p>\n<p>但是，如果是像下面这样：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Promise.resolve()\n  .then(function success (res) &#123;\n    throw new Error(&#39;error!!!&#39;)\n  &#125;, function fail1 (err) &#123;\n    console.log(&#39;fail1&#39;, err)\n  &#125;).catch(function fail2 (err) &#123;\n    console.log(&#39;fail2&#39;, err)\n  &#125;)\n复制代码</code></pre>\n\n<p>在<code>then</code>的第一参数中抛出了错误，那么他就不会被第二个参数不活了，而是被后面的<code>catch</code>捕获到。</p>\n<h3 id=\"13-代码输出结果\"><a href=\"#13-代码输出结果\" class=\"headerlink\" title=\"13. 代码输出结果\"></a>13. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">Promise.resolve(&#39;1&#39;)\n  .then(res &#x3D;&gt; &#123;\n    console.log(res)\n  &#125;)\n  .finally(() &#x3D;&gt; &#123;\n    console.log(&#39;finally&#39;)\n  &#125;)\nPromise.resolve(&#39;2&#39;)\n  .finally(() &#x3D;&gt; &#123;\n    console.log(&#39;finally2&#39;)\n  \treturn &#39;我是finally2返回的值&#39;\n  &#125;)\n  .then(res &#x3D;&gt; &#123;\n    console.log(&#39;finally2后面的then函数&#39;, res)\n  &#125;)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1\nfinally2\nfinally\nfinally2后面的then函数 2\n复制代码</code></pre>\n\n<p><code>.finally()</code>一般用的很少，只要记住以下几点就可以了：</p>\n<ul>\n<li><code>.finally()</code>方法不管Promise对象最后的状态如何都会执行</li>\n<li><code>.finally()</code>方法的回调函数不接受任何的参数，也就是说你在<code>.finally()</code>函数中是无法知道Promise最终的状态是<code>resolved</code>还是<code>rejected</code>的</li>\n<li>它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。</li>\n<li>finally本质上是then方法的特例</li>\n</ul>\n<p><code>.finally()</code>的错误捕获：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Promise.resolve(&#39;1&#39;)\n  .finally(() &#x3D;&gt; &#123;\n    console.log(&#39;finally1&#39;)\n    throw new Error(&#39;我是finally中抛出的异常&#39;)\n  &#125;)\n  .then(res &#x3D;&gt; &#123;\n    console.log(&#39;finally后面的then函数&#39;, res)\n  &#125;)\n  .catch(err &#x3D;&gt; &#123;\n    console.log(&#39;捕获错误&#39;, err)\n  &#125;)\n复制代码</code></pre>\n\n<p>输出结果为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#39;finally1&#39;\n&#39;捕获错误&#39; Error: 我是finally中抛出的异常\n复制代码</code></pre>\n\n<h3 id=\"14-代码输出结果\"><a href=\"#14-代码输出结果\" class=\"headerlink\" title=\"14. 代码输出结果\"></a>14. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function runAsync (x) &#123;\n    const p &#x3D; new Promise(r &#x3D;&gt; setTimeout(() &#x3D;&gt; r(x, console.log(x)), 1000))\n    return p\n&#125;\n\nPromise.all([runAsync(1), runAsync(2), runAsync(3)]).then(res &#x3D;&gt; console.log(res))\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1\n2\n3\n[1, 2, 3]\n复制代码</code></pre>\n\n<p>首先，定义了一个Promise，来异步执行函数runAsync，该函数传入一个值x，然后间隔一秒后打印出这个x。</p>\n<p>之后再使用<code>Promise.all</code>来执行这个函数，执行的时候，看到一秒之后输出了1，2，3，同时输出了数组[1, 2, 3]，三个函数是同步执行的，并且在一个回调函数中返回了所有的结果。并且结果和函数的执行顺序是一致的。</p>\n<h3 id=\"15-代码输出结果\"><a href=\"#15-代码输出结果\" class=\"headerlink\" title=\"15. 代码输出结果\"></a>15. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function runAsync (x) &#123;\n  const p &#x3D; new Promise(r &#x3D;&gt; setTimeout(() &#x3D;&gt; r(x, console.log(x)), 1000))\n  return p\n&#125;\nfunction runReject (x) &#123;\n  const p &#x3D; new Promise((res, rej) &#x3D;&gt; setTimeout(() &#x3D;&gt; rej(&#96;Error: $&#123;x&#125;&#96;, console.log(x)), 1000 * x))\n  return p\n&#125;\nPromise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])\n       .then(res &#x3D;&gt; console.log(res))\n       .catch(err &#x3D;&gt; console.log(err))\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 1s后输出\n1\n3\n&#x2F;&#x2F; 2s后输出\n2\nError: 2\n&#x2F;&#x2F; 4s后输出\n4\n复制代码</code></pre>\n\n<p>可以看到。catch捕获到了第一个错误，在这道题目中最先的错误就是<code>runReject(2)</code>的结果。如果一组异步操作中有一个异常都不会进入<code>.then()</code>的第一个回调函数参数中。会被<code>.then()</code>的第二个回调函数捕获。</p>\n<h3 id=\"16-代码输出结果\"><a href=\"#16-代码输出结果\" class=\"headerlink\" title=\"16. 代码输出结果\"></a>16. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function runAsync (x) &#123;\n  const p &#x3D; new Promise(r &#x3D;&gt; setTimeout(() &#x3D;&gt; r(x, console.log(x)), 1000))\n  return p\n&#125;\nPromise.race([runAsync(1), runAsync(2), runAsync(3)])\n  .then(res &#x3D;&gt; console.log(&#39;result: &#39;, res))\n  .catch(err &#x3D;&gt; console.log(err))\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1\n&#39;result: &#39; 1\n2\n3\n复制代码</code></pre>\n\n<p>then只会捕获第一个成功的方法，其他的函数虽然还会继续执行，但是不是被then捕获了。</p>\n<h3 id=\"17-代码输出结果\"><a href=\"#17-代码输出结果\" class=\"headerlink\" title=\"17. 代码输出结果\"></a>17. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function runAsync(x) &#123;\n  const p &#x3D; new Promise(r &#x3D;&gt;\n    setTimeout(() &#x3D;&gt; r(x, console.log(x)), 1000)\n  );\n  return p;\n&#125;\nfunction runReject(x) &#123;\n  const p &#x3D; new Promise((res, rej) &#x3D;&gt;\n    setTimeout(() &#x3D;&gt; rej(&#96;Error: $&#123;x&#125;&#96;, console.log(x)), 1000 * x)\n  );\n  return p;\n&#125;\nPromise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)])\n  .then(res &#x3D;&gt; console.log(&quot;result: &quot;, res))\n  .catch(err &#x3D;&gt; console.log(err));\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0\nError: 0\n1\n2\n3\n复制代码</code></pre>\n\n<p>可以看到在catch捕获到第一个错误之后，后面的代码还不执行，不过不会再被捕获了。</p>\n<p>注意：<code>all</code>和<code>race</code>传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。</p>\n<h3 id=\"18-代码输出结果\"><a href=\"#18-代码输出结果\" class=\"headerlink\" title=\"18. 代码输出结果\"></a>18. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">async function async1() &#123;\n  console.log(&quot;async1 start&quot;);\n  await async2();\n  console.log(&quot;async1 end&quot;);\n&#125;\nasync function async2() &#123;\n  console.log(&quot;async2&quot;);\n&#125;\nasync1();\nconsole.log(&#39;start&#39;)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">async1 start\nasync2\nstart\nasync1 end\n复制代码</code></pre>\n\n<p>代码的执行过程如下：</p>\n<ol>\n<li>首先执行函数中的同步代码<code>async1 start</code>，之后遇到了<code>await</code>，它会阻塞<code>async1</code>后面代码的执行，因此会先去执行<code>async2</code>中的同步代码<code>async2</code>，然后跳出<code>async1</code>；</li>\n<li>跳出<code>async1</code>函数后，执行同步代码<code>start</code>；</li>\n<li>在一轮宏任务全部执行完之后，再来执行<code>await</code>后面的内容<code>async1 end</code>。</li>\n</ol>\n<p>这里可以理解为await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中。</p>\n<h3 id=\"19-代码输出结果\"><a href=\"#19-代码输出结果\" class=\"headerlink\" title=\"19. 代码输出结果\"></a>19. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">async function async1() &#123;\n  console.log(&quot;async1 start&quot;);\n  await async2();\n  console.log(&quot;async1 end&quot;);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;timer1&#39;)\n  &#125;, 0)\n&#125;\nasync function async2() &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;timer2&#39;)\n  &#125;, 0)\n  console.log(&quot;async2&quot;);\n&#125;\nasync1();\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;timer3&#39;)\n&#125;, 0)\nconsole.log(&quot;start&quot;)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">async1 start\nasync2\nstart\nasync1 end\ntimer2\ntimer3\ntimer1\n复制代码</code></pre>\n\n<p>代码的执行过程如下：</p>\n<ol>\n<li>首先进入<code>async1</code>，打印出<code>async1 start</code>；</li>\n<li>之后遇到<code>async2</code>，进入<code>async2</code>，遇到定时器<code>timer2</code>，加入宏任务队列，之后打印<code>async2</code>；</li>\n<li>由于<code>async2</code>阻塞了后面代码的执行，所以执行后面的定时器<code>timer3</code>，将其加入宏任务队列，之后打印<code>start</code>；</li>\n<li>然后执行async2后面的代码，打印出<code>async1 end</code>，遇到定时器timer1，将其加入宏任务队列；</li>\n<li>最后，宏任务队列有三个任务，先后顺序为<code>timer2</code>，<code>timer3</code>，<code>timer1</code>，没有微任务，所以直接所有的宏任务按照先进先出的原则执行。</li>\n</ol>\n<h3 id=\"20-代码输出结果\"><a href=\"#20-代码输出结果\" class=\"headerlink\" title=\"20. 代码输出结果\"></a>20. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">async function async1 () &#123;\n  console.log(&#39;async1 start&#39;);\n  await new Promise(resolve &#x3D;&gt; &#123;\n    console.log(&#39;promise1&#39;)\n  &#125;)\n  console.log(&#39;async1 success&#39;);\n  return &#39;async1 end&#39;\n&#125;\nconsole.log(&#39;srcipt start&#39;)\nasync1().then(res &#x3D;&gt; console.log(res))\nconsole.log(&#39;srcipt end&#39;)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">script start\nasync1 start\npromise1\nscript end\n复制代码</code></pre>\n\n<p>这里需要注意的是在<code>async1</code>中<code>await</code>后面的Promise是没有返回值的，也就是它的状态始终是<code>pending</code>状态，所以在<code>await</code>之后的内容是不会执行的，包括<code>async1</code>后面的 <code>.then</code>。</p>\n<h3 id=\"21-代码输出结果\"><a href=\"#21-代码输出结果\" class=\"headerlink\" title=\"21. 代码输出结果\"></a>21. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">async function async1 () &#123;\n  console.log(&#39;async1 start&#39;);\n  await new Promise(resolve &#x3D;&gt; &#123;\n    console.log(&#39;promise1&#39;)\n    resolve(&#39;promise1 resolve&#39;)\n  &#125;).then(res &#x3D;&gt; console.log(res))\n  console.log(&#39;async1 success&#39;);\n  return &#39;async1 end&#39;\n&#125;\nconsole.log(&#39;srcipt start&#39;)\nasync1().then(res &#x3D;&gt; console.log(res))\nconsole.log(&#39;srcipt end&#39;)\n复制代码</code></pre>\n\n<p>这里是对上面一题进行了改造，加上了resolve。</p>\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">script start\nasync1 start\npromise1\nscript end\npromise1 resolve\nasync1 success\nasync1 end\n复制代码</code></pre>\n\n<h3 id=\"22-代码输出结果\"><a href=\"#22-代码输出结果\" class=\"headerlink\" title=\"22. 代码输出结果\"></a>22. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">async function async1() &#123;\n  console.log(&quot;async1 start&quot;);\n  await async2();\n  console.log(&quot;async1 end&quot;);\n&#125;\n\nasync function async2() &#123;\n  console.log(&quot;async2&quot;);\n&#125;\n\nconsole.log(&quot;script start&quot;);\n\nsetTimeout(function() &#123;\n  console.log(&quot;setTimeout&quot;);\n&#125;, 0);\n\nasync1();\n\nnew Promise(resolve &#x3D;&gt; &#123;\n  console.log(&quot;promise1&quot;);\n  resolve();\n&#125;).then(function() &#123;\n  console.log(&quot;promise2&quot;);\n&#125;);\nconsole.log(&#39;script end&#39;)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">script start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n复制代码</code></pre>\n\n<p>代码执行过程如下：</p>\n<ol>\n<li>开头定义了async1和async2两个函数，但是并未执行，执行script中的代码，所以打印出script start；</li>\n<li>遇到定时器Settimeout，它是一个宏任务，将其加入到宏任务队列；</li>\n<li>之后执行函数async1，首先打印出async1 start；</li>\n<li>遇到await，执行async2，打印出async2，并阻断后面代码的执行，将后面的代码加入到微任务队列；</li>\n<li>然后跳出async1和async2，遇到Promise，打印出promise1；</li>\n<li>遇到resolve，将其加入到微任务队列，然后执行后面的script代码，打印出script end；</li>\n<li>之后就该执行微任务队列了，首先打印出async1 end，然后打印出promise2；</li>\n<li>执行完微任务队列，就开始执行宏任务队列中的定时器，打印出setTimeout。</li>\n</ol>\n<h3 id=\"23-代码输出结果\"><a href=\"#23-代码输出结果\" class=\"headerlink\" title=\"23. 代码输出结果\"></a>23. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">async function async1 () &#123;\n  await async2();\n  console.log(&#39;async1&#39;);\n  return &#39;async1 success&#39;\n&#125;\nasync function async2 () &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    console.log(&#39;async2&#39;)\n    reject(&#39;error&#39;)\n  &#125;)\n&#125;\nasync1().then(res &#x3D;&gt; console.log(res))\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">async2\nUncaught (in promise) error\n复制代码</code></pre>\n\n<p>可以看到，如果async函数中抛出了错误，就会终止错误结果，不会继续向下执行。</p>\n<p>如果想要让错误不足之处后面的代码执行，可以使用catch来捕获：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">async function async1 () &#123;\n  await Promise.reject(&#39;error!!!&#39;).catch(e &#x3D;&gt; console.log(e))\n  console.log(&#39;async1&#39;);\n  return Promise.resolve(&#39;async1 success&#39;)\n&#125;\nasync1().then(res &#x3D;&gt; console.log(res))\nconsole.log(&#39;script start&#39;)\n复制代码</code></pre>\n\n<p>这样的输出结果就是：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">script start\nerror!!!\nasync1\nasync1 success\n复制代码</code></pre>\n\n<h3 id=\"24-代码输出结果\"><a href=\"#24-代码输出结果\" class=\"headerlink\" title=\"24. 代码输出结果\"></a>24. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">const first &#x3D; () &#x3D;&gt; (new Promise((resolve, reject) &#x3D;&gt; &#123;\n    console.log(3);\n    let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n        console.log(7);\n        setTimeout(() &#x3D;&gt; &#123;\n            console.log(5);\n            resolve(6);\n            console.log(p)\n        &#125;, 0)\n        resolve(1);\n    &#125;);\n    resolve(2);\n    p.then((arg) &#x3D;&gt; &#123;\n        console.log(arg);\n    &#125;);\n&#125;));\nfirst().then((arg) &#x3D;&gt; &#123;\n    console.log(arg);\n&#125;);\nconsole.log(4);\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">3\n7\n4\n1\n2\n5\nPromise&#123;&lt;resolved&gt;: 1&#125;\n复制代码</code></pre>\n\n<p>代码的执行过程如下：</p>\n<ol>\n<li>首先会进入Promise，打印出3，之后进入下面的Promise，打印出7；</li>\n<li>遇到了定时器，将其加入宏任务队列；</li>\n<li>执行Promise  p中的resolve，状态变为resolved，返回值为1；</li>\n<li>执行Promise first中的resolve，状态变为resolved，返回值为2；</li>\n<li>遇到p.then，将其加入微任务队列，遇到first().then，将其加入任务队列；</li>\n<li>执行外面的代码，打印出4；</li>\n<li>这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2；</li>\n<li>这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以<code>resolve(6)</code>不会再执行；</li>\n<li>最后<code>console.log(p)</code>打印出<code>Promise&#123;&lt;resolved&gt;: 1&#125;</code>；</li>\n</ol>\n<h3 id=\"25-代码输出结果\"><a href=\"#25-代码输出结果\" class=\"headerlink\" title=\"25. 代码输出结果\"></a>25. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">const async1 &#x3D; async () &#x3D;&gt; &#123;\n  console.log(&#39;async1&#39;);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;timer1&#39;)\n  &#125;, 2000)\n  await new Promise(resolve &#x3D;&gt; &#123;\n    console.log(&#39;promise1&#39;)\n  &#125;)\n  console.log(&#39;async1 end&#39;)\n  return &#39;async1 success&#39;\n&#125; \nconsole.log(&#39;script start&#39;);\nasync1().then(res &#x3D;&gt; console.log(res));\nconsole.log(&#39;script end&#39;);\nPromise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .catch(4)\n  .then(res &#x3D;&gt; console.log(res))\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;timer2&#39;)\n&#125;, 1000)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">script start\nasync1\npromise1\nscript end\n1\ntimer2\ntimer1\n复制代码</code></pre>\n\n<p>代码的执行过程如下：</p>\n<ol>\n<li>首先执行同步带吗，打印出script start；</li>\n<li>遇到定时器timer1将其加入宏任务队列；</li>\n<li>之后是执行Promise，打印出promise1，由于Promise没有返回值，所以后面的代码不会执行；</li>\n<li>然后执行同步代码，打印出script end；</li>\n<li>继续执行下面的Promise，.then和.catch期望参数是一个函数，这里传入的是一个数字，因此就会发生值渗透，将resolve(1)的值传到最后一个then，直接打印出1；</li>\n<li>遇到第二个定时器，将其加入到微任务队列，执行微任务队列，按顺序依次执行两个定时器，但是由于定时器时间的原因，会在两秒后先打印出timer2，在四秒后打印出timer1。</li>\n</ol>\n<h3 id=\"26-代码输出结果\"><a href=\"#26-代码输出结果\" class=\"headerlink\" title=\"26. 代码输出结果\"></a>26. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">const p1 &#x3D; new Promise((resolve) &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    resolve(&#39;resolve3&#39;);\n    console.log(&#39;timer1&#39;)\n  &#125;, 0)\n  resolve(&#39;resovle1&#39;);\n  resolve(&#39;resolve2&#39;);\n&#125;).then(res &#x3D;&gt; &#123;\n  console.log(res)  &#x2F;&#x2F; resolve1\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(p1)\n  &#125;, 1000)\n&#125;).finally(res &#x3D;&gt; &#123;\n  console.log(&#39;finally&#39;, res)\n&#125;)\n复制代码</code></pre>\n\n<p>执行结果为如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">resolve1\nfinally  undefined\ntimer1\nPromise&#123;&lt;resolved&gt;: undefined&#125;\n复制代码</code></pre>\n\n<p>需要注意的是最后一个定时器打印出的p1其实是<code>.finally</code>的返回值，我们知道<code>.finally</code>的返回值如果在没有抛出错误的情况下默认会是上一个Promise的返回值，而这道题中<code>.finally</code>上一个Promise是<code>.then()</code>，但是这个<code>.then()</code>并没有返回值，所以p1打印出来的Promise的值会是<code>undefined</code>，如果在定时器的下面加上一个<code>return 1</code>，则值就会变成1。</p>\n<h3 id=\"27-代码输出结果\"><a href=\"#27-代码输出结果\" class=\"headerlink\" title=\"27. 代码输出结果\"></a>27. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">console.log(&#39;1&#39;);\n\nsetTimeout(function() &#123;\n    console.log(&#39;2&#39;);\n    process.nextTick(function() &#123;\n        console.log(&#39;3&#39;);\n    &#125;)\n    new Promise(function(resolve) &#123;\n        console.log(&#39;4&#39;);\n        resolve();\n    &#125;).then(function() &#123;\n        console.log(&#39;5&#39;)\n    &#125;)\n&#125;)\nprocess.nextTick(function() &#123;\n    console.log(&#39;6&#39;);\n&#125;)\nnew Promise(function(resolve) &#123;\n    console.log(&#39;7&#39;);\n    resolve();\n&#125;).then(function() &#123;\n    console.log(&#39;8&#39;)\n&#125;)\n\nsetTimeout(function() &#123;\n    console.log(&#39;9&#39;);\n    process.nextTick(function() &#123;\n        console.log(&#39;10&#39;);\n    &#125;)\n    new Promise(function(resolve) &#123;\n        console.log(&#39;11&#39;);\n        resolve();\n    &#125;).then(function() &#123;\n        console.log(&#39;12&#39;)\n    &#125;)\n&#125;)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1\n7\n6\n8\n2\n4\n3\n5\n9\n11\n10\n12\n复制代码</code></pre>\n\n<p><strong>（1）第一轮事件循环流程分析如下：</strong></p>\n<ul>\n<li>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</li>\n<li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。暂且记为<code>setTimeout1</code>。</li>\n<li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。记为<code>process1</code>。</li>\n<li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。记为<code>then1</code>。</li>\n<li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，记为<code>setTimeout2</code>。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>宏任务Event Queue</th>\n<th>微任务Event Queue</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>setTimeout1</td>\n<td>process1</td>\n</tr>\n<tr>\n<td>setTimeout2</td>\n<td>then1</td>\n</tr>\n</tbody></table>\n<p>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。发现了<code>process1</code>和<code>then1</code>两个微任务：</p>\n<ul>\n<li>执行<code>process1</code>，输出6。</li>\n<li>执行<code>then1</code>，输出8。</li>\n</ul>\n<p>第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。</p>\n<p><strong>（2）第二轮时间循环从</strong><code>**setTimeout1**</code><strong>宏任务开始：</strong></p>\n<ul>\n<li>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。</li>\n<li><code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>宏任务Event Queue</th>\n<th>微任务Event Queue</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>setTimeout2</td>\n<td>process2</td>\n</tr>\n<tr>\n<td></td>\n<td>then2</td>\n</tr>\n</tbody></table>\n<p>第二轮事件循环宏任务结束，发现有<code>process2</code>和<code>then2</code>两个微任务可以执行：</p>\n<ul>\n<li>输出3。</li>\n<li>输出5。</li>\n</ul>\n<p>第二轮事件循环结束，第二轮输出2，4，3，5。</p>\n<p><strong>（3）第三轮事件循环开始，此时只剩setTimeout2了，执行。</strong></p>\n<ul>\n<li>直接输出9。</li>\n<li>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</li>\n<li>直接执行<code>new Promise</code>，输出11。</li>\n<li>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>宏任务Event Queue</th>\n<th>微任务Event Queue</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>process3</td>\n</tr>\n<tr>\n<td></td>\n<td>then3</td>\n</tr>\n</tbody></table>\n<p>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>：</p>\n<ul>\n<li>输出10。</li>\n<li>输出12。</li>\n</ul>\n<p>第三轮事件循环结束，第三轮输出9，11，10，12。</p>\n<p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。</p>\n<h3 id=\"28-代码输出结果\"><a href=\"#28-代码输出结果\" class=\"headerlink\" title=\"28. 代码输出结果\"></a>28. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">console.log(1)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(2)\n&#125;)\n\nnew Promise(resolve &#x3D;&gt;  &#123;\n  console.log(3)\n  resolve(4)\n&#125;).then(d &#x3D;&gt; console.log(d))\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(5)\n  new Promise(resolve &#x3D;&gt;  &#123;\n    resolve(6)\n  &#125;).then(d &#x3D;&gt; console.log(d))\n&#125;)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(7)\n&#125;)\n\nconsole.log(8)\n复制代码</code></pre>\n\n<p>输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1\n3\n8\n4\n2\n5\n6\n7\n复制代码</code></pre>\n\n<p>代码执行过程如下：</p>\n<ol>\n<li>首先执行script代码，打印出1；</li>\n<li>遇到第一个定时器，加入到宏任务队列；</li>\n<li>遇到Promise，执行代码，打印出3，遇到resolve，将其加入到微任务队列；</li>\n<li>遇到第二个定时器，加入到宏任务队列；</li>\n<li>遇到第三个定时器，加入到宏任务队列；</li>\n<li>继续执行script代码，打印出8，第一轮执行结束；</li>\n<li>执行微任务队列，打印出第一个Promise的resolve结果：4；</li>\n<li>开始执行宏任务队列，执行第一个定时器，打印出2；</li>\n<li>此时没有微任务，继续执行宏任务中的第二个定时器，首先打印出5，遇到Promise，首选打印出6，遇到resolve，将其加入到微任务队列；</li>\n<li>执行微任务队列，打印出6；</li>\n<li>执行宏任务队列中的最后一个定时器，打印出7。</li>\n</ol>\n<h3 id=\"29-代码输出结果\"><a href=\"#29-代码输出结果\" class=\"headerlink\" title=\"29. 代码输出结果\"></a>29. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">console.log(1);\n    \nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(2);\n  Promise.resolve().then(() &#x3D;&gt; &#123;\n    console.log(3)\n  &#125;);\n&#125;);\n\nnew Promise((resolve, reject) &#x3D;&gt; &#123;\n  console.log(4)\n  resolve(5)\n&#125;).then((data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(6);\n&#125;)\n\nconsole.log(7);\n复制代码</code></pre>\n\n<p>代码输出结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1\n4\n7\n5\n2\n3\n6\n复制代码</code></pre>\n\n<p>代码执行过程如下：</p>\n<ol>\n<li>首先执行scrip代码，打印出1；</li>\n<li>遇到第一个定时器setTimeout，将其加入到宏任务队列；</li>\n<li>遇到Promise，执行里面的同步代码，打印出4，遇到resolve，将其加入到微任务队列；</li>\n<li>遇到第二个定时器setTimeout，将其加入到红任务队列；</li>\n<li>执行script代码，打印出7，至此第一轮执行完成；</li>\n<li>指定微任务队列中的代码，打印出resolve的结果：5；</li>\n<li>执行宏任务中的第一个定时器setTimeout，首先打印出2，然后遇到 Promise.resolve().then()，将其加入到微任务队列；</li>\n<li>执行完这个宏任务，就开始执行微任务队列，打印出3；</li>\n<li>继续执行宏任务队列中的第二个定时器，打印出6。</li>\n</ol>\n<h3 id=\"30-代码输出结果\"><a href=\"#30-代码输出结果\" class=\"headerlink\" title=\"30. 代码输出结果\"></a>30. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">Promise.resolve().then(() &#x3D;&gt; &#123;\n    console.log(&#39;1&#39;);\n    throw &#39;Error&#39;;\n&#125;).then(() &#x3D;&gt; &#123;\n    console.log(&#39;2&#39;);\n&#125;).catch(() &#x3D;&gt; &#123;\n    console.log(&#39;3&#39;);\n    throw &#39;Error&#39;;\n&#125;).then(() &#x3D;&gt; &#123;\n    console.log(&#39;4&#39;);\n&#125;).catch(() &#x3D;&gt; &#123;\n    console.log(&#39;5&#39;);\n&#125;).then(() &#x3D;&gt; &#123;\n    console.log(&#39;6&#39;);\n&#125;);\n复制代码</code></pre>\n\n<p>执行结果如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1 \n3 \n5 \n6\n复制代码</code></pre>\n\n<p>在这道题目中，我们需要知道，无论是thne还是catch中，只要throw 抛出了错误，就会被catch捕获，如果没有throw出错误，就被继续执行后面的then。</p>\n<h3 id=\"31-代码输出结果\"><a href=\"#31-代码输出结果\" class=\"headerlink\" title=\"31. 代码输出结果\"></a>31. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">setTimeout(function () &#123;\n  console.log(1);\n&#125;, 100);\n\nnew Promise(function (resolve) &#123;\n  console.log(2);\n  resolve();\n  console.log(3);\n&#125;).then(function () &#123;\n  console.log(4);\n  new Promise((resove, reject) &#x3D;&gt; &#123;\n    console.log(5);\n    setTimeout(() &#x3D;&gt;  &#123;\n      console.log(6);\n    &#125;, 10);\n  &#125;)\n&#125;);\nconsole.log(7);\nconsole.log(8);\n复制代码</code></pre>\n\n<p>输出结果为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2\n3\n7\n8\n4\n5\n6\n1\n复制代码</code></pre>\n\n<p>代码执行过程如下：</p>\n<ol>\n<li>首先遇到定时器，将其加入到宏任务队列；</li>\n<li>遇到Promise，首先执行里面的同步代码，打印出2，遇到resolve，将其加入到微任务队列，执行后面同步代码，打印出3；</li>\n<li>继续执行script中的代码，打印出7和8，至此第一轮代码执行完成；</li>\n<li>执行微任务队列中的代码，首先打印出4，如遇到Promise，执行其中的同步代码，打印出5，遇到定时器，将其加入到宏任务队列中，此时宏任务队列中有两个定时器；</li>\n<li>执行宏任务队列中的代码，这里我们需要注意是的第一个定时器的时间为100ms，第二个定时器的时间为10ms，所以先执行第二个定时器，打印出6；</li>\n<li>此时微任务队列为空，继续执行宏任务队列，打印出1。</li>\n</ol>\n<p>做完这道题目，我们就需要格外注意，每个定时器的时间，并不是所有定时器的时间都为0哦。</p>\n<h2 id=\"二、this\"><a href=\"#二、this\" class=\"headerlink\" title=\"二、this\"></a>二、this</h2><h3 id=\"1-代码输出结果-1\"><a href=\"#1-代码输出结果-1\" class=\"headerlink\" title=\"1. 代码输出结果\"></a>1. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function foo() &#123;\n  console.log( this.a );\n&#125;\n\nfunction doFoo() &#123;\n  foo();\n&#125;\n\nvar obj &#x3D; &#123;\n  a: 1,\n  doFoo: doFoo\n&#125;;\n\nvar a &#x3D; 2; \nobj.doFoo()\n复制代码</code></pre>\n\n<p>输出结果：2</p>\n<p>在Javascript中，this指向函数执行时的当前对象。在执行foo的时候，执行环境就是doFoo函数，执行环境为全局。所以，foo中的this是指向window的，所以会打印出2。</p>\n<h3 id=\"2-代码输出结果-1\"><a href=\"#2-代码输出结果-1\" class=\"headerlink\" title=\"2. 代码输出结果\"></a>2. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var a &#x3D; 10\nvar obj &#x3D; &#123;\n  a: 20,\n  say: () &#x3D;&gt; &#123;\n    console.log(this.a)\n  &#125;\n&#125;\nobj.say() \n\nvar anotherObj &#x3D; &#123; a: 30 &#125; \nobj.say.apply(anotherObj) \n复制代码</code></pre>\n\n<p>输出结果：10 10</p>\n<p>我么知道，箭头函数时不绑定this的，它的this来自原其父级所处的上下文，所以首先会打印全局中的 a 的值10。后面虽然让say方法指向了另外一个对象，但是仍不能改变箭头函数的特性，它的this仍然是指向全局的，所以依旧会输出10。</p>\n<p>但是，如果是普通函数，那么就会有完全不一样的结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var a &#x3D; 10  \nvar obj &#x3D; &#123;  \n  a: 20,  \n  say()&#123;\n    console.log(this.a)  \n  &#125;  \n&#125;  \nobj.say()   \nvar anotherObj&#x3D;&#123;a:30&#125;   \nobj.say.apply(anotherObj)\n复制代码</code></pre>\n\n<p>输出结果：20 30</p>\n<p>这时，say方法中的this就会指向他所在的对象，输出其中的a的值。</p>\n<h3 id=\"3-代码输出结果-1\"><a href=\"#3-代码输出结果-1\" class=\"headerlink\" title=\"3. 代码输出结果\"></a>3. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function a() &#123;\n  console.log(this);\n&#125;\na.call(null);\n复制代码</code></pre>\n\n<p>打印结果：window对象</p>\n<p>根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。</p>\n<p>要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#39;use strict&#39;;\n\nfunction a() &#123;\n    console.log(this);\n&#125;\na.call(null); &#x2F;&#x2F; null\na.call(undefined); &#x2F;&#x2F; undefined\n复制代码</code></pre>\n\n<h3 id=\"4-代码输出结果-1\"><a href=\"#4-代码输出结果-1\" class=\"headerlink\" title=\"4. 代码输出结果\"></a>4. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var obj &#x3D; &#123; \n  name : &#39;cuggz&#39;, \n  fun : function()&#123; \n    console.log(this.name); \n  &#125; \n&#125; \nobj.fun()     &#x2F;&#x2F; cuggz\nnew obj.fun() &#x2F;&#x2F; undefined\n复制代码</code></pre>\n\n<p>使用new构造函数时，其this指向的是全局环境window。</p>\n<h3 id=\"6-代码输出结果-1\"><a href=\"#6-代码输出结果-1\" class=\"headerlink\" title=\"6. 代码输出结果\"></a>6. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var obj &#x3D; &#123;\n   say: function() &#123;\n     var f1 &#x3D; () &#x3D;&gt;  &#123;\n       console.log(&quot;1111&quot;, this);\n     &#125;\n     f1();\n   &#125;,\n   pro: &#123;\n     getPro:() &#x3D;&gt;  &#123;\n        console.log(this);\n     &#125;\n   &#125;\n&#125;\nvar o &#x3D; obj.say;\no();\nobj.say();\nobj.pro.getPro();\n复制代码</code></pre>\n\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1111 window对象\n1111 obj对象\nwindow对象\n复制代码</code></pre>\n\n<p><strong>解析：</strong></p>\n<ol>\n<li>o()，o是在全局执行的，而f1是箭头函数，它是没有绑定this的，它的this指向其父级的this，其父级say方法的this指向的是全局作用域，所以会打印出window；</li>\n<li>obj.say()，谁调用say，say 的this就指向谁，所以此时this指向的是obj对象；</li>\n<li>obj.pro.getPro()，我们知道，箭头函数时不绑定this的，getPro处于pro中，而对象不构成单独的作用域，所以箭头的函数的this就指向了全局作用域window。</li>\n</ol>\n<h3 id=\"7-代码输出结果-1\"><a href=\"#7-代码输出结果-1\" class=\"headerlink\" title=\"7. 代码输出结果\"></a>7. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var myObject &#x3D; &#123;\n    foo: &quot;bar&quot;,\n    func: function() &#123;\n        var self &#x3D; this;\n        console.log(this.foo);  \n        console.log(self.foo);  \n        (function() &#123;\n            console.log(this.foo);  \n            console.log(self.foo);  \n        &#125;());\n    &#125;\n&#125;;\nmyObject.func();\n复制代码</code></pre>\n\n<p>输出结果：bar bar undefined bar</p>\n<p><strong>解析：</strong></p>\n<ol>\n<li>首先func是由myObject调用的，this指向myObject。又因为var self &#x3D; this;所以self指向myObject。</li>\n<li>这个立即执行匿名函数表达式是由window调用的，this指向window 。立即执行匿名函数的作用域处于myObject.func的作用域中，在这个作用域找不到self变量，沿着作用域链向上查找self变量，找到了指向 myObject对象的self。</li>\n</ol>\n<h3 id=\"8-代码输出问题\"><a href=\"#8-代码输出问题\" class=\"headerlink\" title=\"8. 代码输出问题\"></a>8. 代码输出问题</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">window.number &#x3D; 2;\nvar obj &#x3D; &#123;\n number: 3,\n db1: (function()&#123;\n   console.log(this);\n   this.number *&#x3D; 4;\n   return function()&#123;\n     console.log(this);\n     this.number *&#x3D; 5;\n   &#125;\n &#125;)()\n&#125;\nvar db1 &#x3D; obj.db1;\ndb1();\nobj.db1();\nconsole.log(obj.number);     &#x2F;&#x2F; 15\nconsole.log(window.number);  &#x2F;&#x2F; 40\n复制代码</code></pre>\n\n<p>这道题目看清起来有点乱，但是实际上是考察this指向的:</p>\n<ol>\n<li>执行db1()时，this指向全局作用域，所以window.number * 4 &#x3D; 8，然后执行匿名函数， 所以window.number * 5 &#x3D; 40；</li>\n<li>执行obj.db1();时，this指向obj对象，执行匿名函数，所以obj.numer * 5 &#x3D; 15。</li>\n</ol>\n<h3 id=\"9-代码输出结果-1\"><a href=\"#9-代码输出结果-1\" class=\"headerlink\" title=\"9. 代码输出结果\"></a>9. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var length &#x3D; 10;\nfunction fn() &#123;\n    console.log(this.length);\n&#125;\n \nvar obj &#x3D; &#123;\n  length: 5,\n  method: function(fn) &#123;\n    fn();\n    arguments[0]();\n  &#125;\n&#125;;\n \nobj.method(fn, 1);\n复制代码</code></pre>\n\n<p>输出结果： 10 2</p>\n<p><strong>解析：</strong></p>\n<ol>\n<li>第一次执行fn()，this指向window对象，输出10。</li>\n<li>第二次执行arguments<a href=\"https://link.juejin.cn/?target=\">0</a>，相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。</li>\n</ol>\n<h3 id=\"10-代码输出结果-1\"><a href=\"#10-代码输出结果-1\" class=\"headerlink\" title=\"10. 代码输出结果\"></a>10. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var a &#x3D; 1;\nfunction printA()&#123;\n  console.log(this.a);\n&#125;\nvar obj&#x3D;&#123;\n  a:2,\n  foo:printA,\n  bar:function()&#123;\n    printA();\n  &#125;\n&#125;\n\nobj.foo(); &#x2F;&#x2F; 2\nobj.bar(); &#x2F;&#x2F; 1\nvar foo &#x3D; obj.foo;\nfoo(); &#x2F;&#x2F; 1\n复制代码</code></pre>\n\n<p>输出结果： 2 1 1</p>\n<p><strong>解析：</strong></p>\n<ol>\n<li>obj.foo()，foo 的this指向obj对象，所以a会输出2；</li>\n<li>obj.bar()，printA在bar方法中执行，所以此时printA的this指向的是window，所以会输出1；</li>\n<li>foo()，foo是在全局对象中执行的，所以其this指向的是window，所以会输出1；</li>\n</ol>\n<h3 id=\"11-代码输出结果-1\"><a href=\"#11-代码输出结果-1\" class=\"headerlink\" title=\"11. 代码输出结果\"></a>11. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var x &#x3D; 3;\nvar y &#x3D; 4;\nvar obj &#x3D; &#123;\n    x: 1,\n    y: 6,\n    getX: function() &#123;\n        var x &#x3D; 5;\n        return function() &#123;\n            return this.x;\n        &#125;();\n    &#125;,\n    getY: function() &#123;\n        var y &#x3D; 7;\n        return this.y;\n    &#125;\n&#125;\nconsole.log(obj.getX()) &#x2F;&#x2F; 3\nconsole.log(obj.getY()) &#x2F;&#x2F; 6\n复制代码</code></pre>\n\n<p>输出结果：3 6</p>\n<p><strong>解析：</strong></p>\n<ol>\n<li>我们知道，匿名函数的this是指向全局对象的，所以this指向window，会打印出3；</li>\n<li>getY是由obj调用的，所以其this指向的是obj对象，会打印出6。</li>\n</ol>\n<h3 id=\"12-代码输出结果-1\"><a href=\"#12-代码输出结果-1\" class=\"headerlink\" title=\"12. 代码输出结果\"></a>12. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\"> var a &#x3D; 10; \n var obt &#x3D; &#123; \n   a: 20, \n   fn: function()&#123; \n     var a &#x3D; 30; \n     console.log(this.a)\n   &#125; \n &#125;\n obt.fn();  &#x2F;&#x2F; 20\n obt.fn.call(); &#x2F;&#x2F; 10\n (obt.fn)(); &#x2F;&#x2F; 20\n复制代码</code></pre>\n\n<p>输出结果： 20 10 20</p>\n<p><strong>解析：</strong></p>\n<ol>\n<li> obt.fn()，fn是由obt调用的，所以其this指向obt对象，会打印出20；</li>\n<li> obt.fn.call()，这里call的参数啥都没写，就表示null，我们知道如果call的参数为undefined或null，那么this就会指向全局对象this，所以会打印出 10；</li>\n<li> (obt.fn)()， 这里给表达式加了括号，而括号的作用是改变表达式的运算顺序，而在这里加与不加括号并无影响；相当于  obt.fn()，所以会打印出 20；</li>\n</ol>\n<h3 id=\"13-代码输出结果-1\"><a href=\"#13-代码输出结果-1\" class=\"headerlink\" title=\"13. 代码输出结果\"></a>13. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function a(xx)&#123;\n  this.x &#x3D; xx;\n  return this\n&#125;;\nvar x &#x3D; a(5);\nvar y &#x3D; a(6);\n\nconsole.log(x.x)  &#x2F;&#x2F; undefined\nconsole.log(y.x)  &#x2F;&#x2F; 6\n复制代码</code></pre>\n\n<p>输出结果： undefined 6</p>\n<p><strong>解析：</strong></p>\n<ol>\n<li>最关键的就是var x &#x3D; a(5)，函数a是在全局作用域调用，所以函数内部的this指向window对象。<strong>所以 this.x &#x3D; 5 就相当于：window.x &#x3D; 5。</strong>之后 return this，也就是说 var x &#x3D; a(5) 中的x变量的值是window，这里的x将函数内部的x的值覆盖了。然后执行console.log(x.x)， 也就是console.log(window.x)，而window对象中没有x属性，所以会输出undefined。</li>\n<li>当指向y.x时，会给全局变量中的x赋值为6，所以会打印出6。</li>\n</ol>\n<h3 id=\"14-代码输出结果-1\"><a href=\"#14-代码输出结果-1\" class=\"headerlink\" title=\"14. 代码输出结果\"></a>14. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function foo(something)&#123;\n    this.a &#x3D; something\n&#125;\n\nvar obj1 &#x3D; &#123;\n    foo: foo\n&#125;\n\nvar obj2 &#x3D; &#123;&#125;\n\nobj1.foo(2); \nconsole.log(obj1.a); &#x2F;&#x2F; 2\n\nobj1.foo.call(obj2, 3);\nconsole.log(obj2.a); &#x2F;&#x2F; 3\n\nvar bar &#x3D; new obj1.foo(4)\nconsole.log(obj1.a); &#x2F;&#x2F; 2\nconsole.log(bar.a); &#x2F;&#x2F; 4\n复制代码</code></pre>\n\n<p>输出结果： 2 3 2 4</p>\n<p><strong>解析：</strong></p>\n<ol>\n<li>首先执行obj1.foo(2); 会在obj中添加a属性，其值为2。之后执行obj1.a，a是右obj1调用的，所以this指向obj，打印出2；</li>\n<li>执行 obj1.foo.call(obj2, 3) 时，会将foo的this指向obj2，后面就和上面一样了，所以会打印出3；</li>\n<li>obj1.a会打印出2；</li>\n<li>最后就是考察this绑定的优先级了，new 绑定是比隐式绑定优先级高，所以会输出4。</li>\n</ol>\n<h3 id=\"15-代码输出结果-1\"><a href=\"#15-代码输出结果-1\" class=\"headerlink\" title=\"15. 代码输出结果\"></a>15. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function foo(something)&#123;\n    this.a &#x3D; something\n&#125;\n\nvar obj1 &#x3D; &#123;&#125;\n\nvar bar &#x3D; foo.bind(obj1);\nbar(2);\nconsole.log(obj1.a); &#x2F;&#x2F; 2\n\nvar baz &#x3D; new bar(3);\nconsole.log(obj1.a); &#x2F;&#x2F; 2\nconsole.log(baz.a); &#x2F;&#x2F; 3\n复制代码</code></pre>\n\n<p>输出结果： 2 2 3</p>\n<p>这道题目和上面题目差不多，主要都是考察this绑定的优先级。记住以下结论即可：<strong>this绑定的优先级：new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。</strong></p>\n<h2 id=\"三、作用域-amp-变量提升-amp-闭包\"><a href=\"#三、作用域-amp-变量提升-amp-闭包\" class=\"headerlink\" title=\"三、作用域&amp;变量提升&amp;闭包\"></a>三、作用域&amp;变量提升&amp;闭包</h2><h3 id=\"1-代码输出结果-2\"><a href=\"#1-代码输出结果-2\" class=\"headerlink\" title=\"1. 代码输出结果\"></a>1. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">(function()&#123;\n   var x &#x3D; y &#x3D; 1;\n&#125;)();\nvar z;\n\nconsole.log(y); &#x2F;&#x2F; 1\nconsole.log(z); &#x2F;&#x2F; undefined\nconsole.log(x); &#x2F;&#x2F; Uncaught ReferenceError: x is not defined\n复制代码</code></pre>\n\n<p>这段代码的关键在于：var x &#x3D; y &#x3D; 1; 实际上这里是从右往左执行的，首先执行y &#x3D; 1, 因为y没有使用var声明，所以它是一个全局变量，然后第二步是将y赋值给x，讲一个全局变量赋值给了一个局部变量，最终，x是一个局部变量，y是一个全局变量，所以打印x是报错。</p>\n<h3 id=\"2-代码输出结果-2\"><a href=\"#2-代码输出结果-2\" class=\"headerlink\" title=\"2. 代码输出结果\"></a>2. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var a, b\n(function () &#123;\n   console.log(a);\n   console.log(b);\n   var a &#x3D; (b &#x3D; 3);\n   console.log(a);\n   console.log(b);   \n&#125;)()\nconsole.log(a);\nconsole.log(b);\n复制代码</code></pre>\n\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">undefined \nundefined \n3 \n3 \nundefined \n3\n复制代码</code></pre>\n\n<p>这个题目和上面题目考察的知识点类似，b赋值为3，b此时是一个全局变量，而将3赋值给a，a是一个局部变量，所以最后打印的时候，a仍旧是undefined。</p>\n<h3 id=\"3-代码输出结果-2\"><a href=\"#3-代码输出结果-2\" class=\"headerlink\" title=\"3. 代码输出结果\"></a>3. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var friendName &#x3D; &#39;World&#39;;\n(function() &#123;\n  if (typeof friendName &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n    var friendName &#x3D; &#39;Jack&#39;;\n    console.log(&#39;Goodbye &#39; + friendName);\n  &#125; else &#123;\n    console.log(&#39;Hello &#39; + friendName);\n  &#125;\n&#125;)();\n复制代码</code></pre>\n\n<p>输出结果：Goodbye Jack</p>\n<p>我们知道，在 JavaScript中， Function 和 var 都会被提升（变量提升），所以上面的代码就相当于：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var name &#x3D; &#39;World!&#39;;\n(function () &#123;\n    var name;\n    if (typeof name &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n        name &#x3D; &#39;Jack&#39;;\n        console.log(&#39;Goodbye &#39; + name);\n    &#125; else &#123;\n        console.log(&#39;Hello &#39; + name);\n    &#125;\n&#125;)();\n复制代码</code></pre>\n\n<p>这样，答案就一目了然了。</p>\n<h3 id=\"4-代码输出结果-2\"><a href=\"#4-代码输出结果-2\" class=\"headerlink\" title=\"4. 代码输出结果\"></a>4. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function fn1()&#123;\n  console.log(&#39;fn1&#39;)\n&#125;\nvar fn2\n \nfn1()\nfn2()\n \nfn2 &#x3D; function() &#123;\n  console.log(&#39;fn2&#39;)\n&#125;\n \nfn2()\n复制代码</code></pre>\n\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">fn1\nUncaught TypeError: fn2 is not a function\nfn2\n复制代码</code></pre>\n\n<p>这里也是在考察变量提升，关键在于第一个fn2()，这时fn2仍是一个undefined的变量，所以会报错fn2不是一个函数。</p>\n<h3 id=\"5-代码输出结果-1\"><a href=\"#5-代码输出结果-1\" class=\"headerlink\" title=\"5. 代码输出结果\"></a>5. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function a() &#123;\n    var temp &#x3D; 10;\n    function b() &#123;\n        console.log(temp); &#x2F;&#x2F; 10\n    &#125;\n    b();\n&#125;\na();\n\nfunction a() &#123;\n    var temp &#x3D; 10;\n    b();\n&#125;\nfunction b() &#123;\n    console.log(temp); &#x2F;&#x2F; 报错 Uncaught ReferenceError: temp is not defined\n&#125;\na();\n复制代码</code></pre>\n\n<p>在上面的两段代码中，第一段是可以正常输出，这个应该没啥问题，关键在于第二段代码，它会报错Uncaught ReferenceError: temp is not defined。这时因为在b方法执行时，temp 的值为undefined。</p>\n<h3 id=\"6-代码输出结果-2\"><a href=\"#6-代码输出结果-2\" class=\"headerlink\" title=\"6. 代码输出结果\"></a>6. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\"> var a&#x3D;3;\n function c()&#123;\n    alert(a);\n &#125;\n (function()&#123;\n  var a&#x3D;4;\n  c();\n &#125;)();\n复制代码</code></pre>\n\n<p>js中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等</p>\n<h3 id=\"7-代码输出问题\"><a href=\"#7-代码输出问题\" class=\"headerlink\" title=\"7. 代码输出问题\"></a>7. 代码输出问题</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function fun(n, o) &#123;\n  console.log(o)\n  return &#123;\n    fun: function(m)&#123;\n      return fun(m, n);\n    &#125;\n  &#125;;\n&#125;\nvar a &#x3D; fun(0);  a.fun(1);  a.fun(2);  a.fun(3);\nvar b &#x3D; fun(0).fun(1).fun(2).fun(3);\nvar c &#x3D; fun(0).fun(1);  c.fun(2);  c.fun(3);\n复制代码</code></pre>\n\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">undefined  0  0  0\nundefined  0  1  2\nundefined  0  1  1\n复制代码</code></pre>\n\n<p>这是一道关于闭包的题目，对于fun方法，调用之后返回的是一个对象。我们知道，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。所以 <code>console.log(o);</code> 会输出undefined。而a就是是fun(0)返回的那个对象。也就是说，函数fun中参数 n 的值是0，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0。了解了这一点，其他运算就很简单了，以此类推。</p>\n<h3 id=\"8-代码输出结果-1\"><a href=\"#8-代码输出结果-1\" class=\"headerlink\" title=\"8. 代码输出结果\"></a>8. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">f &#x3D; function() &#123;return true;&#125;;   \ng &#x3D; function() &#123;return false;&#125;;   \n(function() &#123;   \n   if (g() &amp;&amp; [] &#x3D;&#x3D; ![]) &#123;   \n      f &#x3D; function f() &#123;return false;&#125;;   \n      function g() &#123;return true;&#125;   \n   &#125;   \n&#125;)();   \nconsole.log(f());\n复制代码</code></pre>\n\n<p>输出结果： false</p>\n<p>这里首先定义了两个变量f和g，我们知道变量是可以重新赋值的。后面是一个匿名自执行函数，在 if 条件中调用了函数 g()，由于在匿名函数中，又重新定义了函数g，就覆盖了外部定义的变量g，所以，这里调用的是内部函数 g 方法，返回为 true。第一个条件通过，进入第二个条件。</p>\n<p>第二个条件是[] &#x3D;&#x3D; ![]，先看 ![] ，在 JavaScript 中，当用于布尔运算时，比如在这里，对象的非空引用被视为 true，空引用 null 则被视为 false。由于这里不是一个 null, 而是一个没有元素的数组，所以 [] 被视为 true, 而 ![] 的结果就是 false 了。当一个布尔值参与到条件运算的时候，true 会被看作 1, 而 false 会被看作 0。现在条件变成了 [] &#x3D;&#x3D; 0 的问题了，当一个对象参与条件比较的时候，它会被求值，求值的结果是数组成为一个字符串，[] 的结果就是 ‘’ ，而 ‘’ 会被当作 0 ，所以，条件成立。</p>\n<p>两个条件都成立，所以会执行条件中的代码， f 在定义是没有使用var，所以他是一个全局变量。因此，这里会通过闭包访问到外部的变量 f, 重新赋值，现在执行 f 函数返回值已经成为 false 了。而 g 则不会有这个问题，这里是一个函数内定义的 g，不会影响到外部的 g 函数。所以最后的结果就是 false。</p>\n<h2 id=\"四、原型-amp-继承\"><a href=\"#四、原型-amp-继承\" class=\"headerlink\" title=\"四、原型&amp;继承\"></a>四、原型&amp;继承</h2><h3 id=\"1-代码输出结果-3\"><a href=\"#1-代码输出结果-3\" class=\"headerlink\" title=\"1. 代码输出结果\"></a>1. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function Person(name) &#123;\n    this.name &#x3D; name\n&#125;\nvar p2 &#x3D; new Person(&#39;king&#39;);\nconsole.log(p2.__proto__) &#x2F;&#x2F;Person.prototype\nconsole.log(p2.__proto__.__proto__) &#x2F;&#x2F;Object.prototype\nconsole.log(p2.__proto__.__proto__.__proto__) &#x2F;&#x2F; null\nconsole.log(p2.__proto__.__proto__.__proto__.__proto__)&#x2F;&#x2F;null后面没有了，报错\nconsole.log(p2.__proto__.__proto__.__proto__.__proto__.__proto__)&#x2F;&#x2F;null后面没有了，报错\nconsole.log(p2.constructor)&#x2F;&#x2F;Person\nconsole.log(p2.prototype)&#x2F;&#x2F;undefined p2是实例，没有prototype属性\nconsole.log(Person.constructor)&#x2F;&#x2F;Function 一个空函数\nconsole.log(Person.prototype)&#x2F;&#x2F;打印出Person.prototype这个对象里所有的方法和属性\nconsole.log(Person.prototype.constructor)&#x2F;&#x2F;Person\nconsole.log(Person.prototype.__proto__)&#x2F;&#x2F; Object.prototype\nconsole.log(Person.__proto__) &#x2F;&#x2F;Function.prototype\nconsole.log(Function.prototype.__proto__)&#x2F;&#x2F;Object.prototype\nconsole.log(Function.__proto__)&#x2F;&#x2F;Function.prototype\nconsole.log(Object.__proto__)&#x2F;&#x2F;Function.prototype\nconsole.log(Object.prototype.__proto__)&#x2F;&#x2F;null\n复制代码</code></pre>\n\n<p>这道义题目考察原型、原型链的基础，记住就可以了。</p>\n<h3 id=\"2-代码输出结果-3\"><a href=\"#2-代码输出结果-3\" class=\"headerlink\" title=\"2. 代码输出结果\"></a>2. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; a\nfunction Foo () &#123;\n getName &#x3D; function () &#123;\n   console.log(1);\n &#125;\n return this;\n&#125;\n&#x2F;&#x2F; b\nFoo.getName &#x3D; function () &#123;\n console.log(2);\n&#125;\n&#x2F;&#x2F; c\nFoo.prototype.getName &#x3D; function () &#123;\n console.log(3);\n&#125;\n&#x2F;&#x2F; d\nvar getName &#x3D; function () &#123;\n console.log(4);\n&#125;\n&#x2F;&#x2F; e\nfunction getName () &#123;\n console.log(5);\n&#125;\n\nFoo.getName();           &#x2F;&#x2F; 2\ngetName();               &#x2F;&#x2F; 4\nFoo().getName();         &#x2F;&#x2F; 1\ngetName();               &#x2F;&#x2F; 1 \nnew Foo.getName();       &#x2F;&#x2F; 2\nnew Foo().getName();     &#x2F;&#x2F; 3\nnew new Foo().getName(); &#x2F;&#x2F; 3\n复制代码</code></pre>\n\n<p>输出结果：2 4 1 1 2 3 3</p>\n<p><strong>解析：</strong></p>\n<ol>\n<li><strong>Foo.getName()，</strong> Foo为一个函数对象，对象都可以有属性，b 处定义Foo的getName属性为函数，输出2；</li>\n<li><strong>getName()，</strong> 这里看d、e处，d为函数表达式，e为函数声明，两者区别在于变量提升，函数声明的 5 会被后边函数表达式的 4 覆盖；</li>\n<li>** Foo().getName()，** 这里要看a处，在Foo内部将全局的getName重新赋值为 console.log(1) 的函数，执行Foo()返回 this，这个this指向window，Foo().getName() 即为window.getName()，输出 1；</li>\n<li><strong>getName()，</strong> 上面3中，全局的getName已经被重新赋值，所以这里依然输出 1；</li>\n<li><strong>new Foo.getName()，</strong> 这里等价于 new (Foo.getName())，先执行 Foo.getName()，输出 2，然后new一个实例；</li>\n<li><strong>new Foo().getName()，</strong> 这 里等价于 (new Foo()).getName(), 先new一个Foo的实例，再执行这个实例的getName方法，但是这个实例本身没有这个方法，所以去原型链__protot__上边找，实例.<strong>protot</strong> &#x3D;&#x3D;&#x3D; Foo.prototype，所以输出 3；</li>\n<li><strong>new new Foo().getName()，</strong> 这里等价于new (new Foo().getName())，如上述6，先输出 3，然后new 一个 new Foo().getName() 的实例。</li>\n</ol>\n<h3 id=\"3-代码输出结果-3\"><a href=\"#3-代码输出结果-3\" class=\"headerlink\" title=\"3. 代码输出结果\"></a>3. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var F &#x3D; function() &#123;&#125;;\nObject.prototype.a &#x3D; function() &#123;\n  console.log(&#39;a&#39;);\n&#125;;\nFunction.prototype.b &#x3D; function() &#123;\n  console.log(&#39;b&#39;);\n&#125;\nvar f &#x3D; new F();\nf.a();\nf.b();\nF.a();\nF.b()\n复制代码</code></pre>\n\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">a\nUncaught TypeError: f.b is not a function\na\nb\n复制代码</code></pre>\n\n<p><strong>解析：</strong></p>\n<ol>\n<li>f 并不是 Function 的实例，因为它本来就不是构造函数，调用的是 Function 原型链上的相关属性和方法，只能访问到 Object 原型链。所以 f.a() 输出 a  ，而 f.b() 就报错了。</li>\n<li>F 是个构造函数，而 F 是构造函数 Function 的一个实例。因为 F instanceof  Object &#x3D;&#x3D;&#x3D; true，F instanceof Function &#x3D;&#x3D;&#x3D; true，由此可以得出结论：F 是 Object 和 Function 两个的实例，即 F 能访问到 a， 也能访问到 b。所以 F.a() 输出 a ，F.b() 输出 b。</li>\n</ol>\n<h3 id=\"4-代码输出结果-3\"><a href=\"#4-代码输出结果-3\" class=\"headerlink\" title=\"4. 代码输出结果\"></a>4. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function Foo()&#123;\n    Foo.a &#x3D; function()&#123;\n        console.log(1);\n    &#125;\n    this.a &#x3D; function()&#123;\n        console.log(2)\n    &#125;\n&#125;\n\nFoo.prototype.a &#x3D; function()&#123;\n    console.log(3);\n&#125;\n\nFoo.a &#x3D; function()&#123;\n    console.log(4);\n&#125;\n\nFoo.a();\nlet obj &#x3D; new Foo();\nobj.a();\nFoo.a();\n复制代码</code></pre>\n\n<p>输出结果：4 2 1</p>\n<p><strong>解析：</strong></p>\n<ol>\n<li>Foo.a() 这个是调用 Foo 函数的静态方法 a，虽然 Foo 中有优先级更高的属性方法 a，但 Foo 此时没有被调用，所以此时输出 Foo 的静态方法 a 的结果：4</li>\n<li>let obj &#x3D; new Foo(); 使用了 new 方法调用了函数，返回了函数实例对象，此时 Foo 函数内部的属性方法初始化，原型链建立。</li>\n<li>obj.a() ; 调用 obj 实例上的方法 a，该实例上目前有两个 a 方法：一个是内部属性方法，另一个是原型上的方法。当这两者都存在时，首先查找 ownProperty ，如果没有才去原型链上找，所以调用实例上的 a 输出：2</li>\n<li>Foo.a() ; 根据第2步可知 Foo 函数内部的属性方法已初始化，覆盖了同名的静态方法，所以输出：1</li>\n</ol>\n<h3 id=\"5-代码输出结果-2\"><a href=\"#5-代码输出结果-2\" class=\"headerlink\" title=\"5. 代码输出结果\"></a>5. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function Dog() &#123;\n  this.name &#x3D; &#39;puppy&#39;\n&#125;\nDog.prototype.bark &#x3D; () &#x3D;&gt; &#123;\n  console.log(&#39;woof!woof!&#39;)\n&#125;\nconst dog &#x3D; new Dog()\nconsole.log(Dog.prototype.constructor &#x3D;&#x3D;&#x3D; Dog &amp;&amp; dog.constructor &#x3D;&#x3D;&#x3D; Dog &amp;&amp; dog instanceof Dog)\n复制代码</code></pre>\n\n<p>输出结果：true</p>\n<p><strong>解析：</strong> 因为constructor是prototype上的属性，所以dog.constructor实际上就是指向Dog.prototype.constructor；constructor属性指向构造函数。instanceof而实际检测的是类型是否在实例的原型链上。</p>\n<p>constructor是prototype上的属性，这一点很容易被忽略掉。constructor和instanceof 的作用是不同的，感性地来说，constructor的限制比较严格，它只能严格对比对象的构造函数是不是指定的值；而instanceof比较松散，只要检测的类型在原型链上，就会返回true。</p>\n<h3 id=\"6-代码输出结果-3\"><a href=\"#6-代码输出结果-3\" class=\"headerlink\" title=\"6. 代码输出结果\"></a>6. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">var A &#x3D; &#123;n: 4399&#125;;\nvar B &#x3D;  function()&#123;this.n &#x3D; 9999&#125;;\nvar C &#x3D;  function()&#123;var n &#x3D; 8888&#125;;\nB.prototype &#x3D; A;\nC.prototype &#x3D; A;\nvar b &#x3D; new B();\nvar c &#x3D; new C();\nA.n++\nconsole.log(b.n);\nconsole.log(c.n);\n复制代码</code></pre>\n\n<p>输出结果：9999 4400</p>\n<p><strong>解析：</strong></p>\n<ol>\n<li>console.log(b.n)，在查找b.n是首先查找 b 对象自身有没有 n 属性，如果没有会去原型（prototype）上查找，当执行var b &#x3D; new B()时，函数内部this.n&#x3D;9999(此时this指向 b) 返回b对象，b对象有自身的n属性，所以返回 9999。</li>\n<li>console.log(c.n)，同理，当执行var c &#x3D; new C()时，c对象没有自身的n属性，向上查找，找到原型 （prototype）上的 n 属性，因为 A.n++(此时对象A中的n为4400)， 所以返回4400。</li>\n</ol>\n<h3 id=\"7-代码输出问题-1\"><a href=\"#7-代码输出问题-1\" class=\"headerlink\" title=\"7. 代码输出问题\"></a>7. 代码输出问题</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function A()&#123;\n&#125;\nfunction B(a)&#123;\n　　this.a &#x3D; a;\n&#125;\nfunction C(a)&#123;\n　　if(a)&#123;\nthis.a &#x3D; a;\n　　&#125;\n&#125;\nA.prototype.a &#x3D; 1;\nB.prototype.a &#x3D; 1;\nC.prototype.a &#x3D; 1;\n \nconsole.log(new A().a);\nconsole.log(new B().a);\nconsole.log(new C(2).a);\n复制代码</code></pre>\n\n<p>输出结果：1 undefined 2</p>\n<p><strong>解析：</strong></p>\n<ol>\n<li>console.log(new A().a)，new A()为构造函数创建的对象，本身没有a属性，所以向它的原型去找，发现原型的a属性的属性值为1，故该输出值为1；</li>\n<li>console.log(new B().a)，ew B()为构造函数创建的对象，该构造函数有参数a，但该对象没有传参，故该输出值为undefined;</li>\n<li>console.log(new C(2).a)，new C()为构造函数创建的对象，该构造函数有参数a，且传的实参为2，执行函数内部，发现if为真，执行this.a &#x3D; 2,故属性a的值为2。</li>\n</ol>\n<h3 id=\"8-代码输出问题-1\"><a href=\"#8-代码输出问题-1\" class=\"headerlink\" title=\"8 代码输出问题\"></a>8 代码输出问题</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function Parent() &#123;\n    this.a &#x3D; 1;\n    this.b &#x3D; [1, 2, this.a];\n    this.c &#x3D; &#123; demo: 5 &#125;;\n    this.show &#x3D; function () &#123;\n        console.log(this.a , this.b , this.c.demo );\n    &#125;\n&#125;\n\nfunction Child() &#123;\n    this.a &#x3D; 2;\n    this.change &#x3D; function () &#123;\n        this.b.push(this.a);\n        this.a &#x3D; this.b.length;\n        this.c.demo &#x3D; this.a++;\n    &#125;\n&#125;\n\nChild.prototype &#x3D; new Parent();\nvar parent &#x3D; new Parent();\nvar child1 &#x3D; new Child();\nvar child2 &#x3D; new Child();\nchild1.a &#x3D; 11;\nchild2.a &#x3D; 12;\nparent.show();\nchild1.show();\nchild2.show();\nchild1.change();\nchild2.change();\nparent.show();\nchild1.show();\nchild2.show();\n复制代码</code></pre>\n\n<p>输出结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">parent.show(); &#x2F;&#x2F; 1  [1,2,1] 5\n\nchild1.show(); &#x2F;&#x2F; 11 [1,2,1] 5\nchild2.show(); &#x2F;&#x2F; 12 [1,2,1] 5\n\nparent.show(); &#x2F;&#x2F; 1 [1,2,1] 5\n\nchild1.show(); &#x2F;&#x2F; 5 [1,2,1,11,12] 5\n\nchild2.show(); &#x2F;&#x2F; 6 [1,2,1,11,12] 5\n复制代码</code></pre>\n\n<p>这道题目值得神帝，他涉及到的知识点很多，例如<strong>this的指向、原型、原型链、类的继承、数据类型</strong>等。</p>\n<p><strong>解析：</strong></p>\n<ol>\n<li>parent.show()，可以直接获得所需的值，没啥好说的；</li>\n<li>child1.show()，<code>Child</code>的构造函数原本是指向<code>Child</code>的，题目显式将<code>Child</code>类的原型对象指向了<code>Parent</code>类的一个实例，需要注意<code>Child.prototype</code>指向的是<code>Parent</code>的实例<code>parent</code>，而不是指向<code>Parent</code>这个类。</li>\n<li>child2.show()，这个也没啥好说的；</li>\n<li>parent.show()，<code>parent</code>是一个<code>Parent</code>类的实例，<code>Child.prorotype</code>指向的是<code>Parent</code>类的另一个实例，两者在堆内存中互不影响，所以上述操作不影响<code>parent</code>实例，所以输出结果不变；</li>\n<li>child1.show()，<code>child1</code>执行了<code>change()</code>方法后，发生了怎样的变化呢?</li>\n</ol>\n<ul>\n<li><strong>this.b.push(this.a)，</strong>由于this的动态指向特性，this.b会指向<code>Child.prototype</code>上的<strong>b</strong>数组,this.a会指向<code>child1</code>的<strong>a</strong>属性,所以<code>Child.prototype.b</code>变成了**[1,2,1,11]**;</li>\n<li><strong>this.a &#x3D; this.b.length，</strong>这条语句中<code>this.a</code>和<code>this.b</code>的指向与上一句一致，故结果为<code>child1.a</code>变为<strong>4</strong>;</li>\n<li><strong>this.c.demo &#x3D; this.a++，</strong>由于<code>child1</code>自身属性并没有<strong>c</strong>这个属性，所以此处的<code>this.c</code>会指向<code>Child.prototype.c</code>，<code>this.a</code>值为<strong>4</strong>，为原始类型，故赋值操作时会直接赋值，<code>Child.prototype.c.demo</code>的结果为<strong>4</strong>，而<code>this.a</code>随后自增为<strong>5(4 + 1 &#x3D; 5)。</strong></li>\n</ul>\n<ol start=\"6\">\n<li><code>child2</code>执行了<code>change()</code>方法, 而<code>child2</code>和<code>child1</code>均是<code>Child</code>类的实例，所以他们的原型链指向同一个原型对象<code>Child.prototype</code>,也就是同一个<code>parent</code>实例，所以<code>child2.change()</code>中所有影响到原型对象的语句都会影响<code>child1</code>的最终输出结果。</li>\n</ol>\n<ul>\n<li><strong>this.b.push(this.a)，</strong>由于this的动态指向特性，this.b会指向<code>Child.prototype</code>上的<strong>b</strong>数组,this.a会指向<code>child2</code>的<strong>a</strong>属性,所以<code>Child.prototype.b</code>变成了**[1,2,1,11,12]**;</li>\n<li><strong>this.a &#x3D; this.b.length，</strong>这条语句中<code>this.a</code>和<code>this.b</code>的指向与上一句一致，故结果为<code>child2.a</code>变为<strong>5</strong>;</li>\n<li><strong>this.c.demo &#x3D; this.a++，</strong>由于<code>child2</code>自身属性并没有<strong>c</strong>这个属性，所以此处的<code>this.c</code>会指向<code>Child.prototype.c</code>，故执行结果为<code>Child.prototype.c.demo</code>的值变为<code>child2.a</code>的值<strong>5</strong>，而<code>child2.a</code>最终自增为<strong>6(5 + 1 &#x3D; 6)。</strong></li>\n</ul>\n<h3 id=\"9-代码输出结果-2\"><a href=\"#9-代码输出结果-2\" class=\"headerlink\" title=\"9. 代码输出结果\"></a>9. 代码输出结果</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">function SuperType()&#123;\n    this.property &#x3D; true;\n&#125;\n\nSuperType.prototype.getSuperValue &#x3D; function()&#123;\n    return this.property;\n&#125;;\n\nfunction SubType()&#123;\n    this.subproperty &#x3D; false;\n&#125;\n\nSubType.prototype &#x3D; new SuperType();\nSubType.prototype.getSubValue &#x3D; function ()&#123;\n    return this.subproperty;\n&#125;;\n\nvar instance &#x3D; new SubType();\nconsole.log(instance.getSuperValue());\n复制代码</code></pre>\n\n<p>输出结果：true</p>\n<p>实际上，这段代码就是在实现原型链继承，SubType继承了SuperType，本质是重写了SubType的原型对象，代之以一个新类型的实例。SubType的原型被重写了，所以instance.constructor指向的是SuperType。具体如下： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5df64f0bdecb428ea327ae349614c04e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n","text":"一、异步&amp;事件循环1. 代码输出结果const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; console.log(1); console.log(2); &#125;); promise....","link":"","photos":[],"count_time":{"symbolsCount":"41k","symbolsTime":"38 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%BC%82%E6%AD%A5-amp-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">一、异步&amp;事件循环</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">1. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">2. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">3. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">4. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">5. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">6. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">7. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">8. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">9. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">10. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">11. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">12. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">13. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">14. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">15. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">16. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">17. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">18. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#19-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">19. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">20. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#21-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">21. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#22-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">22. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#23-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">23. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#24-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">24. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#25-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">25. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#26-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">26. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#27-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">27. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#28-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">28. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#29-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">29. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#30-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">30. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#31-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">31. 代码输出结果</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81this\"><span class=\"toc-text\">二、this</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">1. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">2. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">3. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">4. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">6. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">7. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">8. 代码输出问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">9. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">10. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">11. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">12. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">13. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">14. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">15. 代码输出结果</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F-amp-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-amp-%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">三、作用域&amp;变量提升&amp;闭包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2\"><span class=\"toc-text\">1. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2\"><span class=\"toc-text\">2. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2\"><span class=\"toc-text\">3. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2\"><span class=\"toc-text\">4. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">5. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2\"><span class=\"toc-text\">6. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">7. 代码输出问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">8. 代码输出结果</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E5%8E%9F%E5%9E%8B-amp-%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">四、原型&amp;继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3\"><span class=\"toc-text\">1. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3\"><span class=\"toc-text\">2. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3\"><span class=\"toc-text\">3. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3\"><span class=\"toc-text\">4. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2\"><span class=\"toc-text\">5. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3\"><span class=\"toc-text\">6. 代码输出结果</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98-1\"><span class=\"toc-text\">7. 代码输出问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98-1\"><span class=\"toc-text\">8 代码输出问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2\"><span class=\"toc-text\">9. 代码输出结果</span></a></li></ol></li></ol>","author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"MJML邮件模版实战","uid":"d15af8effdd73a8b6f9c6e84242a848d","slug":"MJML邮件模版实战","date":"2022-09-07T14:13:14.000Z","updated":"2023-04-21T09:46:29.872Z","comments":true,"path":"api/articles/MJML邮件模版实战.json","keywords":null,"cover":[],"text":" 前言最近画个邮件模版使用table布局一言难尽，还要兼容各种邮件厂商，最后找了一个邮件模版来处理。 MJMLMJML是一种标记语言，旨在减少编写响应电子邮件的痛苦。它的语义语法使它简单明了，它丰富的标准组件库加快了您的开发时间，并减轻了您的电子邮件代码库。MJML的开源引擎生成...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"性能优化常用方案","uid":"b9b334bea88dfba73a4e01092c68ab76","slug":"性能优化常用方案","date":"2022-05-13T07:21:05.000Z","updated":"2023-04-21T09:41:38.644Z","comments":true,"path":"api/articles/性能优化常用方案.json","keywords":null,"cover":[],"text":"一、CDN1. CDN的概念CDN（Content Delivery Network，内容分发网络）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}