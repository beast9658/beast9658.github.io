{"title":"数组转树","uid":"d7aff688f09321eb25c6942e9ba97bfe","slug":"数组转树","date":"2021-09-02T13:54:10.000Z","updated":"2023-04-21T08:51:02.009Z","comments":true,"path":"api/articles/数组转树.json","keywords":null,"cover":null,"content":"<p>前端使用树插件是一个非常常见的使用场景。树插件的数据格式在我使用过的插件都是一样的。 而这个数据格式是由后端组装好返回给前端还是前端自己组装，这个问题在前端和后端也经常拿来撕逼。</p>\n<p>大多数情况下后端会组装好，也有一部分前端自己处理，早之前我合作过的一个后端提出了一个观点， 浏览器是每一个用户都有的，服务器是所有用户共同访问的，后端递归遍历组装树数据比前端处理更耗费性能。</p>\n<p>那时候我居然无言以对，几十条数据组装成树结构的数据居然能牵扯到服务器性能问题，那这个服务器还能做什么？</p>\n<p>也不是想讨论由前端还是后端处理的问题，这种简单的东西，只要商量一下，约定好了，哪一边处理都是可以的。</p>\n<p>现在网上数组转树结构的方法很多，都能够得到想要的结果，今天分享这个方法，我认为应该是性能最优的：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">let arr &#x3D; [\n  &#123;id: 1, name: &#39;部门1&#39;, pid: 0&#125;,\n  &#123;id: 2, name: &#39;部门2&#39;, pid: 3&#125;,\n  &#123;id: 3, name: &#39;部门3&#39;, pid: 1&#125;,\n  &#123;id: 4, name: &#39;部门3&#39;, pid: 0&#125;,\n  &#123;id: 5, name: &#39;部门4&#39;, pid: 4&#125;,\n  &#123;id: 6, name: &#39;部门5&#39;, pid: 0&#125;,\n  &#123;id: 7, name: &#39;部门5&#39;, pid: 6&#125;,\n  &#123;id: 8, name: &#39;部门5&#39;, pid: 7&#125;,\n]\n\nfunction arrayToTree(data) &#123;\n  let result &#x3D; [];\n  let itemMap &#x3D; &#123;&#125;;\n  for (let i &#x3D; 0; i &lt; data.length; i++) &#123;\n    let item &#x3D; data[i];\n    let id &#x3D; item.id;\n    let pid &#x3D; item.parentResourceId;\n    if(!itemMap[id])&#123;\n      itemMap[id] &#x3D; &#123;\n        children: []\n      &#125;\n    &#125;\n    itemMap[id] &#x3D; &#123;\n      ...item,\n      children: itemMap[id][&#39;children&#39;]\n    &#125;\n    let treeItem &#x3D; itemMap[id];\n    if(pid &#x3D;&#x3D;&#x3D; 0)&#123;\n      result.push(treeItem);\n    &#125;else&#123;\n      if(!itemMap[pid])&#123;\n        itemMap[pid] &#x3D; &#123;\n          children: []\n        &#125;\n      &#125;\n      itemMap[pid][&#39;children&#39;].push(treeItem);\n    &#125;\n  &#125;\n  return result;\n&#125;\nconsole.log(arrayToTree(arr));</code></pre>\n\n<p>得到的结果：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[    &#123;        &quot;id&quot;: 1,        &quot;name&quot;: &quot;部门1&quot;,        &quot;pid&quot;: 0,        &quot;children&quot;: [            &#123;                &quot;id&quot;: 2,                &quot;name&quot;: &quot;部门2&quot;,                &quot;pid&quot;: 1,                &quot;children&quot;: []\n            &#125;,\n            &#123;\n                &quot;id&quot;: 3,\n                &quot;name&quot;: &quot;部门3&quot;,\n                &quot;pid&quot;: 1,\n                &quot;children&quot;: []\n            &#125;\n        ]\n    &#125;,\n    &#123;\n        &quot;id&quot;: 4,\n        &quot;name&quot;: &quot;部门3&quot;,\n        &quot;pid&quot;: 0,\n        &quot;children&quot;: [\n            &#123;\n                &quot;id&quot;: 5,\n                &quot;name&quot;: &quot;部门4&quot;,\n                &quot;pid&quot;: 4,\n                &quot;children&quot;: []\n            &#125;\n        ]\n    &#125;,\n    &#123;\n        &quot;id&quot;: 6,\n        &quot;name&quot;: &quot;部门5&quot;,\n        &quot;pid&quot;: 0,\n        &quot;children&quot;: [\n            &#123;\n                &quot;id&quot;: 7,\n                &quot;name&quot;: &quot;部门5&quot;,\n                &quot;pid&quot;: 6,\n                &quot;children&quot;: [\n                    &#123;\n                        &quot;id&quot;: 8,\n                        &quot;name&quot;: &quot;部门5&quot;,\n                        &quot;pid&quot;: 7,\n                        &quot;children&quot;: []\n                    &#125;\n                ]\n            &#125;\n        ]\n    &#125;\n]</code></pre>\n\n<p>思路很简单，维护一个json的map，每一个id都有自己的children和本身的数据， 把属于这个id的pid项都存入children数组，因为json的map都是对象，浅拷贝下， 只要是属于这个对象的children数组都会是同一个。可以打印itemMap看看每一个id对应的数据。</p>\n","text":"前端使用树插件是一个非常常见的使用场景。树插件的数据格式在我使用过的插件都是一样的。 而这个数据格式是由后端组装好返回给前端还是前端自己组装，这个问题在前端和后端也经常拿来撕逼。 大多数情况下后端会组装好，也有一部分前端自己处理，早之前我合作过的一个后端提出了一个观点， 浏览器是...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React Hooks的学习笔记","uid":"15b860383ab68e267beb31ba2d0c1dea","slug":"React Hooks的学习笔记","date":"2021-09-15T12:50:54.000Z","updated":"2023-04-21T08:53:56.671Z","comments":true,"path":"api/articles/React Hooks的学习笔记.json","keywords":null,"cover":null,"text":"Hooks的起步使用其实Hooks主要常用的可以有以下几个： useState useEffect useContext useMemo useRef useReducer useCallback 列举的以上这几个，其实已经算是比较常用的，尤其是前两个，接下来就会介绍它们部分几个...","link":"","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"可能是你需要的 React + TypeScript 50 条规范和经验","uid":"6bbcc54b583d8f9e999b08536b9ffec3","slug":"可能是你需要的 React + TypeScript 50 条规范和经验","date":"2021-08-08T05:24:16.000Z","updated":"2023-04-21T08:46:17.973Z","comments":true,"path":"api/articles/可能是你需要的 React + TypeScript 50 条规范和经验.json","keywords":null,"cover":null,"text":"1. 注释(1) 文件顶部的注释，包括描述、作者、日期&#x2F;** * @description xxxxxx * @author chengfeng * @since 19&#x2F;05&#x2F;21 *&#x2F; 复制代码 (2) 模块的注释&#x2F;** * 拷...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[],"tags":[],"author":{"name":"Beastrong","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}