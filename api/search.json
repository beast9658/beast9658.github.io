[{"id":"b3d40160b165ebd8debc4be9e2a0af94","title":"基于 ChatGPT 和 React 搭建 JSON 转 TS 的 Web 应用","content":"\n在本文中，你将学习如何使用 ChatGPT API 构建一个将 JSON 对象转换为 Typescript interface 的 Web 应用\n为什么你需要它？许多网站为不同的场景提供 API\n简单的解决方案是发送 JSON 并返回 Typescript 中的interface\n你也可以使用 JSON-to-typescript 库来实现，但我将使用 ChatGPT 向你展示这一点，因为你知道，我喜欢魔法（AI） 🪄⭐️\n\n什么是 ChatGPT ？ChatGPT 是一种由 OpenAI 训练的 AI 语言模型，可以生成文本并以类似人类的对话方式与用户进行交互。用户可以在短短几秒钟内提交请求并获得信息或从广泛的主题中获得问题的答案。\nChatGPT 还有助于编写、调试和解释代码片段。 值得一提的是，ChatGPT 及其 API 目前免费开放给公众使用。\n因此在本文中，我们将使用它的 API 构建一个 JSON 到 Typescript 的转换器\n项目设置在这里，我们会为 Web 应用创建项目环境。 我们将在前端使用 React.js，在后端使用 Node.js\n通过运行以下代码为 Web 应用创建项目文件夹：\nmkdir json-to-typescript-cn\ncd json-to-typescript-cn\n复制代码\n\n设置 Node.js 服务端进入 server 目录并创建一个 package.json 文件\nmkdir server\n\ncd server &amp; npm init -y\n复制代码\n\n安装 Express， Nodemon ， CORS， dotenv 包\nnpm install express cors nodemon dotenv\n复制代码\n\nExpressJS 是一个快速、极简的框架，它提供了多种用于在 Node.js 中构建 Web 应用程序的功能； CORS 是一个允许不同域之间通信的 Node.js 包，而 Nodemon 是一个在检测到文件更改后自动重启服务器的 Node.js 工具。Dotenv 是一个零依赖模块，它将环境变量从 .env 文件加载到 process.env 中。\n创建一个 index.js 文件作为 Web 服务器的入口\ntouch index.js\n复制代码\n\n使用 Express.js 设置 Node.js 服务器。 当浏览器访问 http://localhost:4000/api 时，下面的代码片段会返回一个 JSON 对象\n&#x2F;&#x2F;👇🏻index.js\nconst express &#x3D; require(&quot;express&quot;);\nconst cors &#x3D; require(&quot;cors&quot;);\nconst app &#x3D; express();\nconst PORT &#x3D; 4000;\n\napp.use(express.urlencoded(&#123; extended: true &#125;));\napp.use(express.json());\napp.use(cors());\n\napp.get(&quot;&#x2F;api&quot;, (req, res) &#x3D;&gt; &#123;\n    res.json(&#123;\n        message: &quot;Hello world&quot;,\n    &#125;);\n&#125;);\n\napp.listen(PORT, () &#x3D;&gt; &#123;\n    console.log(&#96;Node.js 服务正在监听 $&#123;PORT&#125; 端口 ...&#96;);\n&#125;);\n复制代码\n\n通过将 start 命令添加到 package.json 文件中的 scripts 列表来配置 Nodemon。 下面的代码片段使用 Nodemon 启动服务器。\n&#x2F;&#x2F;在 server&#x2F;package.json 文件中\n\n&quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo &quot;Error: no test specified&quot; &amp;&amp; exit 1&quot;,\n    &quot;start&quot;: &quot;nodemon index.js&quot;\n  &#125;,\n复制代码\n\n恭喜！ 你现在可以使用以下命令启动服务器。\nnpm start\n复制代码\n\n设置 React 应用通过终端导航到根目录并创建一个新的 React.js 项目\nnpm create vite@latest\n\n✔ Project name:  client\n✔ Select a framework: › React\n✔ Select a variant: › JavaScript\n\ncd client \n\nnpm i \n复制代码\n\n在 client 目录安装  Monaco Editor for React 和  React Copy to Clipboard 库\n\nnpm install @monaco-editor&#x2F;react react-copy-to-clipboard\n复制代码\n\nMonaco Editor for React 是一个十分简单的包，用于将代码编辑器添加到 React 应用程序，而 React Copy to Clipboard 包允许我们通过单击按钮复制和粘贴内容\n从 React 应用程序中删除多余的文件，并更新 App.jsx 文件以显示 “Hello World” ，如下所示。\nfunction App() &#123;\n    return (\n        &lt;div&gt;\n            &lt;p&gt;Hello World!&lt;&#x2F;p&gt;\n        &lt;&#x2F;div&gt;\n    );\n&#125;\nexport default App;\n复制代码\n\n如下所示，更新 src/index.css 样式文件\n@import url(&quot;&lt;https:&#x2F;&#x2F;fonts.googleapis.com&#x2F;css2?family&#x3D;Space+Grotesk:wght@300;400;500;600;700&amp;display&#x3D;swap&gt;&quot;);\n\n* &#123;\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n    font-family: &quot;Space Grotesk&quot;, sans-serif;\n&#125;\n.app &#123;\n    width: 100%;\n    min-height: 100vh;\n&#125;\n.loading &#123;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 100%;\n    height: 100vh;\n&#125;\n.header__container &#123;\n    width: 100%;\n    display: flex;\n    align-items: center;\n    height: 10vh;\n    background-color: #e0f2fe;\n&#125;\n.header__right &#123;\n    display: flex;\n    align-items: center;\n&#125;\n.runBtn &#123;\n    padding: 10px 5px;\n    width: 100px;\n    margin-right: 10px;\n    cursor: pointer;\n    border: none;\n    border-radius: 3px;\n    box-shadow: 0 0 1px 1px #e0e0ea;\n    background-color: #065f46;\n    outline: none;\n    color: #fff;\n&#125;\n.header &#123;\n    border: 1px solid #ddd;\n    padding: 10px 20px;\n    border: 1px solid #e8e2e2;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    flex: 0.5;\n    height: 100%;\n&#125;\n.code__container &#123;\n    display: flex;\n    height: 95vh;\n    width: 100%;\n    align-items: flex-start;\n&#125;\n.minimap &#123;\n    display: none;\n&#125;\n.editor &#123;\n    padding: 10px 0px;\n    width: 100%;\n&#125;\n.code,\n.output &#123;\n    width: 50vw;\n&#125;\n.deleteIcon &#123;\n    height: 25px;\n    color: #cf0a0a;\n    cursor: pointer;\n&#125;\n.copyIcon &#123;\n    height: 25px;\n    color: #3e54ac;\n    cursor: pointer;\n&#125;\n复制代码\n\n构建应用用户界面在这里，我们将为 JSON 到 Typescript 转换器创建用户界面，使用户能够在屏幕左侧添加 JSON 对象，并在屏幕右侧查看 Typescript 中的结果。\n\n首先，在 client/src 文件夹中创建一个 icons 文件夹。 icons 文件夹将包含上图中的删除和复制图标\ncd client&#x2F;src\nmkdir icons\ncd icons\ntouch Copy.jsx Delete.jsx\n复制代码\n\n更新 Copy.jsx 文件以添加来自 Heroicons 的 SVG 图标\nimport React from &quot;react&quot;;\n\nconst Copy &#x3D; () &#x3D;&gt; &#123;\n    return (\n        &lt;svg\n            xmlns&#x3D;&#39;&lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&gt;&#39;\n            viewBox&#x3D;&#39;0 0 24 24&#39;\n            fill&#x3D;&#39;currentColor&#39;\n            className&#x3D;&#39;w-6 h-6 copyIcon&#39;\n        &gt;\n            &lt;path d&#x3D;&#39;M7.5 3.375c0-1.036.84-1.875 1.875-1.875h.375a3.75 3.75 0 013.75 3.75v1.875C13.5 8.161 14.34 9 15.375 9h1.875A3.75 3.75 0 0121 12.75v3.375C21 17.16 20.16 18 19.125 18h-9.75A1.875 1.875 0 017.5 16.125V3.375z&#39; &#x2F;&gt;\n            &lt;path d&#x3D;&#39;M15 5.25a5.23 5.23 0 00-1.279-3.434 9.768 9.768 0 016.963 6.963A5.23 5.23 0 0017.25 7.5h-1.875A.375.375 0 0115 7.125V5.25zM4.875 6H6v10.125A3.375 3.375 0 009.375 19.5H16.5v1.125c0 1.035-.84 1.875-1.875 1.875h-9.75A1.875 1.875 0 013 20.625V7.875C3 6.839 3.84 6 4.875 6z&#39; &#x2F;&gt;\n        &lt;&#x2F;svg&gt;\n    );\n&#125;;\n\nexport default Copy;\n复制代码\n\n将下面的代码复制到 Delete.jsx 文件中。 它为删除按钮呈现一个 SVG 图标。\nimport React from &quot;react&quot;;\n\nconst Delete &#x3D; () &#x3D;&gt; &#123;\n    return (\n        &lt;svg\n            xmlns&#x3D;&#39;&lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&gt;&#39;\n            viewBox&#x3D;&#39;0 0 24 24&#39;\n            fill&#x3D;&#39;currentColor&#39;\n            className&#x3D;&#39;w-6 h-6 deleteIcon&#39;\n        &gt;\n            &lt;path\n                fillRule&#x3D;&#39;evenodd&#39;\n                d&#x3D;&#39;M16.5 4.478v.227a48.816 48.816 0 013.878.512.75.75 0 11-.256 1.478l-.209-.035-1.005 13.07a3 3 0 01-2.991 2.77H8.084a3 3 0 01-2.991-2.77L4.087 6.66l-.209.035a.75.75 0 01-.256-1.478A48.567 48.567 0 017.5 4.705v-.227c0-1.564 1.213-2.9 2.816-2.951a52.662 52.662 0 013.369 0c1.603.051 2.815 1.387 2.815 2.951zm-6.136-1.452a51.196 51.196 0 013.273 0C14.39 3.05 15 3.684 15 4.478v.113a49.488 49.488 0 00-6 0v-.113c0-.794.609-1.428 1.364-1.452zm-.355 5.945a.75.75 0 10-1.5.058l.347 9a.75.75 0 101.499-.058l-.346-9zm5.48.058a.75.75 0 10-1.498-.058l-.347 9a.75.75 0 001.5.058l.345-9z&#39;\n                clipRule&#x3D;&#39;evenodd&#39;\n            &#x2F;&gt;\n        &lt;&#x2F;svg&gt;\n    );\n&#125;;\n\nexport default Delete;\n复制代码\n\n更新 App.jsx 文件来渲染 header 元素，如下所示\nimport React from &quot;react&quot;;\nimport Delete from &quot;.&#x2F;icons&#x2F;Delete&quot;;\nimport Copy from &quot;.&#x2F;icons&#x2F;Copy&quot;;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n    const handleSubmit &#x3D; () &#x3D;&gt; &#123;\n        console.log(&quot;运行按钮点击&quot;);\n    &#125;;\n\n    return (\n        &lt;main className&#x3D;&#39;app&#39;&gt;\n            &lt;header className&#x3D;&#39;header__container&#39;&gt;\n                &lt;div className&#x3D;&#39;header&#39;&gt;\n                    &lt;h3&gt;JSON&lt;&#x2F;h3&gt;\n                    &lt;div className&#x3D;&#39;header__right&#39;&gt;\n                        &lt;button className&#x3D;&#39;runBtn&#39; onClick&#x3D;&#123;handleSubmit&#125;&gt;\n                            运行\n                        &lt;&#x2F;button&gt;\n                        &lt;Delete &#x2F;&gt;\n                    &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n\n                &lt;div className&#x3D;&#39;header&#39;&gt;\n                    &lt;h3&gt;Typescript&lt;&#x2F;h3&gt;\n                    &lt;Copy &#x2F;&gt;\n                &lt;&#x2F;div&gt;\n            &lt;&#x2F;header&gt;\n\n            &lt;div className&#x3D;&#39;code__container&#39;&gt;&lt;&#x2F;div&gt;\n        &lt;&#x2F;main&gt;\n    );\n&#125;;\n\nexport default App;\n复制代码\n\n上面的代码片段显示了 Web 应用程序的 header 组件。 在接下来的部分中，我会说明如何将 Monaco 代码编辑器添加到 React 应用程序\n添加 Monaco 代码编辑器到 ReactMonaco Editor 是一款著名的基于 Web 技术的代码编辑器，为 VS Code 提供支持，它只需要一行集成即可支持多种编程语言。\n我们已经在上一节中安装了库。 接下来，将其导入 App.jsx 文件，如下所示\nimport React, &#123; useState &#125; from &quot;react&quot;;\nimport Delete from &quot;.&#x2F;icons&#x2F;Delete&quot;;\nimport Copy from &quot;.&#x2F;icons&#x2F;Copy&quot;;\nimport Editor from &quot;@monaco-editor&#x2F;react&quot;;\n\nconst App &#x3D; () &#x3D;&gt; &#123;\n    const [value, setValue] &#x3D; useState(&quot;&quot;);\n    const [output, setOutput] &#x3D; useState(&quot;&quot;);\n    const handleSubmit &#x3D; () &#x3D;&gt; &#123;\n        console.log(&quot;Run Button Clicked&quot;);\n    &#125;;\n\n    return (\n        &lt;main className&#x3D;&#39;app&#39;&gt;\n            &lt;header className&#x3D;&#39;header__container&#39;&gt;\n                &lt;div className&#x3D;&#39;header&#39;&gt;\n                    &lt;h3&gt;JSON&lt;&#x2F;h3&gt;\n                    &lt;div className&#x3D;&#39;header__right&#39;&gt;\n                        &lt;button className&#x3D;&#39;runBtn&#39; onClick&#x3D;&#123;handleSubmit&#125;&gt;\n                            RUN\n                        &lt;&#x2F;button&gt;\n                        &lt;Delete &#x2F;&gt;\n                    &lt;&#x2F;div&gt;\n                &lt;&#x2F;div&gt;\n\n                &lt;div&gt;\n                    &lt;h3&gt;Typescript&lt;&#x2F;h3&gt;\n                    &lt;Copy &#x2F;&gt;\n                &lt;&#x2F;div&gt;\n            &lt;&#x2F;header&gt;\n\n            &lt;div className&#x3D;&#39;code__container&#39;&gt;\n                &lt;div className&#x3D;&#39;code&#39;&gt;\n                    &lt;Editor\n                        height&#x3D;&#39;90vh&#39;\n                        className&#x3D;&#39;editor&#39;\n                        defaultLanguage&#x3D;&#39;json&#39;\n                        defaultValue&#x3D;&#39;&#123; &#125;&#39;\n                        value&#x3D;&#123;value&#125;\n                        onChange&#x3D;&#123;(value) &#x3D;&gt; setValue(value)&#125;\n                    &#x2F;&gt;\n                &lt;&#x2F;div&gt;\n                &lt;div className&#x3D;&#39;output&#39;&gt;\n                    &lt;Editor\n                        height&#x3D;&#39;90vh&#39;\n                        className&#x3D;&#39;editor&#39;\n                        defaultLanguage&#x3D;&#39;typescript&#39;\n                        options&#x3D;&#123;&#123;\n                            domReadOnly: true,\n                            readOnly: true,\n                        &#125;&#125;\n                        defaultValue&#x3D;&#39;&#39;\n                        value&#x3D;&#123;output&#125;\n                        onChange&#x3D;&#123;(value) &#x3D;&gt; setOutput(value)&#125;\n                    &#x2F;&gt;\n                &lt;&#x2F;div&gt;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;main&gt;\n    );\n&#125;;\n\nexport default App;\n复制代码\n\n从上面的代码片段中，我从 Monaco Editor 包中导入了 Editor 组件。 第一个编辑器组件接受诸如 height、value、defaultLanguage 和 onChange 事件之类的 props 第二个编辑器组件接受与第一个相同的 props，但有一个名为 options 的附加 props，由于它是只读的，因此会禁止用户编辑它的值\n如何在 Node.js 中与 ChatGPT 进行通信在本节中，你将学习如何通过 Node.js 服务器中的 API 与 ChatGPT 进行通信。 我们会将用户提供的 JSON 代码发送到 API，以将代码转换为其等效的 Typescript。 要做到这一点：\n通过运行以下代码安装 OpenAI API Node.js 库\nnpm install openai\n复制代码\n\n在 此处 登录或创建 OpenAI 帐户\n单击导航栏上的 Personal 并从菜单栏中选择 View API Keys 以创建新的密钥。\n\n\n将 API 密钥复制到计算机上安全的地方； 我们很快就会用到它\n通过将以下代码复制到 server&#x2F;index.js 文件来配置 API。\nconst &#123; Configuration, OpenAIApi &#125; &#x3D; require(&quot;openai&quot;);\nconst dotenv &#x3D; require(&#39;dotenv&#39;)\n\ndotenv.config()\nconst GPT_API_KEY &#x3D; process.env.GPT_API_KEY\n\nif (!GPT_API_KEY) &#123;\n    console.log(&quot;请配置 ChatGPT API Key&quot;)\n    return\n&#125;\n\nconst configuration &#x3D; new Configuration(&#123;\n    apiKey: GPT_API_KEY,\n&#125;);\n\nconst openai &#x3D; new OpenAIApi(configuration);\n复制代码\n\n在 server 目录下创建 .env 文件， 将 GPT_API_KEY 的值替换为你的 API 密钥。\nGPT_API_KEY&#x3D;&quot;&lt;你的 GPT API 密钥&gt;&quot;\n复制代码\n\n在服务器上创建一个 POST 路由，它将接受来自前端的 JSON 代码并生成其等效的 Typescript\n&#x2F;&#x2F; server&#x2F;index.js 文件中\n\napp.post(&quot;&#x2F;convert&quot;, (req, res) &#x3D;&gt; &#123;\n    console.log(req.body);\n&#125;);\n复制代码\n\n更新前端 App.jsx 文件中的 handleSubmit 函数，将用户输入的 JSON 对象发送到服务器上的 /convert 接口\nconst handleSubmit &#x3D; () &#x3D;&gt; &#123;\n    fetch(&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;convert&quot;, &#123;\n        method: &quot;POST&quot;,\n        body: JSON.stringify(&#123;\n            value,\n        &#125;),\n        headers: &#123;\n            &quot;Content-Type&quot;: &quot;application&#x2F;json&quot;,\n        &#125;,\n    &#125;)\n        .then((res) &#x3D;&gt; res.json())\n        .then((data) &#x3D;&gt; &#123;\n            setOutput(data.response);\n        &#125;)\n        .catch((err) &#x3D;&gt; console.error(err));\n&#125;;\n复制代码\n\n更新 /convert 接口，如下所示\napp.post(&quot;&#x2F;convert&quot;, async (req, res) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;👇🏻 解构 JSON 对象\n    let &#123; value &#125; &#x3D; req.body;\n\n    &#x2F;&#x2F;👇🏻 向 ChatGPT 提问\n    const prompt &#x3D; &#96;Convert the JSON object into Typescript interfaces \\n $&#123;value&#125; Please, I need the only the code, I don&#39;t need any explanations.&#96;;\n\n    const completion &#x3D; await openai.createChatCompletion(&#123;\n        model: &quot;gpt-3.5-turbo&quot;,\n        messages: [&#123; role: &quot;user&quot;, content: prompt &#125;],\n    &#125;);\n    res.json(&#123;\n        message: &quot;Successful&quot;,\n        response: completion.data.choices[0].message.content,\n    &#125;);\n&#125;);\n复制代码\n\n上面的代码片段从 React 应用程序接受 JSON 对象，使用 JSON 代码创建提问，并将其发送到 ChatGPT API。 包含与请求的 JSON 等效的 Typescript 的响应被发送回客户端。\n由于我们是从 Node.js 服务请求到响应，因此向应用程序添加 loading 状态用于在请求还没有返回时通知用户正在请求中。\n首先，创建一个 Loading.jsx 文件并将以下代码复制到该文件中\nconst Loading &#x3D; () &#x3D;&gt; &#123;\n    return (\n        &lt;div className&#x3D;&#39;loading&#39;&gt;\n            &lt;h2&gt;Loading...&lt;&#x2F;h2&gt;\n        &lt;&#x2F;div&gt;\n    );\n&#125;;\n\nexport default Loading;\n复制代码\n\n在 App.jsx 文件中添加 loading 状态\nconst [loading, setLoading] &#x3D; useState(false);\n复制代码\n\n更新 handleSubmit 函数以在用户单击 “运行” 按钮或请求成功时更新加载状态\nconst handleSubmit &#x3D; () &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 👇🏻 打开 loading\n      setLoading(true);\n      fetch(&quot;http:&#x2F;&#x2F;localhost:4000&#x2F;convert&quot;, &#123;\n          method: &quot;POST&quot;,\n          body: JSON.stringify(&#123;\n              value,\n          &#125;),\n          headers: &#123;\n              &quot;Content-Type&quot;: &quot;application&#x2F;json&quot;,\n          &#125;,\n      &#125;)\n          .then((res) &#x3D;&gt; res.json())\n          .then((data) &#x3D;&gt; &#123;\n              &#x2F;&#x2F; 👇🏻 关闭 loading\n              setLoading(false);\n              setOutput(data.response);\n          &#125;)\n          .catch((err) &#x3D;&gt; console.error(err));\n  &#125;;\n复制代码\n\n有条件地渲染第二个代码编辑器，如下所示\nreturn (\n        &lt;main className&#x3D;&#39;app&#39;&gt;\n           &#123;&#x2F;* -- 其他组件 --*&#x2F;&#125;\n\n            &lt;div className&#x3D;&#39;code__container&#39;&gt;\n              &lt;div className&#x3D;&#39;code&#39;&gt;\n                    &lt;Editor\n                        height&#x3D;&#39;90vh&#39;\n                        className&#x3D;&#39;editor&#39;\n                        defaultLanguage&#x3D;&#39;json&#39;\n                        defaultValue&#x3D;&#39;&#123; &#125;&#39;\n                        value&#x3D;&#123;value&#125;\n                        onChange&#x3D;&#123;(value) &#x3D;&gt; setValue(value)&#125;\n                    &#x2F;&gt;\n                &lt;&#x2F;div&gt;\n                &lt;div className&#x3D;&#39;output&#39;&gt;\n                  &#123;loading ? (\n                      &lt;Loading &#x2F;&gt;\n                  ) : (\n                      &lt;Editor\n                          height&#x3D;&#39;90vh&#39;\n                          className&#x3D;&#39;editor&#39;\n                          defaultLanguage&#x3D;&#39;typescript&#39;\n                          options&#x3D;&#123;&#123;\n                              domReadOnly: true,\n                              readOnly: true,\n                          &#125;&#125;\n                          defaultValue&#x3D;&#39;&#39;\n                          value&#x3D;&#123;output&#125;\n                          onChange&#x3D;&#123;(value) &#x3D;&gt; setOutput(value)&#125;\n                      &#x2F;&gt;\n                  )&#125;\n                &lt;&#x2F;div&gt;\n            &lt;&#x2F;div&gt;\n        &lt;&#x2F;main&gt;\n    );\n复制代码\n\n当用户提交一个 JSON 对象进行转换时，会立即显示 Loading 组件，直到请求成功，然后在代码编辑器上显示结果\n\n恭喜！🎊 应用就快要完成了。 接下来，让我们添加一些额外的功能，例如通过单击按钮复制所有 Typescript 代码以及通过单击按钮清除输入编辑器的所有内容的能力。\n复制 Typescript 代码在这里，你将学习如何使用 React-copy-to-clipboard 库在单击按钮时复制和粘贴内容\n我们已经在本教程开头安装了该包。 接下来，将其导入 App.jsx 文件，如下所示。\nimport &#123; CopyToClipboard &#125; from &quot;react-copy-to-clipboard&quot;;\n复制代码\n\n在成功复制内容后运行的 App.jsx 文件中的一个函数\nconst copyToClipBoard &#x3D; () &#x3D;&gt; alert(&#96;已复制 ✅&#96;);\n复制代码\n\n编写 CopyToClipboard 组件，如下所示\n&lt;CopyToClipboard text&#x3D;&#123;output&#125; onCopy&#x3D;&#123;copyToClipBoard&#125;&gt;\n    &lt;span&gt;\n        &lt;Copy &#x2F;&gt;\n    &lt;&#x2F;span&gt;\n&lt;&#x2F;CopyToClipboard&gt;\n复制代码\n\nCopyToClipboard 组件接收一个 text props（包含要复制的内容）和一个 onCopy 属性（一个在复制内容成功后运行的函数）\n删除用户输入如果要删除所有用户的输入，需要将 value 作为 prop 传递到 &lt;Delete/&gt; 组件中\n&lt;Delete setValue&#x3D;&#123;setValue&#125; &#x2F;&gt;\n复制代码\n\n当用户单击删除图标时更新 value 状态\nconst Delete &#x3D; (&#123; setValue &#125;) &#x3D;&gt; &#123;\n    return (\n        &lt;svg\n            xmlns&#x3D;&#39;&lt;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&gt;&#39;\n            viewBox&#x3D;&#39;0 0 24 24&#39;\n            fill&#x3D;&#39;currentColor&#39;\n            className&#x3D;&#39;w-6 h-6 deleteIcon&#39;\n            onClick&#x3D;&#123;() &#x3D;&gt; setValue(&quot;&#123; &#125;&quot;)&#125;\n        &gt;\n            &lt;path\n                fillRule&#x3D;&#39;evenodd&#39;\n                d&#x3D;&#39;M16.5 4.478v.227a48.816 48.816 0 013.878.512.75.75 0 11-.256 1.478l-.209-.035-1.005 13.07a3 3 0 01-2.991 2.77H8.084a3 3 0 01-2.991-2.77L4.087 6.66l-.209.035a.75.75 0 01-.256-1.478A48.567 48.567 0 017.5 4.705v-.227c0-1.564 1.213-2.9 2.816-2.951a52.662 52.662 0 013.369 0c1.603.051 2.815 1.387 2.815 2.951zm-6.136-1.452a51.196 51.196 0 013.273 0C14.39 3.05 15 3.684 15 4.478v.113a49.488 49.488 0 00-6 0v-.113c0-.794.609-1.428 1.364-1.452zm-.355 5.945a.75.75 0 10-1.5.058l.347 9a.75.75 0 101.499-.058l-.346-9zm5.48.058a.75.75 0 10-1.498-.058l-.347 9a.75.75 0 001.5.058l.345-9z&#39;\n                clipRule&#x3D;&#39;evenodd&#39;\n            &#x2F;&gt;\n        &lt;&#x2F;svg&gt;\n    );\n&#125;;\n\nexport default Delete;\n复制代码\n\n总结到目前为止，我们已经学习了\n\nChatGPT 是什么\n如何在 React 应用程序中添加高效的代码编辑器\n如何在 Node.js 中与 ChatGPT 通信\n如何在 React 中单击按钮时复制与删除内容\n\n本教程完成一个可以使用 ChatGPT API 构建的应用程序示例。 通过 API，你还可以创建功能强大的应用程序，在各个领域都有用，例如翻译、问答、代码解释或生成等。\n其他\n本教程的源代码可在此处获得：github.com&#x2F;zidanDirk&#x2F;j…\n本文为翻译文，原文地址\n\n","slug":"基于 ChatGPT 和 React 搭建 JSON 转 TS 的 Web 应用","date":"2023-03-23T10:06:07.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"3e28ba7063fc55b29481d21803e77406","title":"webpack 优化打包大全","content":"webpack 优化打包大全随着我们的项目项目越做越大，引入的第三方库会越来越多，打包的依赖也越来越多，每次 build 的时间越来越长，打包出来的文件会越来越大。最糟糕的是单页面应用首页白屏时间长，用户体验差。\n此时优化 webpack 打包方法不可回避。下面我们来整理一下常用的 webpack 打包优化方法。\n我们的目的\n\n减小打包后的文件大小\n首页按需引入文件，减少白屏时间\n优化 webpack 打包时间\n\n分析 webpack 打包性能瓶颈首先我们来分析一下 webpack 打包性能瓶颈，找出问题所在，然后才能对症下药。\n1、webpack-bundle-analyzer 分析体积\nvue-cli3 需要安装依赖 webpack-bundle-analyzer\n\nnpm install webpack-bundle-analyzer -D\nconst &#123; BundleAnalyzerPlugin &#125; &#x3D; require(&#39;webpack-bundle-analyzer&#39;);\nplugins:[\n  new BundleAnalyzerPlugin(),\n]\n\n\nvue-cli2 直接在命令行输入 npm run build --report, 构建完成后会在 8888 端口展示大小\n\n2、测量构建时间我们可以通过 speed-measure-webpack-plugin 测量你的 webpack 构建期间各个阶段花费的时间。\n\n步骤一：安装依赖包\n\nnpm install speed-measure-webpack-plugin --save-dev\n\n\n配置 vue.config.js\n\n&#x2F;&#x2F; 分析打包时间\nconst SpeedMeasurePlugin &#x3D; require(&#39;speed-measure-webpack-plugin&#39;)\nconst smp &#x3D; new SpeedMeasurePlugin()\n&#x2F;&#x2F; ...\nmodule.exports &#x3D; &#123;\n  configureWebpack: smp.wrap(&#123;\n    plugins: [new BundleAnalyzerPlugin()],\n  &#125;),\n&#125;\n\n找出问题所在后我们开始来总结一下优化方法。\n1、 按需加载1.1 路由组件按需加载\nconst router &#x3D; [\n  &#123;\n    path: &#39;&#x2F;index&#39;,\n    component: (resolve) &#x3D;&gt; require.ensure([], () &#x3D;&gt; resolve(require(&#39;@&#x2F;components&#x2F;index&#39;))),\n  &#125;,\n  &#123;\n    path: &#39;&#x2F;about&#39;,\n    component: (resolve) &#x3D;&gt; require.ensure([], () &#x3D;&gt; resolve(require(&#39;@&#x2F;components&#x2F;about&#39;))),\n  &#125;,\n]\n\n1.2 第三方组件和插件。按需加载需引入第三方组件\n&#x2F;&#x2F; 引入全部组件\nimport ElementUI from &#39;element-ui&#39;\nimport &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;\nVue.use(ElementUI)\n\n&#x2F;&#x2F; 按需引入组件\nimport &#123; Button &#125; from &#39;element-ui&#39;\nVue.component(Button.name, Button)\n\n1.3 对于一些插件，如果只是在个别组件中用的到，也可以不要在 main.js 里面引入，而是在组件中按需引入\n&#x2F;&#x2F; 在main.js引入\nimport Vue from vue\nimport Vuelidate from &#39;vuelidate&#39;\nVue.use(Vuelidate)\n\n&#x2F;&#x2F; 按组件按需引入\nimport &#123; Vuelidate &#125; from &#39;vuelidate&#39;\n\n1.4 去除打包后文件的预加载 prefetch&#x2F;preload\nvuecli 3 默认开启 prefetch(预先加载模块)，提前获取用户未来可能会访问的内容，在首屏会把这十几个路由文件，都一口气下载了。所以我们要关闭这个功能\n&#x2F;&#x2F;细节配置修改\nchainWebpack: (config) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 移除 prefetch 插件\n  config.plugins.delete(&#39;prefetch-index&#39;)\n  &#x2F;&#x2F; 移除 preload 插件\n  config.plugins.delete(&#39;preload-index&#39;)\n&#125;\n\n\npreload 是告诉浏览器页面必定需要的资源，浏览器一定会加载这些资源\nprefetch 是告诉浏览器页面可能需要的资源，浏览器不一定会加载这些资源\n\n当 prefetch 插件被禁用时，你可以通过 webpack 的内联注释手动选定要提前获取的代码区块：\nimport(&#x2F;* webpackPrefetch: true *&#x2F; &#39;.&#x2F;someAsyncComponent.vue&#39;)\n\n2、缩小构建目标优化 loader 配置排除 Webpack 不需要解析的模块，即使用 loader 的时候，在尽量少的模块中去使用。\n\n优化正则匹配\n通过 cacheDirectory 选项开启缓存\n通过 include、exclude 来减少被处理的文件。\n\nmodule: &#123;\n  rules: [\n    &#123;\n      test: &#x2F;.js$&#x2F;,\n      loader: &#39;babel-loader?cacheDirectory&#39;,\n      include: [resolve(&#39;src&#39;)],\n    &#125;,\n  ]\n&#125;\n\n注意：保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此 loader。\n合理使用 resolve.extensions在导入语句没带文件后缀时，Webpack 会自动带上后缀后去尝试询问文件是否存在，查询的顺序是按照我们配置 的 resolve.extensions 顺序从前到后查找，Webpack 默认支持的后缀是 js 与 json。\n配置别名 aliasalias 的意思为 别名，能把原导入路径映射成一个新的导入路径，我们可以使用 alias 配置来减少查找过程。\nresolve: &#123;\n  extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;],\n  alias: &#123;\n    &#39;vue$&#39;: &#39;vue&#x2F;dist&#x2F;vue.esm.js&#39;,\n    &#39;@&#39;: resolve(&#39;src&#39;),\n  &#125;\n&#125;,\n\n使用 module.noParse:让 webpack 忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。 因为如 jQuery 、echart 等库庞大又没有采用模块化标准，让 webpack 去解析这些文件耗时又没有意义。\nmodule:&#123;\n    noParse:&#x2F;jquery&#x2F;,&#x2F;&#x2F;不去解析jquery中的依赖库\n  ...\n&#125;,\n\n4、生产环境关闭 sourceMapsourceMap 本质上是一种映射关系，打包出来的 js 文件中的代码可以映射到代码文件的具体位置,这种映射关系会帮助我们直接找到在源代码中的错误。在生产环境，打包速度减慢，生产文件变大，所以开发环境使用 sourceMap，生产环境则关闭。\nsourceMap 的种类\n\nsource-map: 会生成 map 格式的文件，里面包含映射关系的代码\ninline-source-map: 不会生成 map 格式的文件，包含映射关系的代码会放在打包后生成的代码中\ninline-cheap-source-map: 一是将错误只定位到行，不定位到列。二是映射业务代码，不映射 loader 和第三方库等。会提升打包构建的速度。\ninline-cheap-module-source-map: module 会映射 loader 和第三方库\neval: 用 eval 的方式生成映射关系代码，效率和性能最佳。但是当代码复杂时，提示信息可能不精确。\n\n5、代码压缩UglifyJSUglifyJS 是 vue-cli 默认使用的压缩代码方式，它使用的是单线程压缩代码，打包时间较慢。\nplugins: [\n  new UglifyJsPlugin(&#123;\n    uglifyOptions: &#123;\n      compress: &#123;\n        warnings: false\n      &#125;\n    &#125;,\n    sourceMap: true,\n    parallel: true\n  &#125;)\n\nParallelUglifyPluginParallelUglifyPlugin 开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。\nplugins: [\n  new ParallelUglifyPlugin(&#123;\n    &#x2F;&#x2F;缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回，\n    &#x2F;&#x2F;cacheDir 用于配置缓存存放的目录路径。\n    cacheDir: &#39;.cache&#x2F;&#39;,\n    sourceMap: true,\n    uglifyJS: &#123;\n      output: &#123;\n        comments: false,\n      &#125;,\n      compress: &#123;\n        warnings: false,\n      &#125;,\n    &#125;,\n  &#125;),\n]\n\n打包速度和打包后的文件大小对比\n\n\n\n方法\n文件大小\n打包速度\n\n\n\n不用插件\n14.6M\n32s\n\n\nUglifyJsPlugin\n12.9M\n33s\n\n\nParallelUglifyPlugi\n7.98M\n17s\n\n\nterser-webpack-pluginWebpack4.0 默认是使用 terser-webpack-plugin 这个压缩插件，在此之前是使用 uglifyjs-webpack-plugin，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 parallel 参数，使用多进程压缩，加快压缩。\nconst TerserPlugin &#x3D; require(&#39;terser-webpack-plugin&#39;) &#x2F;&#x2F; 压缩js代码\nconst OptimizeCSSAssetsPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;) &#x2F;&#x2F; 压缩css代码\n\noptimization: &#123;\n  minimizer: [\n    new TerserPlugin(&#123;\n      parallel: 4, &#x2F;&#x2F; 开启几个进程来处理压缩，默认是 os.cpus().length - 1\n      cache: true, &#x2F;&#x2F; 是否缓存\n      sourceMap: false,\n    &#125;),\n  ]\n&#125;\n\nCSS 压缩我们可以借助 optimize-css-assets-webpack-plugin 插件来压缩 css，其默认使用的压缩引擎是 cssnano\nconst OptimizeCSSAssetsPlugin &#x3D; require(&#39;optimize-css-assets-webpack-plugin&#39;) &#x2F;&#x2F; 压缩css代码\n\noptimization: &#123;\n  minimizer: [\n    &#x2F;&#x2F; 压缩css\n    new OptimizeCSSAssetsPlugin(&#123;&#125;),\n  ]\n&#125;\n\n6、提取公共代码在用 webpack 打包的时候，对于一些不经常更新的第三方库，比如 react，lodash，vue 我们希望能和自己的代码分离开，webpack 社区有以下两种方案：\nCommonsChunkPlugin 及 splitChunks通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。\nwebpack3 使用 CommonsChunkPlugin 的实现：\nplugins: [\n  new webpack.optimize.CommonsChunkPlugin(&#123;\n    name: &#39;vendor&#39;,\n    minChunks: function (module, count) &#123;\n      console.log(module.resource, &#96;引用次数$&#123;count&#125;&#96;)\n      &#x2F;&#x2F;&quot;有正在处理文件&quot; + &quot;这个文件是 .js 后缀&quot; + &quot;这个文件是在 node_modules 中&quot;\n      return (\n        module.resource &amp;&amp;\n        &#x2F;.js$&#x2F;.test(module.resource) &amp;&amp;\n        module.resource.indexOf(path.join(__dirname, &#39;.&#x2F;node_modules&#39;)) &#x3D;&#x3D;&#x3D; 0\n      )\n    &#125;,\n  &#125;),\n  new webpack.optimize.CommonsChunkPlugin(&#123;\n    name: &#39;common&#39;,\n    chunks: &#39;initial&#39;,\n    minChunks: 2,\n  &#125;),\n]\n\nwebpack4 使用 splitChunks 的实现：\nmodule.exports &#x3D; &#123;\n  optimization: &#123;\n    splitChunks: &#123;\n      cacheGroups: &#123;\n        vendor: &#123;\n          priority: 1, &#x2F;&#x2F;添加权重\n          test: &#x2F;node_modules&#x2F;, &#x2F;&#x2F;把这个目录下符合下面几个条件的库抽离出来\n          chunks: &#39;initial&#39;, &#x2F;&#x2F;刚开始就要抽离\n          minChunks: 2, &#x2F;&#x2F;重复2次使用的时候需要抽离出来\n        &#125;,\n        common: &#123;\n          &#x2F;&#x2F;公共的模块\n          chunks: &#39;initial&#39;,\n          minChunks: 2,\n        &#125;,\n      &#125;,\n    &#125;,\n  &#125;,\n&#125;\n\nDLLPluginwebpack.DllPlugin 就是来解决这个问题的插件，使用它可以在第一次编译打包后就生成一份不变的代码供其他模块引用，这样下一次构建的时候就可以节省开发时编译打包的时间。\n1、在 build 下创建 webpack.dll.config.js\nconst path &#x3D; require(&#39;path&#39;)\nconst webpack &#x3D; require(&#39;webpack&#39;)\nmodule.exports &#x3D; &#123;\n  entry: &#123;\n    vendor: [\n      &#39;vue-router&#39;,\n      &#39;vuex&#39;,\n      &#39;vue&#x2F;dist&#x2F;vue.common.js&#39;,\n      &#39;vue&#x2F;dist&#x2F;vue.js&#39;,\n      &#39;vue-loader&#x2F;lib&#x2F;component-normalizer.js&#39;,\n      &#39;vue&#39;,\n      &#39;axios&#39;,\n      &#39;echarts&#39;,\n    ],\n  &#125;,\n  output: &#123;\n    path: path.resolve(&#39;.&#x2F;dist&#39;),\n    filename: &#39;[name].dll.js&#39;,\n    library: &#39;[name]_library&#39;,\n  &#125;,\n  plugins: [\n    new webpack.DllPlugin(&#123;\n      path: path.resolve(&#39;.&#x2F;dist&#39;, &#39;[name]-manifest.json&#39;),\n      name: &#39;[name]_library&#39;,\n    &#125;),\n    &#x2F;&#x2F; 建议加上代码压缩插件，否则dll包会比较大。\n    new webpack.optimize.UglifyJsPlugin(&#123;\n      compress: &#123;\n        warnings: false,\n      &#125;,\n    &#125;),\n  ],\n&#125;\n\n\nlibrary 的意思其实就是将 dll 文件以一个全局变量的形式导出出去，便于接下来引用。\nmainfest.json 文件是一个映射关系，它的作用就是帮助 webpack 使用我们之前打包好的 ***.dll.js 文件，而不是重新再去 node_modules 中去寻找。\n\n2、在 webpack.prod.conf.js 的 plugin 后面加入配置\nnew webpack.DllReferencePlugin(&#123;\n  manifest: require(&#39;..&#x2F;dist&#x2F;vendor-manifest.json&#39;),\n&#125;)\n\n3、package.json文件中添加快捷命令(build:dll)\n&quot;scripts&quot;: &#123;\n  &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build&#x2F;webpack.dev.conf.js&quot;,\n  &quot;start&quot;: &quot;npm run dev&quot;,\n  &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;,\n  &quot;build&quot;: &quot;node build&#x2F;build.js&quot;,\n  &quot;build:dll&quot;: &quot;webpack --config build&#x2F;webpack.dll.conf.js&quot;\n&#125;\n\n生产环境打包的时候先npm run build:dll命令会在打包目录下生成 vendor-manifest.json 文件与 vendor.dll.js 文件。然后npm run build生产其他文件。\n4、根目录下的入口 index.html 加入引用\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;vendor.dll.js&quot;&gt;&lt;&#x2F;script&gt;\n\n7、CDN 优化\n随着项目越做越大，依赖的第三方 npm 包越来越多，构建之后的文件也会越来越大。\n再加上又是单页应用，这就会导致在网速较慢或者服务器带宽有限的情况出现长时间的白屏。\n\n1、将 vue、vue-router、vuex、element-ui 和 axios 这五个库，全部改为通过 CDN 链接获取，在 index.html 里插入 相应链接。\n&lt;head&gt;\n  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;element-ui&#x2F;2.0.7&#x2F;theme-chalk&#x2F;index.css&quot; &#x2F;&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vue&#x2F;2.6.10&#x2F;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;axios&#x2F;0.19.0-beta.1&#x2F;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vuex&#x2F;3.1.0&#x2F;vuex.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vue-router&#x2F;3.0.2&#x2F;vue-router.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;element-ui&#x2F;2.6.1&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;!-- built files will be auto injected --&gt;\n&lt;&#x2F;body&gt;\n\n2、在 webpack.config.js 配置文件\nmodule.exports &#x3D; &#123;\n ···\n    externals: &#123;\n      &#39;vue&#39;: &#39;Vue&#39;,\n      &#39;vuex&#39;: &#39;Vuex&#39;,\n      &#39;vue-router&#39;: &#39;VueRouter&#39;,\n      &#39;element-ui&#39;: &#39;ELEMENT&#39;,\n      &#39;Axios&#39;:&#39;axios&#39;\n    &#125;\n  &#125;,\n\n3、卸载依赖的 npm 包\nnpm uninstall axios element-ui vue vue-router vuex\n\n4、修改 main.js 文件里之前的引包方式\n&#x2F;&#x2F; import Vue from &#39;vue&#39;\n&#x2F;&#x2F; import ElementUI from &#39;element-ui&#39;\n&#x2F;&#x2F; import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;\n&#x2F;&#x2F; import VueRouter from &#39;vue-router&#39;\n\nimport App from &#39;.&#x2F;App.vue&#39;\nimport routes from &#39;.&#x2F;router&#39;\nimport utils from &#39;.&#x2F;utils&#x2F;Utils&#39;\n\nVue.use(ELEMENT)\nVue.use(VueRouter)\n\nconst router &#x3D; new VueRouter(&#123;\n  mode: &#39;hash&#39;, &#x2F;&#x2F;路由的模式\n  routes,\n&#125;)\n\nnew Vue(&#123;\n  router,\n  el: &#39;#app&#39;,\n  render: (h) &#x3D;&gt; h(App),\n&#125;)\n\nhtml-webpack-externals-plugin这种方法每次都需要在 index.html 模板中手动引入需要的 cdn 文件，然后还要在 webpack 里配置，有点繁琐了html-webpack-externals-plugin这样的插件就应运而生了。\n&#x2F;&#x2F; webpack.config.js文件\nconst HtmlWebpackExternalsPlugin &#x3D; require(&#39;html-webpack-externals-plugin&#39;)\n\nmodule.exports &#x3D; &#123;\n  plugins: [\n    new HtmlWebpackExternalsPlugin(&#123;\n      externals: [\n        &#123;\n          &#x2F;&#x2F; 引入的模块\n          module: &#39;jquery&#39;,\n          &#x2F;&#x2F; cdn的地址\n          entry: &#39;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.4.1&#x2F;jquery.min.js&#39;,\n          &#x2F;&#x2F; 挂载到了window上的名称\n          global: &#39;jQuery&#39;,\n        &#125;,\n        &#123;\n          module: &#39;vue&#39;,\n          entry: &#39;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;vue&#x2F;2.6.10&#x2F;vue.min.js&#39;,\n          global: &#39;Vue&#39;,\n        &#125;,\n      ],\n    &#125;),\n  ],\n&#125;\n\n8、多进程解析和处理文件由于运行在 Node.js 之上的 webpack 是单线程模型的，所以 webpack 需要处理的事情需要一件一件的做，不能多件事一起做。当 webpack 需要打包大量文件时，打包时间就会比较漫长。\n以下两个方法能让 webpack 在同一时刻处理多个任务发挥多核 CPU 电脑的功能，提升构建速度。\nthread loader把这个 thread loader 放置在其他 loader 之前， 放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行。\n在 worker 池(worker pool)中运行的 loader 是受到限制的。例如：\n\n这些 loader 不能产生新的文件。\n这些 loader 不能使用定制的 loader API（也就是说，通过插件）。\n这些 loader 无法获取 webpack 的选项设置。\n\n每个 worker 都是一个单独的有 600ms 限制的 node.js 进程。同时跨进程的数据交换也会被限制。\nmodule.exports &#x3D; &#123;\n  module: &#123;\n    rules: [\n      &#123;\n        test: &#x2F;.js$&#x2F;,\n        include: path.resolve(&#39;src&#39;),\n        use: [&#39;thread-loader&#39;, &#39;expensive-loader&#39;],\n      &#125;,\n    ],\n  &#125;,\n&#125;\n\nHappyPackHappyPack 能让 webpack 把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。要注意的是 HappyPack 对 file-loader、url-loader 支持的不友好，所以不建议对该 loader 使用。\n使用方法如下：\n1、 HappyPack 插件安装\nnpm i -D happypack\n\n2、 webpack.base.conf.js 文件对 module.rules 进行配置\nmodule: &#123;\n  rules: [\n    &#123;\n      test: &#x2F;.js$&#x2F;,\n      use: [&#39;happypack&#x2F;loader?id&#x3D;babel&#39;],\n      include: [resolve(&#39;src&#39;), resolve(&#39;test&#39;)],\n      exclude: path.resolve(__dirname, &#39;node_modules&#39;),\n    &#125;,\n    &#123;\n      test: &#x2F;.vue$&#x2F;,\n      use: [&#39;happypack&#x2F;loader?id&#x3D;vue&#39;],\n    &#125;,\n  ]\n&#125;\n\n3、在生产环境 webpack.prod.conf.js 文件进行配置\nconst HappyPack &#x3D; require(&#39;happypack&#39;)\n&#x2F;&#x2F; 构造出共享进程池，在进程池中包含5个子进程\nconst HappyPackThreadPool &#x3D; HappyPack.ThreadPool(&#123; size: 5 &#125;)\nplugins: [\n  new HappyPack(&#123;\n    &#x2F;&#x2F; 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件\n    id: &#39;babel&#39;,\n    &#x2F;&#x2F; 如何处理.js文件，用法和Loader配置中一样\n    loaders: [&#39;babel-loader?cacheDirectory&#39;],\n    threadPool: HappyPackThreadPool,\n  &#125;),\n  new HappyPack(&#123;\n    id: &#39;vue&#39;, &#x2F;&#x2F; 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件\n    loaders: [\n      &#123;\n        loader: &#39;vue-loader&#39;,\n        options: vueLoaderConfig,\n      &#125;,\n    ],\n    threadPool: HappyPackThreadPool,\n  &#125;),\n]\n\n注意，当项目较小时，多线程打包反而会使打包速度变慢。\n9. 启用 gzip 压缩使用 Gzip 两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。\n1、安装依赖\nnpm i compression-webpack-plugin --save\n\n2、在 vue.congig.js 中引入并修改 webpack 配置\nconst CompressionPlugin &#x3D; require(&#39;compression-webpack-plugin&#39;)\nmodule.exports &#x3D; &#123;\n  configureWebpack: (config) &#x3D;&gt; &#123;\n    if (progress.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39;) &#123;\n      return &#123;\n        plugins: [\n          new CompressionPlugin(&#123;\n            test: &#x2F;.js$|.html$|.\\css&#x2F;, &#x2F;&#x2F;匹配文件名\n            threshold: 10240, &#x2F;&#x2F;对超过10k的数据压缩\n            deleteOriginalAssets: false, &#x2F;&#x2F;不删除源文件\n          &#125;),\n        ],\n      &#125;\n    &#125;\n  &#125;,\n&#125;\n\n复制\n\n? compression遇到的坑\nvue 使用webpack插件打包时候报错出现 Cannot read property &#39;tapPromise&#39; of undefined\ncompression-webpack-plugin 目前最新版是 7.1.0\n解决方法：\n先卸载，再装个低一点的版本\nnpm uninstall compression-webpack-plugin\n\nnpm i compression-webpack-plugin@5.0.1\n\n总结\n比较实用的方法: 按需加载，优化 loader 配置，关闭生产环境的 sourceMap，CDN 优化。\nvue-cli 已做的优化： 代码压缩，提取公共代码，再优化空间不大。\n根据项目实际需要和自身开发水平选择优化方法，必须避免因为优化产生 bug。\n\n","slug":"webpack 优化打包大全","date":"2023-03-02T05:46:21.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"423c486a461adf5a32b327715f1653d3","title":"一些VSCode上经常使用的代码格式配置","content":"使用到的插件Prettier ， vetur\n具体JSON\n&#123;\n    &quot;workbench.iconTheme&quot;: &quot;material-icon-theme&quot;,\n    &quot;vsicons.dontShowNewVersionMessage&quot;: true,\n    &quot;editor.suggestSelection&quot;: &quot;first&quot;,\n    &#x2F;&#x2F;配置未使用变量变灰\n    &quot;editor.showUnused&quot;: true,\n    &#x2F;&#x2F; 重新设定tabsize\n    &quot;editor.tabSize&quot;: 4,\n    &#x2F;&#x2F;  #让函数(名)和后面的括号之间加个空格\n    &quot;javascript.format.insertSpaceBeforeFunctionParenthesis&quot;: true,\n    &quot;vsintellicode.modify.editor.suggestSelection&quot;: &quot;automaticallyOverrodeDefaultValue&quot;,\n    &quot;files.exclude&quot;: &#123;\n        &quot;**&#x2F;.classpath&quot;: true,\n        &quot;**&#x2F;.project&quot;: true,\n        &quot;**&#x2F;.settings&quot;: true,\n        &quot;**&#x2F;.factorypath&quot;: true\n    &#125;,\n    &quot;explorer.confirmDelete&quot;: false,\n    &quot;files.associations&quot;: &#123;\n        &quot;*.cjson&quot;: &quot;jsonc&quot;,\n        &quot;*.wxss&quot;: &quot;css&quot;,\n        &quot;*.wxs&quot;: &quot;javascript&quot;\n    &#125;,\n    &quot;emmet.includeLanguages&quot;: &#123;\n        &quot;wxml&quot;: &quot;html&quot;\n    &#125;,\n    &quot;minapp-vscode.disableAutoConfig&quot;: true,\n    &quot;workbench.colorTheme&quot;: &quot;Nebula&quot;,\n    &quot;window.zoomLevel&quot;: -1,\n    &quot;terminal.integrated.rendererType&quot;: &quot;dom&quot;,\n    &quot;python.jediEnabled&quot;: false,\n    &quot;update.mode&quot;: &quot;none&quot;,\n    &quot;update.enableWindowsBackgroundUpdates&quot;: false,\n    &#x2F;&#x2F; &quot;[javascript]&quot;: &#123;\n    &#x2F;&#x2F;     &quot;editor.defaultFormatter&quot;: &quot;HookyQR.beautify&quot;\n    &#x2F;&#x2F; &#125;,\n    &quot;[vue]&quot;: &#123;\n        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,\n        &quot;editor.showUnused&quot;: true,\n    &#125;,\n    &quot;vetur.validation.template&quot;: false,\n    &quot;todo-tree.tree.showScanModeButton&quot;: false,\n    &#x2F;&#x2F; 格式化插件设置为 prettier,以下是prettier的配置\n    &quot;[html]&quot;: &#123;\n        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n    &#125;,\n    &quot;[javascript]&quot;: &#123;\n        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n    &#125;,\n    &quot;[typescript]&quot;: &#123;\n        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n    &#125;,\n    &quot;[javascriptreact]&quot;: &#123;\n        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n    &#125;,\n    &quot;[typescriptreact]&quot;: &#123;\n        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n    &#125;,\n    &quot;[less]&quot;: &#123;\n        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n    &#125;,\n    &quot;[css]&quot;: &#123;\n        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n    &#125;,\n    &quot;[json]&quot;: &#123;\n        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n    &#125;,\n    &quot;[jsonc]&quot;: &#123;\n        &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n    &#125;,\n    &quot;prettier.tabWidth&quot;: 4, &#x2F;&#x2F; 缩进字节数\n    &quot;prettier.printWidth&quot;: 100, &#x2F;&#x2F; \n    &quot;prettier.trailingComma&quot;: &quot;es5&quot;, &#x2F;&#x2F; 在对象或数组最后一个元素后面是否加逗号（在ES5中加尾逗号）\n    &quot;prettier.useTabs&quot;: false, &#x2F;&#x2F; 缩进不使用tab，使用空格\n    &quot;prettier.semi&quot;: true, &#x2F;&#x2F; 句尾添加分号\n    &quot;prettier.singleQuote&quot;: true, &#x2F;&#x2F; 不使用单引号代替双引号\n    &quot;prettier.proseWrap&quot;: &quot;preserve&quot;, &#x2F;&#x2F; 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行\n    &#x2F;&#x2F; 箭头函数参数括号 默认avoid 可选 avoid| always\n    &#x2F;&#x2F; avoid 能省略括号的时候就省略 例如x &#x3D;&gt; x\n    &#x2F;&#x2F; always 总是有括号\n    &#x2F;&#x2F; (x) &#x3D;&gt; &#123;&#125; 箭头函数参数只有一个时是否要有小括号。avoid：省略括号\n    &quot;prettier.arrowParens&quot;: &quot;avoid&quot;, \n    &quot;prettier.bracketSpacing&quot;: true, &#x2F;&#x2F; 在对象，数组括号与文字之间加空格 &quot;&#123; foo: bar &#125;&quot;\n    &#x2F;&#x2F; &quot;prettier.disableLanguages&quot;: [&quot;vue&quot;], &#x2F;&#x2F; 不格式化vue文件，vue文件的格式化单独设置\n    &quot;prettier.endOfLine&quot;: &quot;auto&quot;, &#x2F;&#x2F;不让prettier使用eslint的代码格式进行校验\n    &quot;prettier.htmlWhitespaceSensitivity&quot;: &quot;ignore&quot;,\n    &quot;prettier.ignorePath&quot;: &quot;.prettierignore&quot;, &#x2F;&#x2F; 不使用prettier格式化的文件填写在项目的.prettierignore文件中\n    &quot;prettier.jsxBracketSameLine&quot;: true, &#x2F;&#x2F; 在jsx中把&#39;&gt;&#39; 单独放一行\n    &quot;prettier.jsxSingleQuote&quot;: false, &#x2F;&#x2F; 在jsx中使用单引号代替双引号\n    &#x2F;&#x2F; &quot;prettier.parser&quot;: &quot;babylon&quot;, &#x2F;&#x2F; 格式化的解析器，默认是babylon\n    &quot;prettier.requireConfig&quot;: false, &#x2F;&#x2F; 不让prettier使用tslint的代码格式进行校验\n&#125;","slug":"一些VSCode上经常使用的代码格式配置","date":"2023-02-25T08:30:49.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"570b4b67776f5ca65289af79d788c1db","title":"Vue3 + ts 使用总结","content":"\n阅读vue的英文官网Vue的中文官网质量比起Vue的英文官网，你会发现质量有点差距，不过这种情况很容易理解，因为Vue是服务于全球的开源项目之一。\n因此，作为程序员，学好英语是提高生产力的重要因素。\n对于开发者来说，掌握英语是很有必要的，因为它是全球通用的编程语言之一。在学习和掌握新技术、阅读文档、与其他程序员交流和协作时，能够流利地使用英语将会使工作更加高效和便捷。\n总之，学好英语是程序员必备的技能之一，它将为我们的职业发展和成长带来重要的帮助和机会。\n所以程序员的第一生产力还是英语，重要的话说三遍，英语，英语，还是英语！\n另外不管学什么都要去获取第一手资料，不要看别人啃剩下的东西，直接去看英文官网\nvite初始化项目\npnpm create vite\n\n\n\n选择vue，再选择typescript\n启动项目\n\n  cd test1\n  pnpm install\n  pnpm run dev\n复制代码\n\n这里选择pnpm，pnpm相对npm和yarn做了一些改进，感兴趣的可以去搜下，切换的心智成本也不高。\nvscode的vue代码片段根据自己的使用习惯，设置vscode的vue代码片段，推荐使用snippet-generator.app\n&quot;vue3模版&quot;: &#123;\n\n&quot;prefix&quot;: &quot;vue3&quot;,\n\n&quot;body&quot;: [\n\n   &quot;&lt;template&gt;&quot;,\n\n       &quot; &lt;div class&#x3D;&#39;$&#123;1:box&#125;&#39;&gt;&lt;&#x2F;div&gt;&quot;,\n\n   &quot;&lt;&#x2F;template&gt;&quot;,\n\n   &quot; &quot;,\n\n   &quot;&lt;script setup lang&#x3D;&#39;ts&#39;&gt;&quot;,\n\n   &quot; import &#123;ref,reactive&#125; from &quot;vue&quot;;&quot;,\n\n   &quot; $&#123;3&#125;&quot;,\n\n   &quot;&lt;&#x2F;script&gt;&quot;,\n\n   &quot; &quot;,\n\n   &quot;&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&quot;,\n\n   &quot; .$&#123;2:box&#125; &#123;&quot;,\n\n   &quot; &#125;&quot;,\n\n   &quot;&lt;&#x2F;style&gt;&quot;\n\n],\n\n&quot;description&quot;: &quot;vue3模版&quot;\n\n&#125;\n复制代码\n\n另外vscode的不仅可以设置vue的代码片段，理论上你在vscode上写的任何代码，都可以设置成代码片段，方便自己以后使用。\n这个自己根据自己的个人习惯，自己挖掘。\n另外因为使用vscode开发vue的typescript项目，vscode还需要安装对应的插件，比如TypeScript Vue Plugin\n\n这里随着chatGpt的大火，你会发现你写代码的方式会慢慢改变，现在一些有一些尝试，比如Github Compilot\n\nGithub Compilot 可以根据你写的代码，自动学习，然后当你写其它代码的时候，会自动给出你提示，如果你去试用，你会发现太牛逼了😄。\n另外在工作中，一些重复的工作，尽量想着如何去优化，去节省自己的时间，比如一些模版代码的编写，一些增删改查的工作，能用工具就用工具。\n比如如果你使用umi，你会发现很多重复的工作其实都给你简化成了一个命令，比如创建页面，比如初始化prettier等。\n总之就是能用工具处理的，就用工具处理，如果自己觉得做了，都不会提升自己，就想办法自动化去处理。\nVue组件引入当使用setup的时候，组件直接引入就可以了，不需要再自己手动注册.\n下面就是直接把HelloWorld这个组件在App组件里边引入，直接使用就可以了，不需要再像以前那样注册。\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\nimport HelloWorld from &quot;.&#x2F;components&#x2F;HelloWorld.vue&quot;;\n&lt;&#x2F;script&gt;\n\n&lt;template&gt;\n  &lt;HelloWorld msg&#x3D;&quot;Vite + Vue&quot; &#x2F;&gt;\n&lt;&#x2F;template&gt;\n复制代码\n\n如果不使用setup，你会发现引入一个组件，还是比较麻烦的，可以对比一下代码，自己感受一下😄\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;HelloWorld msg&#x3D;&quot;Hello, Vue 3!&quot; &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script lang&#x3D;&quot;ts&quot;&gt;\nimport &#123; defineComponent &#125; from &#39;vue&#39;\nimport HelloWorld from &#39;.&#x2F;HelloWorld.vue&#39;\n\nexport default defineComponent(&#123;\n  components: &#123;\n    HelloWorld\n  &#125;\n&#125;)\n&lt;&#x2F;script&gt;\n复制代码\n\ndefineProps的使用defineProps 在有两种定义方式，你可以任意选择其中一种，但是不能两种都使用\n官方说明\nHowever, it is usually more straightforward to define props with pure types via a generic type argument:\n第一种”runtime declaration”\nconst props &#x3D; defineProps(&#123;\n  foo: &#123; type: String, required: true &#125;,\n  bar: Number,\n&#125;);\n复制代码\n\n第二种”type-based declaration”\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt; \n    interface Props &#123; \n        foo: string \n        bar?: number \n    &#125; \n    const props &#x3D; defineProps&lt;Props&gt;() \n&lt;&#x2F;script&gt;\n复制代码\n\n这两种定义方式没多大区别，可以任意选择一种使用，但是不能两种同时使用。\n同时我们有些情况下，也希望props能够有默认值，可以如下使用：\n\n&#x2F;&#x2F; 第二种带默认值props\nexport interface ChildProps &#123;\n  foo: string\n  bar?: number\n&#125;\nconst props &#x3D; withDefaults(defineProps&lt;ChildProps&gt;(), &#123;\n   foo: &quot;1qsd&quot;\n   bar?: 3\n&#125;)\n\n复制代码\n\n当然如果遇到特别复杂的对象，需要使用ts定义的时候，可以这样使用：\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\ninterface Book &#123;\n  title: string;\n  author: string;\n  year: number;\n&#125;\n\nconst props &#x3D; defineProps&lt;&#123;\n  book: Book;\n&#125;&gt;();\n&lt;&#x2F;script&gt;\n复制代码\n\n或者使用runtime那种方式\nimport type &#123; PropType &#125; from &#39;vue&#39;\n\ninterface Book &#123;\n  title: string;\n  author: string;\n  year: number;\n&#125;\n\nconst props &#x3D; defineProps(&#123;\n  book: Object as PropType&lt;Book&gt;\n&#125;)\n\n复制代码\n\ndefineEmits和defineProps获取父组件传过来值和事件\n&#x2F;&#x2F; 第一种获取事件方法\nconst emit &#x3D; defineEmits&lt;&#123;\n  (e: &#39;change&#39;, id: number): void\n  (e: &#39;update&#39;, value: string): void\n&#125;&gt;()\n\n&#x2F;&#x2F; 第二种获取事件方法\nconst emit &#x3D; defineEmits([&quot;dosth&quot;])\n\n复制代码\n\nref和reactiveref一般用于基本的数据类型，比如string，boolean\nreactive一般用于对象\n使用reactive的注意事项：\n\nreactive不能用于string，number，boolean\n\nvue官方网站说明如下： It cannot hold primitive types such as string, number or boolean\n\n不能修改reactive设置的值\n\n比如：\nlet state &#x3D; reactive(&#123; count: 0 &#125;) \n&#x2F;&#x2F; the above reference (&#123; count: 0 &#125;) is no longer being tracked (reactivity connection &#x2F;&#x2F; is lost!) \n&#x2F;&#x2F; 这里state如果重新赋值以后，vue就不能双向绑定\nstate &#x3D; reactive(&#123; count: 1 &#125;)\n复制代码\n\nref的底层实现，其实也是调用的reactive实现的，有点类似react hooks的useState和useReducer；\n使用useAttrs和useSlotsuseAttrs 可以获取父组件传过来的id和class等值。 useSlots 可以获得插槽的内容。 例子中，我们使用useAttrs获取父组件传过来的id和class，useSlots获取插槽的内容。\n父组件：\n&lt;template&gt;\n\n    &lt;div class&#x3D;&quot;father&quot;&gt;&#123;&#123; fatherRef &#125;&#125;&lt;&#x2F;div&gt;\n\n    &lt;Child :fatherRef&#x3D;&quot;fatherRef&quot; @changeVal&#x3D;&quot;changeVal&quot; class&#x3D;&quot;btn&quot; id&#x3D;&quot;111&quot;&gt;\n\n        &lt;template #test1&gt;\n\n        &lt;div&gt;1223&lt;&#x2F;div&gt;\n\n        &lt;&#x2F;template&gt;\n\n    &lt;&#x2F;Child&gt;\n\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\n\nimport &#123; ref &#125; from &quot;vue&quot;;\n\nimport Child from &quot;.&#x2F;Child.vue&quot;;\n\nconst fatherRef &#x3D; ref(&quot;1&quot;);\n\nfunction changeVal(val: string) &#123;\n\n    fatherRef.value &#x3D; val;\n\n&#125;\n\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n\n.father &#123;\n\n    margin-top: 40px;\n\n    margin-bottom: 40px;\n\n&#125;\n\n.btn &#123;\n\n    font-size: 20px;\n\n    color: red;\n\n&#125;\n\n&lt;&#x2F;style&gt;\n复制代码\n\n子组件：\n&lt;template&gt;\n\n    &lt;!-- &lt;div class&#x3D;&quot;child&quot;&gt;&#123;&#123; props.fatherRef &#125;&#125;&lt;&#x2F;div&gt; --&gt;\n\n    &lt;div v-bind&#x3D;&quot;attrs&quot;&gt;\n\n        &lt;slot name&#x3D;&quot;test1&quot;&gt;11&lt;&#x2F;slot&gt;\n\n        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;inputVal&quot; &#x2F;&gt;\n\n    &lt;&#x2F;div&gt;\n\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\n\nimport &#123; computed, useAttrs, useSlots &#125; from &quot;vue&quot;;\n\nconst props &#x3D; defineProps&lt;&#123;\n\n    fatherRef: string;\n\n&#125;&gt;();\n\nconst emits &#x3D; defineEmits([&quot;changeVal&quot;]);\n\nconst slots &#x3D; useSlots();\n\nconst attrs &#x3D; useAttrs();\n\nconsole.log(122, attrs, slots);\n\nconst inputVal &#x3D; computed(&#123;\n\n    get() &#123;\n\n        return props.fatherRef;\n\n    &#125;,\n\n    set(val: string) &#123;\n\n        emits(&quot;changeVal&quot;, val);\n\n    &#125;,\n\n&#125;);\n\n&lt;&#x2F;script&gt;\n\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n\n.child &#123;\n\n&#125;\n\n&lt;&#x2F;style&gt;\n\n复制代码\n\n使用自定义指令在setup里边自定义指令的时候，只需要遵循vNameOfDirective 这样的命名规范就可以了\n比如如下自定义focus指令，命名就是vMyFocus，使用的就是v-my-focus\n自定义指令\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\nconst vMyFocus &#x3D; &#123;\n  onMounted: (el: HTMLInputElement) &#x3D;&gt; &#123;\n    el.focus();\n    &#x2F;&#x2F; 在元素上做些操作\n  &#125;,\n&#125;;\n&lt;&#x2F;script&gt;\n&lt;template&gt;\n  &lt;input v-my-focus value&#x3D;&quot;111&quot; &#x2F;&gt;\n&lt;&#x2F;template&gt;\n\n\n复制代码\n\n使用defineExpose子组件传父组件子组件\n&lt;template&gt;\n\n    &lt;div class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;\n\n&lt;&#x2F;template&gt;\n\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\n\nimport &#123; ref, reactive &#125; from &quot;vue&quot;;\n\nfunction doSth() &#123;\n\n    console.log(333);\n\n&#125;\n\ndefineExpose(&#123; doSth &#125;);\n\n&lt;&#x2F;script&gt;\n\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n\n.child &#123;\n\n&#125;\n\n&lt;&#x2F;style&gt;\n\n复制代码\n\n父组件\n&lt;template&gt;\n\n&lt;div class&#x3D;&quot;father&quot; @click&#x3D;&quot;doSth1&quot;&gt;222&lt;&#x2F;div&gt;\n\n    &lt;Child ref&#x3D;&quot;childRef&quot;&gt;&lt;&#x2F;Child&gt;\n\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\n\nimport &#123; ref, reactive &#125; from &quot;vue&quot;;\n\nimport Child from &quot;.&#x2F;Child.vue&quot;;\n\nconst childRef &#x3D; ref();\n\nfunction doSth1() &#123;\n\n    childRef.value.doSth();\n\n&#125;\n\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n\n.father &#123;\n\n&#125;\n\n&lt;&#x2F;style&gt;\n\n复制代码\n\n父组件传子组件父组件\n&lt;template&gt;\n\n    &lt;div class&#x3D;&quot;father&quot;&gt;&lt;&#x2F;div&gt;\n\n    &lt;Child @click&#x3D;&quot;doSth&quot;&gt;&lt;&#x2F;Child&gt;\n\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\n\nimport &#123; ref, reactive &#125; from &quot;vue&quot;;\n\nimport Child from &quot;.&#x2F;Child.vue&quot;;\n\nfunction doSth() &#123;\n\n    console.log(112);\n\n&#125;\n\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n\n.father &#123;\n\n&#125;\n\n&lt;&#x2F;style&gt;\n\n复制代码\n\n子组件\n&lt;template&gt;\n\n    &lt;div class&#x3D;&quot;child&quot;&gt;2222&lt;&#x2F;div&gt;\n\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\n\nimport &#123; ref, reactive, onMounted &#125; from &quot;vue&quot;;\n\nconst emits &#x3D; defineEmits([&quot;doSth&quot;]);\n\nonMounted(() &#x3D;&gt; &#123;\n\n    emits(&quot;doSth&quot;);\n\n&#125;);\n\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n\n.child &#123;\n\n&#125;\n\n&lt;&#x2F;style&gt;\n\n复制代码\n\ntoRefs当从父组件向子组件传props的时候，必须使用toRefs或者toRef进行转一下，这是为什么呢？\n这里是因为如果不使用toRefs转一次的话，当父组件中的props改变的时候，子组件如果使用了Es6的解析，会失去响应性。\n可以看下如下例子\n父组件\n&lt;template&gt;\n\n&lt;div class&#x3D;&quot;father&quot; @click&#x3D;&quot;changeVal&quot;&gt;&#123;&#123; fatherRef &#125;&#125;&lt;&#x2F;div&gt;\n\n    &lt;Child :fatherRef&#x3D;&quot;fatherRef&quot;&gt;&lt;&#x2F;Child&gt;\n\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\n\nimport &#123; ref, reactive &#125; from &quot;vue&quot;;\n\nimport Child from &quot;.&#x2F;Child.vue&quot;;\n\nconst fatherRef &#x3D; ref(1);\n\nfunction changeVal() &#123;\n\n    fatherRef.value &#x3D; 2;\n\n&#125;\n\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n\n.father &#123;\n\n    margin-bottom: 40px;\n\n&#125;\n\n&lt;&#x2F;style&gt;\n\n复制代码\n\n子组件\n&lt;template&gt;\n\n    &lt;div class&#x3D;&quot;child&quot; @click&#x3D;&quot;changeVal&quot;&gt;&#123;&#123; fatherRef &#125;&#125;&lt;&#x2F;div&gt;\n\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\n\nimport &#123; ref, reactive, onMounted, toRefs &#125; from &quot;vue&quot;;\n\nconst props &#x3D; defineProps&lt;&#123;\n\n    fatherRef: any;\n\n&#125;&gt;();\n\nconst &#123; fatherRef &#125; &#x3D; props;\n\nfunction changeVal() &#123;\n\n    fatherRef.value &#x3D; 34;\n&#125;\n\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n\n.child &#123;\n\n&#125;\n\n&lt;&#x2F;style&gt;\n\n复制代码\n\n可以看到当父组件如果点击之后，因为使用const { fatherRef } &#x3D; props;进行解析，就失去了响应性\n所以当父组件变成2的时候，子组件还是1。\n这里有两种解决办法\n\n使用const { fatherRef } &#x3D; toRefs(props);\n在模版中中使用props.fatherRef\n\n子组件使用v-model1. 可以在子组件中使用computed，实现双向绑定父组件\n&lt;template&gt;\n\n    &lt;div class&#x3D;&quot;father&quot;&gt;&#123;&#123; fatherRef &#125;&#125;&lt;&#x2F;div&gt;\n\n    &lt;Child :fatherRef&#x3D;&quot;fatherRef&quot; @changeVal&#x3D;&quot;changeVal&quot;&gt;&lt;&#x2F;Child&gt;\n\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\n\nimport &#123; ref &#125; from &quot;vue&quot;;\n\nimport Child from &quot;.&#x2F;Child.vue&quot;;\n\nconst fatherRef &#x3D; ref(&quot;1&quot;);\n\nfunction changeVal(val: string) &#123;\n\n    fatherRef.value &#x3D; val;\n\n&#125;\n\n&lt;&#x2F;script&gt;\n\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n\n.father &#123;\n\n    margin-top: 40px;\n\n    margin-bottom: 40px;\n\n&#125;\n\n&lt;&#x2F;style&gt;\n\n复制代码\n\n子组件\n&lt;template&gt;\n\n    &lt;!-- &lt;div class&#x3D;&quot;child&quot;&gt;&#123;&#123; props.fatherRef &#125;&#125;&lt;&#x2F;div&gt; --&gt;\n\n    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;inputVal&quot; &#x2F;&gt;\n\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\n\nimport &#123; computed &#125; from &quot;vue&quot;;\n\nconst props &#x3D; defineProps&lt;&#123;\n\n    fatherRef: string;\n\n&#125;&gt;();\n\nconst emits &#x3D; defineEmits([&quot;changeVal&quot;]);\n\n\nconst inputVal &#x3D; computed(&#123;\n\n    get() &#123;\n\n        return props.fatherRef;\n\n    &#125;,\n\n    set(val: string) &#123;\n\n        emits(&quot;changeVal&quot;, val);\n\n    &#125;,\n\n&#125;);\n\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n\n.child &#123;\n\n&#125;\n\n&lt;&#x2F;style&gt;\n\n复制代码\n\n2 可以从父组件传递值和改变值的方法，然后子组件也可以使用v-model例子中父组件传递 modelValue和update:modelValue方法 父组件：\n&lt;template&gt;\n\n    &lt;Child :modelValue&#x3D;&quot;searchText&quot; @update:modelValue&#x3D;&quot;changeVal&quot;&gt; &lt;&#x2F;Child&gt;\n\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\n\nimport &#123; ref &#125; from &quot;vue&quot;;\n\nimport Child from &quot;.&#x2F;Child.vue&quot;;\n\nconst searchText &#x3D; ref(1);\n\nfunction changeVal(val: number) &#123;\n\n    searchText.value &#x3D; val;\n\n&#125;\n\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n\n.father &#123;\n\n    margin-top: 40px;\n\n    margin-bottom: 40px;\n\n&#125;\n\n.btn &#123;\n\n    font-size: 20px;\n\n    color: red;\n\n&#125;\n\n&lt;&#x2F;style&gt;\n复制代码\n\n子组件：\n&lt;template&gt;\n\n    &lt;!-- &lt;div class&#x3D;&quot;child&quot;&gt;&#123;&#123; props.fatherRef &#125;&#125;&lt;&#x2F;div&gt; --&gt;\n\n    &lt;!-- &lt;div v-bind&#x3D;&quot;attrs&quot;&gt;\n\n        &lt;slot name&#x3D;&quot;test1&quot;&gt;11&lt;&#x2F;slot&gt;\n\n        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;inputVal&quot; &#x2F;&gt;\n\n    &lt;&#x2F;div&gt; --&gt;\n\n    &lt;input v-model&#x3D;&quot;modelValue&quot; &#x2F;&gt;\n\n&lt;&#x2F;template&gt;\n\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\n\nimport &#123; computed, useAttrs, useSlots &#125; from &quot;vue&quot;;\n\nconst props &#x3D; defineProps&lt;&#123;\n\n    modelValue: number;\n\n&#125;&gt;();\n\n&#x2F;&#x2F; const emits &#x3D; defineEmits([&quot;changeVal&quot;]);\n\n&lt;&#x2F;script&gt;\n\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n\n.child &#123;\n\n&#125;\n\n&lt;&#x2F;style&gt;\n\n复制代码\n\n递归组件组件本身是可以调用组件自身的，也就是递归。 比如名为 Child.vue 的组件可以在其模板中用 &lt;Child/&gt; 引用它自己。这里需要注意的是需要设置条件语句，用来中断递归，不然递归会无限递归下去。\n父组件\n&lt;template&gt;\n  &lt;Child :modelValue&#x3D;&quot;searchText&quot; @update:modelValue&#x3D;&quot;changeVal&quot;&gt; &lt;&#x2F;Child&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\nimport &#123; ref &#125; from &quot;vue&quot;;\nimport Child from &quot;.&#x2F;Child.vue&quot;;\nconst searchText &#x3D; ref(1);\nfunction changeVal(val: number) &#123;\n  searchText.value &#x3D; val;\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.father &#123;\n  margin-top: 40px;\n  margin-bottom: 40px;\n&#125;\n.btn &#123;\n  font-size: 20px;\n  color: red;\n&#125;\n&lt;&#x2F;style&gt;\n\n复制代码\n\n子组件\n&lt;template&gt;\n  &lt;input v-model&#x3D;&quot;modelValue&quot; &#x2F;&gt;\n  &lt;Child\n    :modelValue&#x3D;&quot;test&quot;\n    @update:modelValue&#x3D;&quot;changeTest&quot;\n    v-if&#x3D;&quot;modelValue &gt; 2&quot;\n  &gt;&lt;&#x2F;Child&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\nimport &#123; computed, useAttrs, useSlots, ref &#125; from &quot;vue&quot;;\nconst props &#x3D; defineProps&lt;&#123;\n  modelValue: number;\n&#125;&gt;();\nconst test &#x3D; ref(0);\nfunction changeTest(val: number) &#123;\n  test.value &#x3D; val;\n&#125;\n\n&#x2F;&#x2F; const emits &#x3D; defineEmits([&quot;changeVal&quot;]);\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;\n.child &#123;\n  position: relative;\n&#125;\n&lt;&#x2F;style&gt;","slug":"Vue3 + ts 使用总结","date":"2023-02-22T16:24:19.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"c15a6a9dda465b3a99cae28e33ecb722","title":"vue2 与 vue3 的区别","content":"vue2 与 vue3 的区别Vue 内部根据功能可以被分为三个大的模块：**响应性 reactivite、运行时 runtime、编辑器 compiler**，以及一些小的功能点。那么要说 vue2 与 vue3 的区别，我们需要从这三个方面加小的功能点进行说起。\n首先先来说 **响应性 reactivite**：\nvue2 的响应性主要依赖 Object.defineProperty 进行实现，但是 Object.defineProperty 只能监听 指定对象的指定属性的 getter 行为和 setter 行为，那么这样在某些情况下就会出现问题。\n什么问题呢？\n比如说：我们在 data 中声明了一个对象 person ，但是在后期为 person 增加了新的属性，那么这个新的属性就会失去响应性。想要解决这个问题其实也非常的简单，可以通过 Vue.$set 方法来增加 指定对象指定属性的响应性。但是这样的一种方式，在 Vue 的自动响应性机制中是不合理。\n所以在 Vue3 中，Vue 引入了反射和代理的概念，所谓反射指的是 Reflect，所谓代理指的是 Proxy。我们可以利用 Proxy 直接代理一个普通对象，得到一个 proxy 实例 的代理对象。在 vue3 中，这个过程通过 reactive 这个方法进行实现。\n但是 proxy 只能实现代理复杂数据类型，所以 vue 额外提供了 ref 方法，用来处理简单数据类型的响应性。ref 本质上并没有进行数据的监听，而是构建了一个 RefImpl 的类，通过 set 和 get 标记了 value 函数，以此来进行的实现。所以 ref 必须要通过 .value 进行触发，之所以要这么做本质是调用 value 方法。\n接下来是**运行时 runtime**：\n所谓的运行时，大多数时候指的是 renderer 渲染器，渲染器本质上是一个对象，内部主要三个方法 render、hydrate、createApp ，其中 render 主要处理渲染逻辑，hydrate 主要处理服务端渲染逻辑，而 createApp 就是创建 vue 实例的方法。\n这里咱们主要来说 render 渲染函数，vue3 中为了保证宿主环境与渲染逻辑的分离，把所有与宿主环境相关的逻辑进行了抽离，通过接口的形式进行传递。这样做的目的其实是为了解绑宿主环境与渲染逻辑，以保证 vue 在非浏览器端的宿主环境下可以正常渲染。\n再往下是 **编辑器 compiler**：\nvue 中的 compiler 其实是一个 DSL（特定领域下专用语言编辑器） ，其目的是为了把 template 模板 编译成 render 函数。 逻辑主要是分成了三大步： parse、transform 和 generate。其中 parse 的作用是为了把 template 转化为 AST（抽象语法树），transform 可以把 AST（抽象语法树） 转化为 JavaScript AST，最后由 generate 把 JavaScript AST 通过转化为 render 函数。转化的过程中会涉及到一些稍微复杂的概念，比如 有限自动状态机 这个就不再这里展开说了。\n除此之外，还有一些其他的变化。比如 vue3 新增的 composition API。 composition API 在 vue3.0 和 vue3.2 中会有一些不同的呈现，比如说：最初的 composition API 以 setup 函数作为入口函数， setup 函数必须返回两种类型的值：第一是对象，第二是函数。\n当 setup 函数返回对象时，对象中的数据或方法可以在 template 中被使用。当 setup 函数返回函数时，函数会被作为 render 函数。\n但是这种 setup 函数的形式并不好，因为所有的逻辑都集中在 setup 函数中，很容易出现一个巨大的 setup 函数，我们把它叫做巨石（屎山）函数。所以 vue 3.2 的时候，新增了一个 script setup 的语法糖，尝试解决这个问题。目前来看 script setup 的呈现还是非常不错的。\n除此之外还有一些小的变化，比如 Fragment、Teleport、Suspense 等等，这些就不去说了…\n","slug":"vue2 与 vue3 的区别","date":"2023-01-09T07:24:48.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"18ec0d2dffa6580aa03409c2b752705b","title":"几种重复请求数据的问题及解决方法","content":"\n最近封控在家，回顾问题解解闷。今天来讲讲重复请求的问题。\n问题汇总\n表单提交按钮重复点击\n查询按钮重复点击\n可能多个因素同时触发某个请求\n页面自动刷新数据（如：数据大屏）\n同一页面内有多个tab用同一个table，tab1下的数据量大，tab2下的数据量极小，tab1数据未获取到的时候切换到tab2，可能渲染的是tab1的数据\n\n解决的是什么问题解决重复请求的问题本质上是解决这三类问题：\n\n用户体验\n页面性能\n数据正确且安全，关于这个问题，前端是无法完全杜绝的，必须后端进行兜底，这里不是今天的重点。\n\n分类分析提交按钮重复点击这是最常见的问题，重复提交会造成多条数据入库。点击提交给个loading提示过渡，期间按钮不可再次触发就可以。\n查询按钮重复点击如果查询按钮点一下就设置loading，体验其实并不好，但是一直请求，数据不断重新渲染，又会影响性能。 我第一反应是用防抖，如果误触只请求最后一次就好了。\n&#x2F;&#x2F; 防抖\n&#x2F;&#x2F; fn: 回调函数\n&#x2F;&#x2F; delay: 延时时间\nexport const debounce &#x3D; (fn, delay &#x3D; 1000) &#x3D;&gt; &#123;\n  let timer &#x3D; null;\n  return function() &#123;\n    if (timer !&#x3D;&#x3D; null) &#123;\n      clearTimeout(timer);\n    &#125;\n    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n      fn.apply(this, arguments);\n    &#125;, 1000);\n  &#125;;\n&#125;;\n复制代码\n\n直到我疯狂点击搜索引擎的搜索按钮，我发现人家用的不是防抖，我陷入沉思，如果我的用户像我一样，那防抖就会让他无法快速看到数据，所以我又觉得应该用节流。\n&#x2F;&#x2F; 节流\nexport const throttle &#x3D; (fn, delay &#x3D; 1000) &#x3D;&gt; &#123;\n  let old &#x3D; 0;\n  return function() &#123;\n    let now &#x3D; new Date().valueOf();\n    if (now - old &gt; delay) &#123;\n      fn.apply(this, arguments);\n      old &#x3D; now;\n    &#125;\n  &#125;;\n&#125;;\n\n复制代码\n\naxios取消重复请求当多个因素瞬时一起触发某个请求，你会希望只处理最后一次请求，那么可以从axios入手，cancel掉多余的请求\n&#x2F;&#x2F; axios.js\n\n……\n\nconst CANCEL_RETRANSMIT &#x3D; []; &#x2F;&#x2F; 这里存储需要处理重复请求的url\nlet s &#x3D; 1; &#x2F;&#x2F; 单位秒\nlet pending &#x3D; []; &#x2F;&#x2F; 声明一个数组用于存储每个请求的取消函数和axios标识\nlet cancelToken &#x3D; Axios.CancelToken;\nlet removePending &#x3D; config &#x3D;&gt; &#123;\n  pending &#x3D; pending.filter(i &#x3D;&gt; new Date().getTime() - i.t &lt; s * 1000); &#x2F;&#x2F; 保留s秒内发的请求\n  if (\n    pending.length &gt; 1 &amp;&amp;\n    pending[pending.length - 2].u &#x3D;&#x3D;&#x3D; config.url &amp;&amp;\n    pending[pending.length - 1].t - pending[pending.length - 2].t &lt; s * 1000\n  ) &#123;\n    pending[pending.length - 2].f(); &#x2F;&#x2F;执行取消操作\n    pending.splice(pending.length - 2, 1);\n  &#125;\n&#125;;\n\n……\n\n&#x2F;&#x2F; 请求拦截器内\naxios.interceptors.request.use(\n  async config &#x3D;&gt; &#123;\n    ……\n    const url &#x3D; config.url || &#39;&#39;;\n    &#x2F;&#x2F; 删除重复请求\n    if (CANCEL_RETRANSMIT.includes(config.url)) &#123;\n      config.cancelToken &#x3D; new cancelToken(c &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 用请求地址&amp;请求参数拼接的字符串\n        pending.push(&#123;\n          u: url,\n          t: new Date().getTime(),\n          f: c,\n        &#125;);\n      &#125;);\n      await removePending(config);\n    &#125;\n\n    return config;\n  &#125;,\n  ……\n);\n\n复制代码\n\n这种方式只是让前端减少处理重复请求，但是后端依然会收到多个请求。\n页面自动刷新数据有些页面需要定时自动重复请求数据更新页面，比如：数据大屏、带状态信息的数据表格。 大多数前端仔看到定时任务第一反应就是setInterval。\nsetInterval(function()&#123;\n    &#x2F;&#x2F;要执行的代码                    \n&#125;,200);\n\n复制代码\n\n我们先复习一下setInterval的特点：\n\n会阻塞\n无论页面显示隐藏，都会执行\n退出需要清除定时器\n间隔时间可以任意定义\n浏览器兼容性极好\n\n那么有没有一种东西能解决setInterval的缺点？这个就是requestAnimationFrame，简称rAF。 rAF的特点：\n\n按浏览器帧执行，低阻塞。如果是动画则流畅度会更高。\n仅当页面显示时会执行，页面在后台不执行，这样可以减小CPU占用\n退出需要清除定时器\n间隔时间是每一帧的间隔时间，可以封装方法任意定义\n浏览器兼容比setInterval差点用rAF封装出来的定时器如下\n\nexport const rafInterval &#x3D; (fn, delay &#x3D; 3000) &#x3D;&gt; &#123;\n  let start &#x3D; 0;\n  function fun() &#123;\n    const timestamp &#x3D; new Date().valueOf();\n    if (start &#x3D;&#x3D;&#x3D; undefined) start &#x3D; timestamp;\n    if (timestamp - start &gt; delay) &#123;\n      start &#x3D; timestamp;\n      fn.apply(this, arguments);\n    &#125;\n    requestAnimationFrame(fun);\n  &#125;\n  return function() &#123;\n    requestAnimationFrame(fun);\n  &#125;;\n&#125;;\n\n复制代码\n\n前面提过requestAnimationFrame兼容性不够好，那么就加个判断\nvar requestAnimFrame &#x3D; (function() &#123;\n  return (\n    window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    function(callback) &#123;\n      window.setTimeout(callback, 1000 &#x2F; 60);\n    &#125;\n  );\n&#125;)();\n\nexport const rafInterval &#x3D; (fn, delay &#x3D; 3000) &#x3D;&gt; &#123;\n    ……\n&#125;;\n复制代码\n\n同页面根据条件展示不同表格数据实际场景：同一页面内有多个tab用同一个table组件，tab1下的数据量大，tab2下的数据量极小，tab1数据未获取到的时候切换到tab2，可能tab1的数据比tab2还晚返回，table渲染的就会是tab1的数据\n解决思路：\n\n如果是同一个url发出的请求，用axios的cancel方法，把存在的pending状态的请求cancel\n如果是不同url发出的请求，传个标记给后端，后端返回数据带给前端\n\n","slug":"几种重复请求数据的问题及解决方法","date":"2022-11-20T08:41:18.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"de3904e4fffd4a0033c6fe3d6902ae56","title":"webpack5三种mode默认配置对比","content":"虽然webpack的文档中已经给出了三种模式默认的配置项的配置，但是我还是好奇除了这些列出的配置，是否还有其他的配置之间的差异呢？\n导出三种模式的配置对象webpack的版本是V5.36.1，获取默认配置的源码路径为webpack/lib/WebpackOptionsDefaulter.js ，该文件源码如下：\nconst &#123; applyWebpackOptionsDefaults &#125; &#x3D; require(&quot;.&#x2F;config&#x2F;defaults&quot;);\nconst &#123; getNormalizedWebpackOptions &#125; &#x3D; require(&quot;.&#x2F;config&#x2F;normalization&quot;);\n\nclass WebpackOptionsDefaulter &#123;\n\tprocess(options) &#123;\n\t\toptions &#x3D; getNormalizedWebpackOptions(options);\n\t\tapplyWebpackOptionsDefaults(options);\n\t\treturn options;\n\t&#125;\n&#125;\n\nmodule.exports &#x3D; WebpackOptionsDefaulter;\n复制代码\n\n我们的目的是获取每个模式的options，所以暂且不需要管这里引入的两个模块的具体代码，通过这段代码得知，只需要通过WebpackOptionsDefaulter 的实例方法process，即可获取每种模式的具体配置，获取默认配置代码如下：\n&#x2F;&#x2F; getWebpackConfig.js\nconst fs &#x3D; require(&#39;fs&#39;);\nconst &#123;stringify&#125; &#x3D; require(&#39;javascript-stringify&#39;);\nconst WebpackDefaulterClass &#x3D; require(&#39;webpack&#x2F;lib&#x2F;WebpackOptionsDefaulter&#39;);\nconst webpackDefaulter &#x3D; new WebpackDefaulterClass();\n\n[&#39;none&#39;,&#39;development&#39;,&#39;production&#39;].forEach(mode &#x3D;&gt; generateOptions(mode));\n\nfunction generateOptions(mode) &#123;\n  const options &#x3D; webpackDefaulter.process(&#123;mode&#125;);\n  fs.writeFileSync(&#96;.&#x2F;webpack.$&#123;mode&#125;.config.js&#96;, &#39;module.exports &#x3D; &#39; + stringify(options));\n&#125;\n复制代码\n\n在命令行执行node getWebpackConfig 之后，就把相对应的配置输出到对应的文件中，再对文件进行代码格式化，准备工作就好了。\n三种模式的配置差异1、cache\nproduction模式为false\n\ndevelopment模式为\n&#123;\n  cache: &#123;\n    type: &#39;memory&#39;,\n    maxGenerations: Infinity\n  &#125;\n&#125;\n复制代码\n\nnone模式为false\n\n\ncache配置的作用是换成已经处理过的module和chunk，以达到加速构建的目的。production模式一般为全新构建打包，所以默认为不使用缓存，但是在开发过程中，构建速度直接影响到开发效率，所以development模式下，webpack会使用缓存。\ntype支持配置为filesystem和memory，即文件系统和内存缓存，开发模式下追求快速，所以配置为memory。\nmaxGenerations是5.30.0+版本才有的配置，该配置设置没有被使用的内存缓存的寿命，配置值类型为number，设置为Infinity表示一直保留。\n2、devtool\nproduction模式为false\n\nnone模式为false\n\ndevelopment中的配置为：\n&#123;\n  devtool: &#39;eval&#39;\n&#125;\n复制代码\n\n该配置指定source map的格式，false则不生成source map，development模式默认使用eval格式，eval格式的特点每个模块都使用 eval() 执行，并且都有 //@ sourceURL。此选项会非常快地构建。主要缺点是，由于会映射到转换后的代码，而不是映射到原始代码（没有从 loader 中获取 source map），所以不能正确的显示行数。\n如果构建速度要求没那么高时，可以使用eval-cheap-module-source-map替代eval，eval-cheap-module-source-map会牺牲一定的构建速度，但是可以提供原始代码行数的映射。\n3、module.unsafeCache\nproduction模式为false\n\nnone模式为false\n\ndevelopment的配置为：\n&#x2F;&#x2F; const NODE_MODULES_REGEXP &#x3D; &#x2F;[\\&#x2F;]node_modules[\\&#x2F;]&#x2F;i;\n&#123;\n  unsafeCache: module &#x3D;&gt; &#123;\n    const name &#x3D; module.nameForCondition();\n    return name &amp;&amp; NODE_MODULES_REGEXP.test(name);\n  &#125;,\n&#125;\n复制代码\n\n该配置表示是否缓存模块请求的解析，development的unsafeCache配置表示，如果通过模块的nameForCondition方法得到的模块路径存在，且是node_modules中的模块，则缓存。\n4、optimization.splitChunks.hidePathInfo该配置表示由于optimization.splitChunks.maxSize配置而创建的提取的文件名称隐藏路径信息，表现为派生名称是模块名称还是哈希值。\n\nproduction模式为true\ndevelopment模式为false\nnone模式为false\n\n当 chunk 已经有一个名称时，每个部分将获得一个从该名称派生的新名称。 根据 optimization.splitChunks.hidePathInfo 的值，它将添加一个从第一个模块名称或其哈希值派生的密钥。\n5、optimization.splitChunks.minRemainingSize\nproduction模式为undefined（此时使用的是splitChunks.minSize的值）\ndevelopment模式为0\nnone模式为undefined（此时使用的是splitChunks.minSize的值）\n\nwebpack 5中引入了splitChunks.minRemainingSize选项，通过确保拆分后剩余的最小块大小大于限制来避免大小为零的模块。开发模式下默认为0。在其他情况下，splitChunks.minRemainingSize的默认值为splitChunks.minSize的值，因此除极少数需要过度干预的情况外，无需手动指定它。\n6、optimization.splitChunks.enforceSizeThreshold\nproduction模式为5000\ndevelopment模式为3000\nnone模式为3000\n\n7、optimization.emitOnErrors\nprodution模式为false\ndevelopment模式为true\nnone模式为true\n\n该配置表示在编译的过程中遇到错误时，是否依然生成资源，所以当生产构建过程中出现错误会终止编译，而开发时不会终止，但是会在代码运行时出现报错。\n8、optimization.flagIncludedChunks\nprodution模式为true\ndevelopment模式为false\nnone模式为false\n\n设置为true时，webpack标记作为其他chunk子集的chunk，在已经加载过较大的chunk时不必加载子集chunk。\n9、optimization.moduleIds和optimization.chunkIds两个配置分别为模块id和chunk id选择某种名称算法，这个配置三种模式都不相同。\n\nproduction模式下都为deterministic，模块名称被散列为较小的数值。\ndevelopment模式下都为named，模块名称可读性强，方便调试。\nnone模式下都为natural，模块名称是按使用顺序的数字ID。\n\n10、optimization.sideEffects\nproduction模式为true\ndevelopment模式为flag\nnone模式为flag\n\n告知 webpack 去辨识 package.json 中的 副作用 标记或规则，以跳过那些当导出不被使用且被标记不包含副作用的模块。\n11、optimization.usedExports\nproduction模式为true\ndevelopment模式为false\nnone模式为false\n\n它告诉Webpack去决定每一个模块所用到的导出。有了它，Webpack会在打包产出里添加额外的像是&#x2F;* unused harmony export *&#x2F;之类的注释，在后续的压缩步骤中可用到。\n12、optimization.innerGraph告知 webpack 是否对未使用的导出内容，实施内部图形分析。\n\nproduction模式为true\ndevelopment模式为false\nnone模式为false\n\n13、optimization.mangleExports该配置为是否允许控制导出处理。\n\nproduction模式为true，等价于deterministic，简写形式 - 通常两个字符 — 在添加或移除 export 时不会改变。适用于长效缓存。\ndevelopment模式为false，保留原名，有利于阅读和调试。\nnone模式为false，保留原名，有利于阅读和调试。\n\n14、optimization.concatenateModules该配置告知webpack是否根据模块图将模块安全地合并为一个模块。\n\nproduction模式为true\ndevelopment模式为false\nnone模式为false\n\n15、optimization.realContentHash资源生成并生成正确的资源内容hash后，再添加一个额外的hash。\n\nproduction模式为true\ndevelopment模式为false\nnone模式为false\n\n16、optimization.minimize告诉 webpack使用 TerserPlugin 或者在 optimization.minimizer选项中配置的插件压缩bundle。\n\nproduction模式下为true\ndevelopment模式为false\nnone模式为false\n\n三种模式下的optimization.minimizer配置都是一样的：\nminimizer: [&#123;\n  apply: compiler &#x3D;&gt; &#123;\n    &#x2F;&#x2F; Lazy load the Terser plugin\n    const TerserPlugin &#x3D; require(&quot;terser-webpack-plugin&quot;);\n    new TerserPlugin(&#123;\n      terserOptions: &#123;\n        compress: &#123;\n          passes: 2\n        &#125;\n      &#125;\n    &#125;).apply(compiler);\n  &#125;\n&#125;],\n复制代码\n\n17、optimization.nodeEnv该配置会将值赋值给process.env.NODE_ENV，如果是false，则不赋值。\n\nproduction模式为production\ndevelopment模式为development\nnone模式为false\n\n18、performance通过该配置可以设置当构建资源超出限制时如何提示。\n\nproduction模式配置为：\nperformance: &#123;\n  maxAssetSize: 250000, &#x2F;&#x2F; 最大资源大小250KB\n  maxEntrypointSize: 250000, &#x2F;&#x2F; 最大入口资源大小250KB\n  hints: &#39;warning&#39; &#x2F;&#x2F; 超出限制时只给出警告\n&#125;,\n复制代码\n\ndevelopment模式为false\n\nnone模式为false\n\n\n三种模式目标从以上分析的差异可以再次验证三种模式的目标的差异。\nproduction模式是为了生产环境资源访问的效率。\ndevelopment模式是为了开发环境的调试效率。\nnone模式一般都不会用上，它基本上和development模式相同，在缓存和开发调试上又有些不足，所以基本上不选择none模式。\n三种模式的配置对象mode: &#39;none&#39;module.exports &#x3D; &#123;\n  amd: undefined,\n  bail: undefined,\n  cache: false,\n  context: &#39;&#x2F;Users&#x2F;test&#39;,\n  dependencies: undefined,\n  devServer: undefined,\n  devtool: false,\n  entry: &#123;\n    main: &#123;\n      &#39;import&#39;: [&#39;.&#x2F;src&#39;]\n    &#125;\n  &#125;,\n  experiments: &#123;\n    topLevelAwait: false,\n    syncWebAssembly: false,\n    asyncWebAssembly: false,\n    outputModule: false\n  &#125;,\n  externals: undefined,\n  externalsPresets: &#123;\n    web: true,\n    node: false,\n    nwjs: false,\n    electron: false,\n    electronMain: false,\n    electronPreload: false,\n    electronRenderer: false\n  &#125;,\n  externalsType: &#39;var&#39;,\n  ignoreWarnings: undefined,\n  infrastructureLogging: &#123;&#125;,\n  loader: &#123;\n    target: &#39;web&#39;\n  &#125;,\n  mode: &#39;none&#39;,\n  module: &#123;\n    noParse: undefined,\n    unsafeCache: false,\n    parser: &#123;\n      javascript: &#123;\n        unknownContextRequest: &#39;.&#39;,\n        unknownContextRegExp: false,\n        unknownContextRecursive: true,\n        unknownContextCritical: true,\n        exprContextRequest: &#39;.&#39;,\n        exprContextRegExp: false,\n        exprContextRecursive: true,\n        exprContextCritical: true,\n        wrappedContextRegExp: &#x2F;.*&#x2F;,\n        wrappedContextRecursive: true,\n        wrappedContextCritical: false,\n        strictExportPresence: false,\n        strictThisContextOnImports: false\n      &#125;,\n      asset: &#123;\n        dataUrlCondition: &#123;\n          maxSize: 8096\n        &#125;\n      &#125;\n    &#125;,\n    generator: &#123;&#125;,\n    defaultRules: [&#123;\n      mimetype: &#39;application&#x2F;node&#39;,\n      type: &#39;javascript&#x2F;auto&#39;\n    &#125;, &#123;\n      test: &#x2F;.json$&#x2F;i,\n      type: &#39;json&#39;\n    &#125;, &#123;\n      mimetype: &#39;application&#x2F;json&#39;,\n      type: &#39;json&#39;\n    &#125;, &#123;\n      test: &#x2F;.mjs$&#x2F;i,\n      type: &#39;javascript&#x2F;esm&#39;,\n      resolve: &#123;\n        byDependency: &#123;\n          esm: &#123;\n            fullySpecified: true\n          &#125;\n        &#125;\n      &#125;\n    &#125;, &#123;\n      test: &#x2F;.js$&#x2F;i,\n      descriptionData: &#123;\n        type: &#39;module&#39;\n      &#125;,\n      type: &#39;javascript&#x2F;esm&#39;,\n      resolve: &#123;\n        byDependency: &#123;\n          esm: &#123;\n            fullySpecified: true\n          &#125;\n        &#125;\n      &#125;\n    &#125;, &#123;\n      test: &#x2F;.cjs$&#x2F;i,\n      type: &#39;javascript&#x2F;dynamic&#39;\n    &#125;, &#123;\n      test: &#x2F;.js$&#x2F;i,\n      descriptionData: &#123;\n        type: &#39;commonjs&#39;\n      &#125;,\n      type: &#39;javascript&#x2F;dynamic&#39;\n    &#125;, &#123;\n      mimetype: &#123;\n        or: [&#39;text&#x2F;javascript&#39;, &#39;application&#x2F;javascript&#39;]\n      &#125;,\n      type: &#39;javascript&#x2F;esm&#39;,\n      resolve: &#123;\n        byDependency: &#123;\n          esm: &#123;\n            fullySpecified: true\n          &#125;\n        &#125;\n      &#125;\n    &#125;, &#123;\n      dependency: &#39;url&#39;,\n      type: &#39;asset&#x2F;resource&#39;\n    &#125;],\n    rules: []\n  &#125;,\n  name: undefined,\n  node: &#123;\n    global: true,\n    __filename: &#39;mock&#39;,\n    __dirname: &#39;mock&#39;\n  &#125;,\n  optimization: &#123;\n    runtimeChunk: false,\n    splitChunks: &#123;\n      defaultSizeTypes: [&#39;javascript&#39;, &#39;unknown&#39;],\n      cacheGroups: &#123;\n        &#39;default&#39;: &#123;\n          idHint: &#39;&#39;,\n          reuseExistingChunk: true,\n          minChunks: 2,\n          priority: -20\n        &#125;,\n        defaultVendors: &#123;\n          idHint: &#39;vendors&#39;,\n          reuseExistingChunk: true,\n          test: &#x2F;[\\&#x2F;]node_modules[\\&#x2F;]&#x2F;i,\n          priority: -10\n        &#125;\n      &#125;,\n      hidePathInfo: false,\n      chunks: &#39;async&#39;,\n      usedExports: false,\n      minChunks: 1,\n      minSize: 10000,\n      minRemainingSize: undefined,\n      enforceSizeThreshold: 30000,\n      maxAsyncRequests: Infinity,\n      maxInitialRequests: Infinity,\n      automaticNameDelimiter: &#39;-&#39;\n    &#125;,\n    emitOnErrors: true,\n    removeAvailableModules: false,\n    removeEmptyChunks: true,\n    mergeDuplicateChunks: true,\n    flagIncludedChunks: false,\n    moduleIds: &#39;natural&#39;,\n    chunkIds: &#39;natural&#39;,\n    sideEffects: &#39;flag&#39;,\n    providedExports: true,\n    usedExports: false,\n    innerGraph: false,\n    mangleExports: false,\n    concatenateModules: false,\n    checkWasmTypes: false,\n    mangleWasmImports: false,\n    portableRecords: false,\n    realContentHash: false,\n    minimize: false,\n    minimizer: [&#123;\n      apply: compiler &#x3D;&gt; &#123;\n        &#x2F;&#x2F; Lazy load the Terser plugin\n        const TerserPlugin &#x3D; require(&quot;terser-webpack-plugin&quot;);\n        new TerserPlugin(&#123;\n          terserOptions: &#123;\n            compress: &#123;\n              passes: 2\n            &#125;\n          &#125;\n        &#125;).apply(compiler);\n      &#125;\n    &#125;],\n    nodeEnv: false\n  &#125;,\n  output: &#123;\n    assetModuleFilename: &#39;[hash][ext][query]&#39;,\n    charset: true,\n    chunkFilename: &#39;[name].js&#39;,\n    chunkFormat: &#39;array-push&#39;,\n    chunkLoading: &#39;jsonp&#39;,\n    chunkLoadingGlobal: &#39;webpackChunktest_npm&#39;,\n    chunkLoadTimeout: 120000,\n    clean: undefined,\n    compareBeforeEmit: true,\n    crossOriginLoading: false,\n    devtoolFallbackModuleFilenameTemplate: undefined,\n    devtoolModuleFilenameTemplate: undefined,\n    devtoolNamespace: &#39;test-npm&#39;,\n    environment: &#123;\n      arrowFunction: true,\n      &#39;const&#39;: true,\n      destructuring: true,\n      forOf: true,\n      bigIntLiteral: undefined,\n      dynamicImport: undefined,\n      module: undefined\n    &#125;,\n    enabledChunkLoadingTypes: [&#39;jsonp&#39;, &#39;import-scripts&#39;],\n    enabledLibraryTypes: [],\n    enabledWasmLoadingTypes: [&#39;fetch&#39;],\n    filename: &#39;[name].js&#39;,\n    globalObject: &#39;self&#39;,\n    hashDigest: &#39;hex&#39;,\n    hashDigestLength: 20,\n    hashFunction: &#39;md4&#39;,\n    hashSalt: undefined,\n    hotUpdateChunkFilename: &#39;[id].[fullhash].hot-update.js&#39;,\n    hotUpdateGlobal: &#39;webpackHotUpdatetest_npm&#39;,\n    hotUpdateMainFilename: &#39;[runtime].[fullhash].hot-update.json&#39;,\n    iife: true,\n    importFunctionName: &#39;import&#39;,\n    importMetaName: &#39;import.meta&#39;,\n    scriptType: false,\n    library: undefined,\n    module: false,\n    path: &#39;&#x2F;Users&#x2F;test&#x2F;dist&#39;,\n    pathinfo: false,\n    publicPath: &#39;auto&#39;,\n    sourceMapFilename: &#39;[file].map[query]&#39;,\n    sourcePrefix: undefined,\n    strictModuleExceptionHandling: false,\n    uniqueName: &#39;test-npm&#39;,\n    wasmLoading: &#39;fetch&#39;,\n    webassemblyModuleFilename: &#39;[hash].module.wasm&#39;,\n    workerChunkLoading: &#39;import-scripts&#39;,\n    workerWasmLoading: &#39;fetch&#39;\n  &#125;,\n  parallelism: 100,\n  performance: false,\n  plugins: [],\n  profile: false,\n  recordsInputPath: false,\n  recordsOutputPath: false,\n  resolve: &#123;\n    byDependency: &#123;\n      wasm: &#123;\n        conditionNames: [&#39;import&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      esm: &#123;\n        conditionNames: [&#39;import&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      loaderImport: &#123;\n        conditionNames: [&#39;import&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      worker: &#123;\n        conditionNames: [&#39;import&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;],\n        preferRelative: true\n      &#125;,\n      commonjs: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      amd: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      loader: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      unknown: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      undefined: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      url: &#123;\n        preferRelative: true\n      &#125;\n    &#125;,\n    cache: false,\n    modules: [&#39;node_modules&#39;],\n    conditionNames: [&#39;webpack&#39;, &#39;production&#39;, &#39;browser&#39;],\n    mainFiles: [&#39;index&#39;],\n    extensions: [],\n    aliasFields: [],\n    exportsFields: [&#39;exports&#39;],\n    roots: [&#39;&#x2F;Users&#x2F;test&#39;],\n    mainFields: [&#39;main&#39;]\n  &#125;,\n  resolveLoader: &#123;\n    cache: false,\n    conditionNames: [&#39;loader&#39;, &#39;require&#39;, &#39;node&#39;],\n    exportsFields: [&#39;exports&#39;],\n    mainFields: [&#39;loader&#39;, &#39;main&#39;],\n    extensions: [&#39;.js&#39;],\n    mainFiles: [&#39;index&#39;]\n  &#125;,\n  snapshot: &#123;\n    resolveBuildDependencies: &#123;\n      timestamp: true,\n      hash: true\n    &#125;,\n    buildDependencies: &#123;\n      timestamp: true,\n      hash: true\n    &#125;,\n    resolve: &#123;\n      timestamp: true\n    &#125;,\n    module: &#123;\n      timestamp: true\n    &#125;,\n    immutablePaths: [],\n    managedPaths: [&#39;&#x2F;Users&#x2F;test&#x2F;node_modules&#39;]\n  &#125;,\n  stats: &#123;&#125;,\n  target: &#39;web&#39;,\n  watch: false,\n  watchOptions: &#123;&#125;\n&#125;\n复制代码\n\nmode: &#39;development&#39;module.exports &#x3D; &#123;\n  amd: undefined,\n  bail: undefined,\n  cache: &#123;\n    type: &#39;memory&#39;,\n    maxGenerations: Infinity\n  &#125;,\n  context: &#39;&#x2F;Users&#x2F;test&#39;,\n  dependencies: undefined,\n  devServer: undefined,\n  devtool: &#39;eval&#39;,\n  entry: &#123;\n    main: &#123;\n      &#39;import&#39;: [&#39;.&#x2F;src&#39;]\n    &#125;\n  &#125;,\n  experiments: &#123;\n    topLevelAwait: false,\n    syncWebAssembly: false,\n    asyncWebAssembly: false,\n    outputModule: false\n  &#125;,\n  externals: undefined,\n  externalsPresets: &#123;\n    web: true,\n    node: false,\n    nwjs: false,\n    electron: false,\n    electronMain: false,\n    electronPreload: false,\n    electronRenderer: false\n  &#125;,\n  externalsType: &#39;var&#39;,\n  ignoreWarnings: undefined,\n  infrastructureLogging: &#123;&#125;,\n  loader: &#123;\n    target: &#39;web&#39;\n  &#125;,\n  mode: &#39;development&#39;,\n  module: &#123;\n    noParse: undefined,\n    unsafeCache: module &#x3D;&gt; &#123;\n      const name &#x3D; module.nameForCondition();\n      return name &amp;&amp; NODE_MODULES_REGEXP.test(name);\n    &#125;,\n    parser: &#123;\n      javascript: &#123;\n        unknownContextRequest: &#39;.&#39;,\n        unknownContextRegExp: false,\n        unknownContextRecursive: true,\n        unknownContextCritical: true,\n        exprContextRequest: &#39;.&#39;,\n        exprContextRegExp: false,\n        exprContextRecursive: true,\n        exprContextCritical: true,\n        wrappedContextRegExp: &#x2F;.*&#x2F;,\n        wrappedContextRecursive: true,\n        wrappedContextCritical: false,\n        strictExportPresence: false,\n        strictThisContextOnImports: false\n      &#125;,\n      asset: &#123;\n        dataUrlCondition: &#123;\n          maxSize: 8096\n        &#125;\n      &#125;\n    &#125;,\n    generator: &#123;&#125;,\n    defaultRules: [&#123;\n      mimetype: &#39;application&#x2F;node&#39;,\n      type: &#39;javascript&#x2F;auto&#39;\n    &#125;, &#123;\n      test: &#x2F;.json$&#x2F;i,\n      type: &#39;json&#39;\n    &#125;, &#123;\n      mimetype: &#39;application&#x2F;json&#39;,\n      type: &#39;json&#39;\n    &#125;, &#123;\n      test: &#x2F;.mjs$&#x2F;i,\n      type: &#39;javascript&#x2F;esm&#39;,\n      resolve: &#123;\n        byDependency: &#123;\n          esm: &#123;\n            fullySpecified: true\n          &#125;\n        &#125;\n      &#125;\n    &#125;, &#123;\n      test: &#x2F;.js$&#x2F;i,\n      descriptionData: &#123;\n        type: &#39;module&#39;\n      &#125;,\n      type: &#39;javascript&#x2F;esm&#39;,\n      resolve: &#123;\n        byDependency: &#123;\n          esm: &#123;\n            fullySpecified: true\n          &#125;\n        &#125;\n      &#125;\n    &#125;, &#123;\n      test: &#x2F;.cjs$&#x2F;i,\n      type: &#39;javascript&#x2F;dynamic&#39;\n    &#125;, &#123;\n      test: &#x2F;.js$&#x2F;i,\n      descriptionData: &#123;\n        type: &#39;commonjs&#39;\n      &#125;,\n      type: &#39;javascript&#x2F;dynamic&#39;\n    &#125;, &#123;\n      mimetype: &#123;\n        or: [&#39;text&#x2F;javascript&#39;, &#39;application&#x2F;javascript&#39;]\n      &#125;,\n      type: &#39;javascript&#x2F;esm&#39;,\n      resolve: &#123;\n        byDependency: &#123;\n          esm: &#123;\n            fullySpecified: true\n          &#125;\n        &#125;\n      &#125;\n    &#125;, &#123;\n      dependency: &#39;url&#39;,\n      type: &#39;asset&#x2F;resource&#39;\n    &#125;],\n    rules: []\n  &#125;,\n  name: undefined,\n  node: &#123;\n    global: true,\n    __filename: &#39;mock&#39;,\n    __dirname: &#39;mock&#39;\n  &#125;,\n  optimization: &#123;\n    runtimeChunk: false,\n    splitChunks: &#123;\n      defaultSizeTypes: [&#39;javascript&#39;, &#39;unknown&#39;],\n      cacheGroups: &#123;\n        &#39;default&#39;: &#123;\n          idHint: &#39;&#39;,\n          reuseExistingChunk: true,\n          minChunks: 2,\n          priority: -20\n        &#125;,\n        defaultVendors: &#123;\n          idHint: &#39;vendors&#39;,\n          reuseExistingChunk: true,\n          test: &#x2F;[\\&#x2F;]node_modules[\\&#x2F;]&#x2F;i,\n          priority: -10\n        &#125;\n      &#125;,\n      hidePathInfo: false,\n      chunks: &#39;async&#39;,\n      usedExports: false,\n      minChunks: 1,\n      minSize: 10000,\n      minRemainingSize: 0,\n      enforceSizeThreshold: 30000,\n      maxAsyncRequests: Infinity,\n      maxInitialRequests: Infinity,\n      automaticNameDelimiter: &#39;-&#39;\n    &#125;,\n    emitOnErrors: true,\n    removeAvailableModules: false,\n    removeEmptyChunks: true,\n    mergeDuplicateChunks: true,\n    flagIncludedChunks: false,\n    moduleIds: &#39;named&#39;,\n    chunkIds: &#39;named&#39;,\n    sideEffects: &#39;flag&#39;,\n    providedExports: true,\n    usedExports: false,\n    innerGraph: false,\n    mangleExports: false,\n    concatenateModules: false,\n    checkWasmTypes: false,\n    mangleWasmImports: false,\n    portableRecords: false,\n    realContentHash: false,\n    minimize: false,\n    minimizer: [&#123;\n      apply: compiler &#x3D;&gt; &#123;\n        &#x2F;&#x2F; Lazy load the Terser plugin\n        const TerserPlugin &#x3D; require(&quot;terser-webpack-plugin&quot;);\n        new TerserPlugin(&#123;\n          terserOptions: &#123;\n            compress: &#123;\n              passes: 2\n            &#125;\n          &#125;\n        &#125;).apply(compiler);\n      &#125;\n    &#125;],\n    nodeEnv: &#39;development&#39;\n  &#125;,\n  output: &#123;\n    assetModuleFilename: &#39;[hash][ext][query]&#39;,\n    charset: true,\n    chunkFilename: &#39;[name].js&#39;,\n    chunkFormat: &#39;array-push&#39;,\n    chunkLoading: &#39;jsonp&#39;,\n    chunkLoadingGlobal: &#39;webpackChunktest_npm&#39;,\n    chunkLoadTimeout: 120000,\n    clean: undefined,\n    compareBeforeEmit: true,\n    crossOriginLoading: false,\n    devtoolFallbackModuleFilenameTemplate: undefined,\n    devtoolModuleFilenameTemplate: undefined,\n    devtoolNamespace: &#39;test-npm&#39;,\n    environment: &#123;\n      arrowFunction: true,\n      &#39;const&#39;: true,\n      destructuring: true,\n      forOf: true,\n      bigIntLiteral: undefined,\n      dynamicImport: undefined,\n      module: undefined\n    &#125;,\n    enabledChunkLoadingTypes: [&#39;jsonp&#39;, &#39;import-scripts&#39;],\n    enabledLibraryTypes: [],\n    enabledWasmLoadingTypes: [&#39;fetch&#39;],\n    filename: &#39;[name].js&#39;,\n    globalObject: &#39;self&#39;,\n    hashDigest: &#39;hex&#39;,\n    hashDigestLength: 20,\n    hashFunction: &#39;md4&#39;,\n    hashSalt: undefined,\n    hotUpdateChunkFilename: &#39;[id].[fullhash].hot-update.js&#39;,\n    hotUpdateGlobal: &#39;webpackHotUpdatetest_npm&#39;,\n    hotUpdateMainFilename: &#39;[runtime].[fullhash].hot-update.json&#39;,\n    iife: true,\n    importFunctionName: &#39;import&#39;,\n    importMetaName: &#39;import.meta&#39;,\n    scriptType: false,\n    library: undefined,\n    module: false,\n    path: &#39;&#x2F;Users&#x2F;test&#x2F;dist&#39;,\n    pathinfo: true,\n    publicPath: &#39;auto&#39;,\n    sourceMapFilename: &#39;[file].map[query]&#39;,\n    sourcePrefix: undefined,\n    strictModuleExceptionHandling: false,\n    uniqueName: &#39;test-npm&#39;,\n    wasmLoading: &#39;fetch&#39;,\n    webassemblyModuleFilename: &#39;[hash].module.wasm&#39;,\n    workerChunkLoading: &#39;import-scripts&#39;,\n    workerWasmLoading: &#39;fetch&#39;\n  &#125;,\n  parallelism: 100,\n  performance: false,\n  plugins: [],\n  profile: false,\n  recordsInputPath: false,\n  recordsOutputPath: false,\n  resolve: &#123;\n    byDependency: &#123;\n      wasm: &#123;\n        conditionNames: [&#39;import&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      esm: &#123;\n        conditionNames: [&#39;import&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      loaderImport: &#123;\n        conditionNames: [&#39;import&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      worker: &#123;\n        conditionNames: [&#39;import&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;],\n        preferRelative: true\n      &#125;,\n      commonjs: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      amd: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      loader: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      unknown: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      undefined: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      url: &#123;\n        preferRelative: true\n      &#125;\n    &#125;,\n    cache: true,\n    modules: [&#39;node_modules&#39;],\n    conditionNames: [&#39;webpack&#39;, &#39;development&#39;, &#39;browser&#39;],\n    mainFiles: [&#39;index&#39;],\n    extensions: [],\n    aliasFields: [],\n    exportsFields: [&#39;exports&#39;],\n    roots: [&#39;&#x2F;Users&#x2F;test&#39;],\n    mainFields: [&#39;main&#39;]\n  &#125;,\n  resolveLoader: &#123;\n    cache: true,\n    conditionNames: [&#39;loader&#39;, &#39;require&#39;, &#39;node&#39;],\n    exportsFields: [&#39;exports&#39;],\n    mainFields: [&#39;loader&#39;, &#39;main&#39;],\n    extensions: [&#39;.js&#39;],\n    mainFiles: [&#39;index&#39;]\n  &#125;,\n  snapshot: &#123;\n    resolveBuildDependencies: &#123;\n      timestamp: true,\n      hash: true\n    &#125;,\n    buildDependencies: &#123;\n      timestamp: true,\n      hash: true\n    &#125;,\n    resolve: &#123;\n      timestamp: true\n    &#125;,\n    module: &#123;\n      timestamp: true\n    &#125;,\n    immutablePaths: [],\n    managedPaths: [&#39;&#x2F;Users&#x2F;test&#x2F;node_modules&#39;]\n  &#125;,\n  stats: &#123;&#125;,\n  target: &#39;web&#39;,\n  watch: false,\n  watchOptions: &#123;&#125;\n&#125;\n复制代码\n\nmode: &#39;production&#39;module.exports &#x3D; &#123;\n  amd: undefined,\n  bail: undefined,\n  cache: false,\n  context: &#39;&#x2F;Users&#x2F;test&#39;,\n  dependencies: undefined,\n  devServer: undefined,\n  devtool: false,\n  entry: &#123;\n    main: &#123;\n      &#39;import&#39;: [&#39;.&#x2F;src&#39;]\n    &#125;\n  &#125;,\n  experiments: &#123;\n    topLevelAwait: false,\n    syncWebAssembly: false,\n    asyncWebAssembly: false,\n    outputModule: false\n  &#125;,\n  externals: undefined,\n  externalsPresets: &#123;\n    web: true,\n    node: false,\n    nwjs: false,\n    electron: false,\n    electronMain: false,\n    electronPreload: false,\n    electronRenderer: false\n  &#125;,\n  externalsType: &#39;var&#39;,\n  ignoreWarnings: undefined,\n  infrastructureLogging: &#123;&#125;,\n  loader: &#123;\n    target: &#39;web&#39;\n  &#125;,\n  mode: &#39;production&#39;,\n  module: &#123;\n    noParse: undefined,\n    unsafeCache: false,\n    parser: &#123;\n      javascript: &#123;\n        unknownContextRequest: &#39;.&#39;,\n        unknownContextRegExp: false,\n        unknownContextRecursive: true,\n        unknownContextCritical: true,\n        exprContextRequest: &#39;.&#39;,\n        exprContextRegExp: false,\n        exprContextRecursive: true,\n        exprContextCritical: true,\n        wrappedContextRegExp: &#x2F;.*&#x2F;,\n        wrappedContextRecursive: true,\n        wrappedContextCritical: false,\n        strictExportPresence: false,\n        strictThisContextOnImports: false\n      &#125;,\n      asset: &#123;\n        dataUrlCondition: &#123;\n          maxSize: 8096\n        &#125;\n      &#125;\n    &#125;,\n    generator: &#123;&#125;,\n    defaultRules: [&#123;\n      mimetype: &#39;application&#x2F;node&#39;,\n      type: &#39;javascript&#x2F;auto&#39;\n    &#125;, &#123;\n      test: &#x2F;.json$&#x2F;i,\n      type: &#39;json&#39;\n    &#125;, &#123;\n      mimetype: &#39;application&#x2F;json&#39;,\n      type: &#39;json&#39;\n    &#125;, &#123;\n      test: &#x2F;.mjs$&#x2F;i,\n      type: &#39;javascript&#x2F;esm&#39;,\n      resolve: &#123;\n        byDependency: &#123;\n          esm: &#123;\n            fullySpecified: true\n          &#125;\n        &#125;\n      &#125;\n    &#125;, &#123;\n      test: &#x2F;.js$&#x2F;i,\n      descriptionData: &#123;\n        type: &#39;module&#39;\n      &#125;,\n      type: &#39;javascript&#x2F;esm&#39;,\n      resolve: &#123;\n        byDependency: &#123;\n          esm: &#123;\n            fullySpecified: true\n          &#125;\n        &#125;\n      &#125;\n    &#125;, &#123;\n      test: &#x2F;.cjs$&#x2F;i,\n      type: &#39;javascript&#x2F;dynamic&#39;\n    &#125;, &#123;\n      test: &#x2F;.js$&#x2F;i,\n      descriptionData: &#123;\n        type: &#39;commonjs&#39;\n      &#125;,\n      type: &#39;javascript&#x2F;dynamic&#39;\n    &#125;, &#123;\n      mimetype: &#123;\n        or: [&#39;text&#x2F;javascript&#39;, &#39;application&#x2F;javascript&#39;]\n      &#125;,\n      type: &#39;javascript&#x2F;esm&#39;,\n      resolve: &#123;\n        byDependency: &#123;\n          esm: &#123;\n            fullySpecified: true\n          &#125;\n        &#125;\n      &#125;\n    &#125;, &#123;\n      dependency: &#39;url&#39;,\n      type: &#39;asset&#x2F;resource&#39;\n    &#125;],\n    rules: []\n  &#125;,\n  name: undefined,\n  node: &#123;\n    global: true,\n    __filename: &#39;mock&#39;,\n    __dirname: &#39;mock&#39;\n  &#125;,\n  optimization: &#123;\n    runtimeChunk: false,\n    splitChunks: &#123;\n      defaultSizeTypes: [&#39;javascript&#39;, &#39;unknown&#39;],\n      cacheGroups: &#123;\n        &#39;default&#39;: &#123;\n          idHint: &#39;&#39;,\n          reuseExistingChunk: true,\n          minChunks: 2,\n          priority: -20\n        &#125;,\n        defaultVendors: &#123;\n          idHint: &#39;vendors&#39;,\n          reuseExistingChunk: true,\n          test: &#x2F;[\\&#x2F;]node_modules[\\&#x2F;]&#x2F;i,\n          priority: -10\n        &#125;\n      &#125;,\n      hidePathInfo: true,\n      chunks: &#39;async&#39;,\n      usedExports: true,\n      minChunks: 1,\n      minSize: 20000,\n      minRemainingSize: undefined,\n      enforceSizeThreshold: 50000,\n      maxAsyncRequests: 30,\n      maxInitialRequests: 30,\n      automaticNameDelimiter: &#39;-&#39;\n    &#125;,\n    emitOnErrors: false,\n    removeAvailableModules: false,\n    removeEmptyChunks: true,\n    mergeDuplicateChunks: true,\n    flagIncludedChunks: true,\n    moduleIds: &#39;deterministic&#39;,\n    chunkIds: &#39;deterministic&#39;,\n    sideEffects: true,\n    providedExports: true,\n    usedExports: true,\n    innerGraph: true,\n    mangleExports: true,\n    concatenateModules: true,\n    checkWasmTypes: true,\n    mangleWasmImports: false,\n    portableRecords: false,\n    realContentHash: true,\n    minimize: true,\n    minimizer: [&#123;\n      apply: compiler &#x3D;&gt; &#123;\n        &#x2F;&#x2F; Lazy load the Terser plugin\n        const TerserPlugin &#x3D; require(&quot;terser-webpack-plugin&quot;);\n        new TerserPlugin(&#123;\n          terserOptions: &#123;\n            compress: &#123;\n              passes: 2\n            &#125;\n          &#125;\n        &#125;).apply(compiler);\n      &#125;\n    &#125;],\n    nodeEnv: &#39;production&#39;\n  &#125;,\n  output: &#123;\n    assetModuleFilename: &#39;[hash][ext][query]&#39;,\n    charset: true,\n    chunkFilename: &#39;[name].js&#39;,\n    chunkFormat: &#39;array-push&#39;,\n    chunkLoading: &#39;jsonp&#39;,\n    chunkLoadingGlobal: &#39;webpackChunktest_npm&#39;,\n    chunkLoadTimeout: 120000,\n    clean: undefined,\n    compareBeforeEmit: true,\n    crossOriginLoading: false,\n    devtoolFallbackModuleFilenameTemplate: undefined,\n    devtoolModuleFilenameTemplate: undefined,\n    devtoolNamespace: &#39;test-npm&#39;,\n    environment: &#123;\n      arrowFunction: true,\n      &#39;const&#39;: true,\n      destructuring: true,\n      forOf: true,\n      bigIntLiteral: undefined,\n      dynamicImport: undefined,\n      module: undefined\n    &#125;,\n    enabledChunkLoadingTypes: [&#39;jsonp&#39;, &#39;import-scripts&#39;],\n    enabledLibraryTypes: [],\n    enabledWasmLoadingTypes: [&#39;fetch&#39;],\n    filename: &#39;[name].js&#39;,\n    globalObject: &#39;self&#39;,\n    hashDigest: &#39;hex&#39;,\n    hashDigestLength: 20,\n    hashFunction: &#39;md4&#39;,\n    hashSalt: undefined,\n    hotUpdateChunkFilename: &#39;[id].[fullhash].hot-update.js&#39;,\n    hotUpdateGlobal: &#39;webpackHotUpdatetest_npm&#39;,\n    hotUpdateMainFilename: &#39;[runtime].[fullhash].hot-update.json&#39;,\n    iife: true,\n    importFunctionName: &#39;import&#39;,\n    importMetaName: &#39;import.meta&#39;,\n    scriptType: false,\n    library: undefined,\n    module: false,\n    path: &#39;&#x2F;Users&#x2F;test&#x2F;dist&#39;,\n    pathinfo: false,\n    publicPath: &#39;auto&#39;,\n    sourceMapFilename: &#39;[file].map[query]&#39;,\n    sourcePrefix: undefined,\n    strictModuleExceptionHandling: false,\n    uniqueName: &#39;test-npm&#39;,\n    wasmLoading: &#39;fetch&#39;,\n    webassemblyModuleFilename: &#39;[hash].module.wasm&#39;,\n    workerChunkLoading: &#39;import-scripts&#39;,\n    workerWasmLoading: &#39;fetch&#39;\n  &#125;,\n  parallelism: 100,\n  performance: &#123;\n    maxAssetSize: 250000,\n    maxEntrypointSize: 250000,\n    hints: &#39;warning&#39;\n  &#125;,\n  plugins: [],\n  profile: false,\n  recordsInputPath: false,\n  recordsOutputPath: false,\n  resolve: &#123;\n    byDependency: &#123;\n      wasm: &#123;\n        conditionNames: [&#39;import&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      esm: &#123;\n        conditionNames: [&#39;import&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      loaderImport: &#123;\n        conditionNames: [&#39;import&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      worker: &#123;\n        conditionNames: [&#39;import&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;],\n        preferRelative: true\n      &#125;,\n      commonjs: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      amd: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      loader: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      unknown: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      undefined: &#123;\n        conditionNames: [&#39;require&#39;, &#39;module&#39;, &#39;...&#39;],\n        extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;],\n        aliasFields: [&#39;browser&#39;],\n        mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;...&#39;]\n      &#125;,\n      url: &#123;\n        preferRelative: true\n      &#125;\n    &#125;,\n    cache: false,\n    modules: [&#39;node_modules&#39;],\n    conditionNames: [&#39;webpack&#39;, &#39;production&#39;, &#39;browser&#39;],\n    mainFiles: [&#39;index&#39;],\n    extensions: [],\n    aliasFields: [],\n    exportsFields: [&#39;exports&#39;],\n    roots: [&#39;&#x2F;Users&#x2F;test&#39;],\n    mainFields: [&#39;main&#39;]\n  &#125;,\n  resolveLoader: &#123;\n    cache: false,\n    conditionNames: [&#39;loader&#39;, &#39;require&#39;, &#39;node&#39;],\n    exportsFields: [&#39;exports&#39;],\n    mainFields: [&#39;loader&#39;, &#39;main&#39;],\n    extensions: [&#39;.js&#39;],\n    mainFiles: [&#39;index&#39;]\n  &#125;,\n  snapshot: &#123;\n    resolveBuildDependencies: &#123;\n      timestamp: true,\n      hash: true\n    &#125;,\n    buildDependencies: &#123;\n      timestamp: true,\n      hash: true\n    &#125;,\n    resolve: &#123;\n      timestamp: true,\n      hash: true\n    &#125;,\n    module: &#123;\n      timestamp: true,\n      hash: true\n    &#125;,\n    immutablePaths: [],\n    managedPaths: [&#39;&#x2F;Users&#x2F;test&#x2F;node_modules&#39;]\n  &#125;,\n  stats: &#123;&#125;,\n  target: &#39;web&#39;,\n  watch: false,\n  watchOptions: &#123;&#125;\n&#125;\n复制代码\n\n一点感想webpack的配置十分复杂，对构建过程涉及到的细节做成了可配置的，给人的感觉是增加了很大的学习成本，很多配置的来龙去脉，读文档也未必能够理解其中的作用，去研究源码会投入过多的精力，往往投入产出比很低。\n在一般的开发场景中，我们并不需要如此细致地对webpack的配置进行学习，webpack通过模式已经提供了最佳实践配置，而我们要做的，只不过是指定mode，然后视情况配置entry、output、loader、plugin而已。只有当默认的配置无法满足实际情况时，才需要对它进一步理解，这种情况少之又少，我们的重心应该放在更具有意义的业务价值上吧。\n","slug":"webpack5三种mode默认配置对比","date":"2022-10-21T14:49:27.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"efdc9b79c944d790c755000a59863fa6","title":"彻底搞懂nginx","content":"什么是nginx？nginx是一个开源可靠的HTTP中间件代理服务。\n配置目录主配置文件&#x2F;etc&#x2F;nginx&#x2F;nginx.conf配置文件基本结构：\n\nnginx 开启，关闭，重启开启 systemctl start nginx 关闭 nginx -s stop 重启，nginx -s reload （这个一般是在修改配置文件后，先用nginx -t 检查配置语法是否正确后，再用nginx -s reload 平滑重启）\n日志文件&#x2F;var&#x2F;log&#x2F;nginx\n发生错误的时候查找方法最重要的就是错误日志，错误日志，错误日志，当发生错误的时候，首先第一要想到去查看错误日志，查看发生错误的原因。\n\n1，首先查看错误日志 tail -n 10 &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log\n2，找到错误原因，修改配置文件 &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf\n3，查看修改的错误命令是否争取 nginx -t\n4，平滑重启 nginx -s reload\n\nserver_name优先级1，当在多个serve中匹配了相同的server_name 最先出现的优先级是最高的。\nlocationlocation 匹配规则\n1 &#x3D; 表示精确匹配。只有请求的url路径与后面的字符串完全相等时，才会命中。\n2 ~ 表示该规则是使用正则定义的，区分大小写。\n3 ~* 表示该规则是使用正则定义的，不区分大小写。\n4 ^~ 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找。 匹配顺序\n1 如果匹配到 &#x3D; ， 也就是精确匹配到url，则返回\n2 如果匹配到^~,则返回，并且不会想下匹配。这里我曾经遇到过在同一服务器上同时部署两个react单页项目的时候，一个react A 项目放在&#x2F;home目录下，一个react B项目放在&#x2F;codsse目录下，因为写了如下规则\n\n^~ &#x2F;codsse &#123;\n    ...\n&#125;\n复制代码\n\n导致当url是&#x2F;codesse&#x2F;的时候，可以匹配到B项目的index.html,但是同时在B中index.html中的js也匹配到了B项目的index.html,所以导致形成了一个死循环。\n\n3 接下来匹配正则表达式的，~ 或者~*的，如果匹配到则返回\n4 最后都没匹配到，则返回最大匹配的或者404\n5 &#x3D; &gt; ^~ &gt; &#x2F;* 优先级\n\ntry_filestry_files 试图寻找的文件\nalias与root的区别root会把匹配到location连在一起去访问 比如有以下配置\nlocation &#x2F;cat &#123;\n    root &#x2F;cat&#x2F;imgs&#x2F;;\n&#125;\n复制代码\n\n当访问 xx&#x2F;cat&#x2F;a.png的时候，实际上是到 &#x2F;cat&#x2F;imgs&#x2F;cat&#x2F;a.png中去寻找 当alias是&#x2F;cat&#x2F;imgs 的时候，同样的网址，实际上到&#x2F;cat&#x2F;imgs&#x2F;a.png中去寻找\nnginx 的访问控制http_access_moduledeny 拒绝访问allow 可以访问\n作为静态资源服务器压缩静态资源1， gzip：on        gzip_comp_level: 2 (压缩级别)  \n设置过期时间一般浏览器首先会检查max-age，如果过期，则会发送etag和Last-Modified到服务器验证 1， 设置过期时间       expires\n正向代理和反向代理正向代理？正向代理就是代理客户端发起请求，比如我们经常使用的vpn\n反向代理？就是在服务器端进行代理，比如你访问一个域名，并不知道真正的实际资源是否通过nginx给代理到哪里去了。\n跨域访问设置可以nginx允许可以跨域访问\nlocation &#x2F;sddss&#x2F; &#123;\n       proxy_redirect off; # 关闭重定向\n       add_header Access-Control-Allow-Origin *;\n   &#125;\n复制代码\n\n负载均衡所谓的负载均衡其实就是通过nginx把请求转发到不同的服务器上面去。 每个服务可以配置一些参数，比如weight权重，比如max_fails等 负载均衡也可以选择不同的算法，比如轮询，比如ip—hash算法和url—hash算法等\nupsteam ii &#123;\n    serve 1;\n    serve 2;\n&#125;\nserver &#123;\n    location &#x2F; &#123;\n        proxy_pass ii;\n        include proxy_params;\n    &#125;\n&#125;\n复制代码\n\nnginx 作为缓存服务器nginx 作为中间缓存，使用proxy_cache_path\nnginx 重定向url可以通过rewrite 根据正则匹配，把匹配到的url重定向到别的url中去\nrewrite 语法rewrite 正则 flagflag 包括break，last,redirect，permanent break会直接去查找而last相当于会继续向下匹配rediect 临时重定向permanent 永久重定向\nrewrite 优先级sever 中的rewrite规则 &gt; location 中的rewrite规则\nnginx 链接周期限制使用模块secure_link_module 原理就是首先nginx根据一些信息返回下载链接包括md5和expries，然后下载的时候，nginx在进行验证md5和过期时间。 返回链接如下： &#x2F;download?mad5&#x3D;dsdsd&amp;expries&#x3D;112233222\nlocation ~ &#123;\n   secure_link\n   secure_link_md5\n&#125;\n复制代码\n\nnginx 区分国内外ip使用模块http_geoip_module 可以根据访问的ip是否是国内ip，来进行限制访问\nlocation &#x2F; &#123;\n    if ($geoip_country_code !&#x3D; CN) &#123;\n        return 403\n    &#125;\n&#125;\n复制代码\n\nnginx httpshttps 配置*1 安装openssl http_ssl_module *2 生成CA证书 *3 配置\nserver &#123;\n    listen      443;\n    server_name www.onedns.net;\n    ssl         on;\n    ssl_certificate     &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;111net.pem;\n    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;2222.key;\n    ssl_protocols       Tddsdss;\n    ssl_ciphers         dddssdss;\n复制代码\n\nhttps 服务优化*1 激活keepalive 长链接 *2 激活ssl cache 缓存\nnginx+ LuaLua 基础语法\n1 ~&#x3D; 表示不等于\n2 字符串拼接 ..\n\n根据ip进行不同内容的访问基本原理： 当用户访问的时候，nginx 获得用户的ip，然后通过lua去访问ip数据库，然后让不同的ip访问不同的内容。\nlocation &#x2F; &#123;\n    default_type &quot;text&#x2F;html&quot;;\n    content_by_lua_file &#x2F;opt&#x2F;as.lua;\n&#125;\n复制代码\n\nnginx 性能优化ab接口压力测试工具ab -n 2000 -c 2 http://127.0.0.1\ncpu亲和设置worker process 为cpu核数\nnginx 安全常见的攻击手段\n1 密码撞库\n2 文件上传漏洞\n3 sql 注入\n\n","slug":"彻底搞懂nginx","date":"2022-10-14T11:56:14.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"b027df790b988095e3311de9321e5959","title":"记录微前端micro-app的配置","content":"介绍：基座应用react\n文章发布时，涉及到的依赖包版本：\n&#123;\n  &quot;@micro-zoe&#x2F;micro-app&quot;: &quot;^0.8.4&quot;,\n&#125;\n复制代码\n\n文章默认您已经大致浏览过micro-app官方文档，所以最好请先阅读官方文档：cangdu.org&#x2F;micro-app&#x2F;d…\n我目前大多数的项目都是hash路由，本来想着基座和子应用都配置成hash路由，但是我没找到官方的例子，自己也没试出来。。。最终选择了 基座应用history路由、子应用hash路由的方式 （注：后面已全部改为history路由）\n更多实现方式：cangdu.org&#x2F;micro-app&#x2F;d…\n下面说一下 需要做的修改：\n基座应用1、修改路由模式为historywebpack搭建的import &#123; BrowserRouter, HashRouter, useRoutes &#125; from &#39;react-router-dom&#39;\n...\nfunction App() &#123;\n  return (\n    &lt;BrowserRouter&gt;\n      &lt;RouteElement &#x2F;&gt;\n    &lt;&#x2F;BrowserRouter&gt;\n  )\n&#125;\nexport default App\n复制代码\n\nwebpack.config.js – 2022.02.17更新config.js一共需要改两个地方:\n...\noutput: &#123;\n  ...\n  publicPath: &#39;&#x2F;&#39;, &#x2F;&#x2F; history路由\n  ...\n&#125;,\n...\n...\ndevServer: &#123;\n  ...\n  historyApiFallback: true, &#x2F;&#x2F; history路由\n&#125;,\n复制代码\n\n如果是umi的项目需要查文档修改config\n2、安装@micro-zoe&#x2F;micro-appnpm install @micro-zoe&#x2F;micro-app\n复制代码\n\n3、入口文件引入microApp并start\nimport ReactDOM from &#39;react-dom&#39;\nimport App from &#39;.&#x2F;App&#39;\nimport microApp from &#39;@micro-zoe&#x2F;micro-app&#39;\n\nmicroApp.start(&#123;\n  &#x2F;&#x2F; 本地启动时 sockjs-node报错 要不然会一直刷新\n  plugins: &#123;\n    modules: &#123;\n      app1: [\n        &#123;\n          loader(code) &#123;\n            if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39; &amp;&amp; code.indexOf(&#39;sockjs-node&#39;) &gt; -1) &#123;\n              code &#x3D; code.replace(&#39;window.location.port&#39;, 8052) &#x2F;&#x2F; 这里需要修改成子应用的端口\n            &#125;\n            return code\n          &#125;,\n        &#125;,\n      ],\n    &#125;,\n  &#125;,\n&#125;)\nReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#39;root-main&#39;)) &#x2F;&#x2F; 这里index.html里的root div最好换个名字（root-main），以免和子应用的冲突\n复制代码\n\n4、路由配置中增加一个子应用的路由这里不需要每个页面加一个路由比如，子应用有 order&#x2F;page1 和 order&#x2F;page2 这两个路由，这里只需要添加一个childApp（这个是自己起名的），然后主应用配置菜单的时候，配置 childApp#&#x2F;order&#x2F;page1 和 childApp#&#x2F;order&#x2F;page2 这两个菜单就可以了\n  ...\n  &#x2F;&#x2F; 子应用1\n  &#123;\n    path: &#39;childApp&#39;,\n    element: () &#x3D;&gt; import(&#39;@&#x2F;pages&#x2F;childApp&#39;),\n  &#125;,\n  ...\n复制代码\n\n5、&#x2F;pages&#x2F;childApp&#x2F;index.jsx因为React不支持自定义事件，所以我们需要引入一个polyfill。在&lt;micro-app&gt;标签所在的文件顶部添加polyfill，注释也要复制。\n&#x2F;** @jsxRuntime classic *&#x2F;\n&#x2F;** @jsx jsxCustomEvent *&#x2F;\nimport jsxCustomEvent from &#39;@micro-zoe&#x2F;micro-app&#x2F;polyfill&#x2F;jsx-custom-event&#39; &#x2F;&#x2F; \n\nfunction Index() &#123;\n  &#x2F;&#x2F; name(必传)：应用名称\n  &#x2F;&#x2F; url(必传)：应用地址，会被自动补全为http:&#x2F;&#x2F;localhost:3000&#x2F;index.html\n  &#x2F;&#x2F; baseroute(可选)：基座应用分配给子应用的基础路由，就是上面的 &#96;&#x2F;my-page&#96;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;子应用&lt;&#x2F;h1&gt;\n      &lt;micro-app name&#x3D;&quot;app1&quot; url&#x3D;&quot;http:&#x2F;&#x2F;localhost:8052&#x2F;&quot; baseroute&#x3D;&quot;&#x2F;childApp&quot;&gt;&lt;&#x2F;micro-app&gt;\n    &lt;&#x2F;div&gt;\n  )\n&#125;\nexport default Index\n复制代码\n\n子应用webpack.config devServer增加headers支持跨域webpack.config.js\n  devServer: &#123;\n    headers: &#123;\n      &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,\n    &#125;,\n  &#125;,\n复制代码\n\nchainWebpack\n  config.devServer.headers(&#123;\n    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,\n  &#125;)\n复制代码\n\npublicPath如果自动补全失败，可以采用运行时publicPath方案解决。\n这是由webpack提供的功能，会在运行时动态设置webpack.publicPath\n步骤1:  在子应用src目录下创建名称为public-path.js的文件，并添加如下内容\n&#x2F;&#x2F; __MICRO_APP_ENVIRONMENT__和__MICRO_APP_PUBLIC_PATH__是由micro-app注入的全局变量\nif (window.__MICRO_APP_ENVIRONMENT__) &#123;\n  &#x2F;&#x2F; eslint-disable-next-line\n  __webpack_public_path__ &#x3D; window.__MICRO_APP_PUBLIC_PATH__\n&#125;复制代码Error复制成功\n复制代码\n\n步骤2:  在子应用入口文件的最顶部引入public-path.js\n&#x2F;&#x2F; entry\nimport &#39;.&#x2F;public-path&#39;复制代码Error复制成功\n复制代码\n\n子应用配置完毕。\n数据通信我这里主要是实现2种场景：1、共享token和login的userInfo2、子应用token失效要通知基座应用，清除token、userInfo并跳转登录页\n更多通信方式：cangdu.org&#x2F;micro-app&#x2F;d…\n1、共享token和login的userInfo基座应用setGlobalDataimport microApp from &#39;@micro-zoe&#x2F;micro-app&#39;\n\n...\nmicroApp.setGlobalData(&#123; userInfo: login.userInfo &#125;)\n...\n复制代码\n\n子应用获取数据const globalData &#x3D; window.microApp?.getGlobalData() &#x2F;&#x2F; 返回全局数据\nconsole.log(&#39;子应用拿到的 globalData&#39;, globalData);\n复制代码\n\n2、子应用token失效的情况子应用microApp.dispatch&#x2F;&#x2F; 子应用token失效的时候 触发：\nfunction handleTokenFail() &#123;\n  console.log(&#39;子应用token 失效&#39;)\n  window.microApp?.dispatch(&#123; type: &#39;token失效&#39; &#125;) &#x2F;&#x2F; 关键代码\n&#125;\n复制代码\n\n基座应用监听入口文件增加 microApp.addDataListener 代码\nimport ReactDOM from &#39;react-dom&#39;\nimport App from &#39;.&#x2F;App&#39;\nimport microApp from &#39;@micro-zoe&#x2F;micro-app&#39;\n\nmicroApp.start(&#123;\n  &#x2F;&#x2F; sockjs-node报错 要不然会一直刷新\n  plugins: &#123;\n    modules: &#123;\n      app1: [\n        &#123;\n          loader(code) &#123;\n            if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;development&#39; &amp;&amp; code.indexOf(&#39;sockjs-node&#39;) &gt; -1) &#123;\n              code &#x3D; code.replace(&#39;window.location.port&#39;, 8052)\n            &#125;\n            return code\n          &#125;,\n        &#125;,\n      ],\n    &#125;,\n  &#125;,\n&#125;)\n\nfunction dataListener(data) &#123;\n  console.log(&#39;来自子应用my-app的数据&#39;, data)\n&#125;\n\n&#x2F;**\n * 绑定监听函数\n * appName: 应用名称\n * dataListener: 绑定函数\n * autoTrigger: 在初次绑定监听函数时如果有缓存数据，是否需要主动触发一次，默认为false\n *&#x2F;\nmicroApp.addDataListener(&#39;app1&#39;, dataListener)\n\n&#x2F;&#x2F; &#x2F;&#x2F; 解绑监听my-app子应用的函数\n&#x2F;&#x2F; microApp.removeDataListener(appName: string, dataListener: Function)\n\n&#x2F;&#x2F; &#x2F;&#x2F; 清空所有监听appName子应用的函数\n&#x2F;&#x2F; microApp.clearDataListener(appName: string)\n\nReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#39;root-main&#39;))\n复制代码\n\n或者microApp.addDataListener和microApp.removeDataListener也可以写在最外面的layout里\n总结其实大部分的用法和修改，官方文档都已经介绍的非常详细了，这里只是结合自己的项目的一些修改，可以看到micro-app相比qiankun对项目入侵非常少，而且涉及到的api很少且更容易理解。后面会持续关注：）\n","slug":"记录微前端micro-app的配置","date":"2022-09-23T14:31:25.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"a110b92c4e47b4fc49cc33cb7f9c3765","title":"微前端实战篇","content":"一.为什么需要微前端?我们通过3W(what,why,how)的方式来讲解微前端\nWhat?什么是微前端?\n微前端就是将不同的功能按照不同的维度拆分成多个子应用。通过主应用来加载这些子应用。\n微前端的核心在于拆, 拆完后在合!\nWhy?为什么去使用他?\n不同团队间开发同一个应用技术栈不同怎么破？\n希望每个团队都可以独立开发，独立部署怎么破？\n项目中还需要老的应用代码怎么破？\n\n我们是不是可以将一个应用划分成若干个子应用，将子应用打包成一个个的lib。当路径切换时加载不同的子应用。这样每个子应用都是独立的，技术栈也不用做限制了！从而解决了前端协同开发问题\nHow?怎样落地微前端?\n2018年 Single-SPA诞生了， single-spa是一个用于前端微服务化的JavaScript前端解决方案 (本身没有处理样式隔离，js执行隔离) 实现了路由劫持和应用加载\n2019年 qiankun基于Single-SPA, 提供了更加开箱即用的 API （single-spa + sandbox + import-html-entry） 做到了，技术栈无关、并且接入简单（像iframe一样简单）\n\n\n\n\n\n\n\n\n\n总结：子应用可以独立构建，运行时动态加载,主子应用完全解耦，技术栈无关，靠的是协议接入（子应用必须导出 bootstrap、mount、unmount方法）\n这里先回答大家肯定会问的问题：\n这不是iframe吗？\n\n如果使用iframe，iframe中的子应用切换路由时用户刷新页面就尴尬了。\n\n应用通信:\n\n基于URL来进行数据传递，但是传递消息能力弱\n基于CustomEvent实现通信\n基于props主子应用间通信\n使用全局变量、Redux进行通信\n\n公共依赖:\n\nCDN - externals\nwebpack联邦模块\n\n二 .SingleSpa实战1.构建子应用vue create spa-vue\nnpm install single-spa-vue\n复制代码\n\nimport singleSpaVue from &#39;single-spa-vue&#39;;\nconst appOptions &#x3D; &#123;\n   el: &#39;#vue&#39;,\n   router,\n   render: h &#x3D;&gt; h(App)\n&#125;\n&#x2F;&#x2F; 在非子应用中正常挂载应用\nif(!window.singleSpaNavigate)&#123;\n delete appOptions.el;\n new Vue(appOptions).$mount(&#39;#app&#39;);\n&#125;\nconst vueLifeCycle &#x3D; singleSpaVue(&#123;\n   Vue,\n   appOptions\n&#125;);\n&#x2F;&#x2F; 子应用必须导出 以下生命周期 bootstrap、mount、unmount\nexport const bootstrap &#x3D; vueLifeCycle.bootstrap;\nexport const mount &#x3D; vueLifeCycle.mount;\nexport const unmount &#x3D; vueLifeCycle.unmount;\nexport default vueLifeCycle;\n复制代码\n\nconst router &#x3D; new VueRouter(&#123;\n  mode: &#39;history&#39;,\n  base: &#39;&#x2F;vue&#39;,\n  routes\n&#125;)\n复制代码\n\n\n\n\n\n\n\n\n\n\n配置子路由基础路径\n2.配置库打包module.exports &#x3D; &#123;\n    configureWebpack: &#123;\n        output: &#123;\n            library: &#39;singleVue&#39;,\n            libraryTarget: &#39;umd&#39;\n        &#125;,\n        devServer:&#123;\n            port:10000\n        &#125;\n    &#125;\n&#125;\n复制代码\n\n\n\n\n\n\n\n\n\n\n将子模块打包成类库\n3.主应用搭建&lt;div id&#x3D;&quot;nav&quot;&gt;\n    &lt;router-link to&#x3D;&quot;&#x2F;vue&quot;&gt;vue项目&lt;&#x2F;router-link&gt; \n    &lt;div id&#x3D;&quot;vue&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n复制代码\n\n\n\n\n\n\n\n\n\n\n将子应用挂载到id=&quot;vue&quot;标签中\nimport Vue from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\nimport router from &#39;.&#x2F;router&#39;\nimport ElementUI from &#39;element-ui&#39;;\nimport &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;;\nVue.use(ElementUI);\nconst loadScript &#x3D; async (url)&#x3D;&gt; &#123;\n  await new Promise((resolve,reject)&#x3D;&gt;&#123;\n    const script &#x3D; document.createElement(&#39;script&#39;);\n    script.src &#x3D; url;\n    script.onload &#x3D; resolve;\n    script.onerror &#x3D; reject;\n    document.head.appendChild(script)\n  &#125;);\n&#125;\nimport &#123; registerApplication, start &#125; from &#39;single-spa&#39;;\nregisterApplication(\n    &#39;singleVue&#39;,\n    async ()&#x3D;&gt;&#123;\n        await loadScript(&#39;http:&#x2F;&#x2F;localhost:10000&#x2F;js&#x2F;chunk-vendors.js&#39;);\n        await loadScript(&#39;http:&#x2F;&#x2F;localhost:10000&#x2F;js&#x2F;app.js&#39;);\n        return window.singleVue\n    &#125;,\n    location &#x3D;&gt; location.pathname.startsWith(&#39;&#x2F;vue&#39;)\n)\nstart();\nnew Vue(&#123;\n  router,\n  render: h &#x3D;&gt; h(App)\n&#125;).$mount(&#39;#app&#39;)\n复制代码\n\n4.动态设置子应用publicPathif(window.singleSpaNavigate)&#123;\n  __webpack_public_path__ &#x3D; &#39;http:&#x2F;&#x2F;localhost:10000&#x2F;&#39;\n&#125;\n复制代码\n\n三.qiankun实战1.主应用编写&lt;el-menu :router&#x3D;&quot;true&quot; mode&#x3D;&quot;horizontal&quot;&gt;\n    &lt;el-menu-item index&#x3D;&quot;&#x2F;&quot;&gt;首页&lt;&#x2F;el-menu-item&gt;\n    &lt;el-menu-item index&#x3D;&quot;&#x2F;vue&quot;&gt;vue应用&lt;&#x2F;el-menu-item&gt;\n    &lt;el-menu-item index&#x3D;&quot;&#x2F;react&quot;&gt;react应用&lt;&#x2F;el-menu-item&gt;\n&lt;&#x2F;el-menu&gt;\n&lt;router-view v-show&#x3D;&quot;$route.name&quot;&gt;&lt;&#x2F;router-view&gt;\n&lt;div v-show&#x3D;&quot;!$route.name&quot; id&#x3D;&quot;vue&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div v-show&#x3D;&quot;!$route.name&quot; id&#x3D;&quot;react&quot;&gt;&lt;&#x2F;div&gt;\n复制代码\n\n2.注册子应用import &#123;registerMicroApps,start&#125; from &#39;qiankun&#39;\nconst apps &#x3D; [  &#123;    name:&#39;vueApp&#39;,    entry:&#39;&#x2F;&#x2F;localhost:10000&#39;,    container:&#39;#vue&#39;,    activeRule:&#39;&#x2F;vue&#39;  &#125;,  &#123;    name:&#39;reactApp&#39;,    entry:&#39;&#x2F;&#x2F;localhost:20000&#39;,    container:&#39;#react&#39;,    activeRule:&#39;&#x2F;react&#39;  &#125;]\nregisterMicroApps(apps);\nstart();\n复制代码\n\n3.子Vue应用let instance &#x3D; null;\nfunction render()&#123;\n  instance &#x3D; new Vue(&#123;\n    router,\n    render: h &#x3D;&gt; h(App)\n  &#125;).$mount(&#39;#app&#39;)\n&#125;\nif(window.__POWERED_BY_QIANKUN__)&#123;\n  __webpack_public_path__ &#x3D; window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;\n&#125;\nif(!window.__POWERED_BY_QIANKUN__)&#123;render()&#125;\nexport async function bootstrap()&#123;&#125;\nexport async function mount(props)&#123;render();&#125;\nexport async function unmount()&#123;instance.$destroy();&#125;\n复制代码\n\n打包配置\nmodule.exports &#x3D; &#123;\n    devServer:&#123;\n        port:10000,\n        headers:&#123;\n            &#39;Access-Control-Allow-Origin&#39;:&#39;*&#39;\n        &#125;\n    &#125;,\n    configureWebpack:&#123;\n        output:&#123;\n            library:&#39;vueApp&#39;,\n            libraryTarget:&#39;umd&#39;\n        &#125;\n    &#125;\n&#125;\n复制代码\n\n4.子React应用import React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport &#39;.&#x2F;index.css&#39;;\nimport App from &#39;.&#x2F;App&#39;;\nfunction render() &#123;\n  ReactDOM.render(\n    &lt;React.StrictMode&gt;\n      &lt;App &#x2F;&gt;\n    &lt;&#x2F;React.StrictMode&gt;,\n    document.getElementById(&#39;root&#39;)\n  );\n&#125;\nif(!window.__POWERED_BY_QIANKUN__)&#123;\n  render()\n&#125;\nexport async function bootstrap() &#123;&#125;\nexport async function mount() &#123;render();&#125;\nexport async function unmount() &#123;\n  ReactDOM.unmountComponentAtNode(document.getElementById(&quot;root&quot;));\n&#125;\n复制代码\n\n重写react中的webpack配置文件 (config-overrides.js)\nyarn add react-app-rewired --save-dev\n复制代码\n\nmodule.exports &#x3D; &#123;\n  webpack: (config) &#x3D;&gt; &#123;\n    config.output.library &#x3D; &#96;reactApp&#96;;\n    config.output.libraryTarget &#x3D; &quot;umd&quot;;\n    config.output.publicPath &#x3D; &#39;http:&#x2F;&#x2F;localhost:20000&#x2F;&#39;\n    return config\n  &#125;,\n  devServer: function (configFunction) &#123;\n    return function (proxy, allowedHost) &#123;\n      const config &#x3D; configFunction(proxy, allowedHost);\n      config.headers &#x3D; &#123;\n        &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,\n      &#125;;\n      return config;\n    &#125;;\n  &#125;,\n&#125;;\n复制代码\n\n配置.env文件\nPORT&#x3D;20000\nWDS_SOCKET_PORT&#x3D;20000\n复制代码\n\nReact路由配置\nimport &#123; BrowserRouter, Route, Link &#125; from &quot;react-router-dom&quot;\nconst BASE_NAME &#x3D; window.__POWERED_BY_QIANKUN__ ? &quot;&#x2F;react&quot; : &quot;&quot;;\nfunction App() &#123;\n  return (\n    &lt;BrowserRouter basename&#x3D;&#123;BASE_NAME&#125;&gt;\n      &lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;首页&lt;&#x2F;Link&gt;\n      &lt;Link to&#x3D;&quot;&#x2F;about&quot;&gt;关于&lt;&#x2F;Link&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;&quot; exact render&#x3D;&#123;() &#x3D;&gt; &lt;h1&gt;hello home&lt;&#x2F;h1&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n      &lt;Route path&#x3D;&quot;&#x2F;about&quot; render&#x3D;&#123;() &#x3D;&gt; &lt;h1&gt;hello about&lt;&#x2F;h1&gt;&#125;&gt;&lt;&#x2F;Route&gt;\n    &lt;&#x2F;BrowserRouter&gt;\n  );\n&#125;\n复制代码\n\n四.CSS隔离方案子应用之间样式隔离：\n\nDynamic Stylesheet动态样式表，当应用切换时移除老应用样式，添加新应用样式\n\n主应用和子应用之间的样式隔离：\n\nBEM(Block Element Modifier) 约定项目前缀\nCSS-Modules 打包时生成不冲突的选择器名\nShadow DOM 真正意义上的隔离\ncss-in-js\n\n\nlet shadowDom &#x3D; shadow.attachShadow(&#123; mode: &#39;open&#39; &#125;);\nlet pElement &#x3D; document.createElement(&#39;p&#39;);\npElement.innerHTML &#x3D; &#39;hello world&#39;;\nlet styleElement &#x3D; document.createElement(&#39;style&#39;);\nstyleElement.textContent &#x3D; &#96;\n    p&#123;color:red&#125;\n&#96;\nshadowDom.appendChild(pElement);\nshadowDom.appendChild(styleElement)\n复制代码\n\n\n\n\n\n\n\n\n\n\nshadow DOM 可以实现真正的隔离机制\n五.JS沙箱机制\n当运行子应用时应该跑在内部沙箱环境中\n\n快照沙箱，在应用沙箱挂载或卸载时记录快照，在切换时依据快照恢复环境 (无法支持多实例)\nProxy 代理沙箱,不影响全局环境\n\n1).快照沙箱\n1.激活时将当前window属性进行快照处理\n2.失活时用快照中的内容和当前window属性比对\n3.如果属性发生变化保存到modifyPropsMap中，并用快照还原window属性\n4.在次激活时，再次进行快照，并用上次修改的结果还原window\n\nclass SnapshotSandbox &#123;\n    constructor() &#123;\n        this.proxy &#x3D; window; \n        this.modifyPropsMap &#x3D; &#123;&#125;; &#x2F;&#x2F; 修改了那些属性\n        this.active();\n    &#125;\n    active() &#123;\n        this.windowSnapshot &#x3D; &#123;&#125;; &#x2F;&#x2F; window对象的快照\n        for (const prop in window) &#123;\n            if (window.hasOwnProperty(prop)) &#123;\n                &#x2F;&#x2F; 将window上的属性进行拍照\n                this.windowSnapshot[prop] &#x3D; window[prop];\n            &#125;\n        &#125;\n        Object.keys(this.modifyPropsMap).forEach(p &#x3D;&gt; &#123;\n            window[p] &#x3D; this.modifyPropsMap[p];\n        &#125;);\n    &#125;\n    inactive() &#123;\n        for (const prop in window) &#123; &#x2F;&#x2F; diff 差异\n            if (window.hasOwnProperty(prop)) &#123;\n                &#x2F;&#x2F; 将上次拍照的结果和本次window属性做对比\n                if (window[prop] !&#x3D;&#x3D; this.windowSnapshot[prop]) &#123;\n                    &#x2F;&#x2F; 保存修改后的结果\n                    this.modifyPropsMap[prop] &#x3D; window[prop]; \n                    &#x2F;&#x2F; 还原window\n                    window[prop] &#x3D; this.windowSnapshot[prop]; \n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n复制代码\n\nlet sandbox &#x3D; new SnapshotSandbox();\n((window) &#x3D;&gt; &#123;\n    window.a &#x3D; 1;\n    window.b &#x3D; 2;\n    window.c &#x3D; 3\n    console.log(a,b,c)\n    sandbox.inactive();\n    console.log(a,b,c)\n&#125;)(sandbox.proxy);\n复制代码\n\n\n\n\n\n\n\n\n\n\n快照沙箱只能针对单实例应用场景,如果是多个实例同时挂载的情况则无法解决，只能通过proxy代理沙箱来实现\n2.Proxy 代理沙箱class ProxySandbox &#123;\n    constructor() &#123;\n        const rawWindow &#x3D; window;\n        const fakeWindow &#x3D; &#123;&#125;\n        const proxy &#x3D; new Proxy(fakeWindow, &#123;\n            set(target, p, value) &#123;\n                target[p] &#x3D; value;\n                return true\n            &#125;,\n            get(target, p) &#123;\n                return target[p] || rawWindow[p];\n            &#125;\n        &#125;);\n        this.proxy &#x3D; proxy\n    &#125;\n&#125;\nlet sandbox1 &#x3D; new ProxySandbox();\nlet sandbox2 &#x3D; new ProxySandbox();\nwindow.a &#x3D; 1;\n((window) &#x3D;&gt; &#123;\n    window.a &#x3D; &#39;hello&#39;;\n    console.log(window.a)\n&#125;)(sandbox1.proxy);\n((window) &#x3D;&gt; &#123;\n    window.a &#x3D; &#39;world&#39;;\n    console.log(window.a)\n&#125;)(sandbox2.proxy);\n复制代码\n\n\n\n\n\n\n\n\n\n\n每个应用都创建一个proxy来代理window，好处是每个应用都是相对独立，不需要直接更改全局window属性！\n","slug":"微前端实战篇","date":"2022-09-15T15:16:31.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"d15af8effdd73a8b6f9c6e84242a848d","title":"MJML邮件模版实战","content":"\n前言最近画个邮件模版使用table布局一言难尽，还要兼容各种邮件厂商，最后找了一个邮件模版来处理。\nMJMLMJML是一种标记语言，旨在减少编写响应电子邮件的痛苦。它的语义语法使它简单明了，它丰富的标准组件库加快了您的开发时间，并减轻了您的电子邮件代码库。MJML的开源引擎生成符合最佳实践的高质量响应HTML。\n环境搭建创建个文件夹demo -&gt; 进入demo目录\n初始化项目\nnpm init -y\n复制代码\n\n安装mjml包\nnpm install mjml\n复制代码\n\n创建demo.mjml文件\n\n页面编写vscode 和 webstorm都有预览插件，直接搜索MJML即可。 建议还是在官网在线编写，然后在复制到代码保存。\n在线编写地址: mjml.io&#x2F;try-it-live\n当然你也可以用可视化界面来编辑：grapesjs.com&#x2F;demo-mjml.h…\n这是一封回复邮件\n\n像普通的HTML模板一样，我们可以将这个模板分成不同的部分以适应网格。 电子邮件正文，由mj-body标记包含文档的全部内容：\n\n&lt;mjml&gt;\n  &lt;mj-body&gt;\n    to do..\n  &lt;&#x2F;mj-body&gt;\n&lt;&#x2F;mjml&gt;\n复制代码\n\n从这里，您可以首先定义您的分区：\n\n&lt;mjml&gt;\n  &lt;mj-body&gt;\n    &lt;mj-section&gt;\n      1\n    &lt;&#x2F;mj-section&gt;\n    &lt;mj-section&gt;\n      2\n    &lt;&#x2F;mj-section&gt;\n    &lt;mj-section&gt;\n      3\n    &lt;&#x2F;mj-section&gt;\n    &lt;mj-section&gt;\n      4\n    &lt;&#x2F;mj-section&gt;\n  &lt;&#x2F;mj-body&gt;\n&lt;&#x2F;mjml&gt;\n复制代码\n\n在任何部分中，都应该有列（即使您只需要一列），列是使MJML响应的原因。\n\n&lt;mjml&gt;\n  &lt;mj-body&gt;\n     &lt;!-- 1 --&gt;\n     &lt;mj-section background-url&#x3D;&quot;http:&#x2F;&#x2F;1.bp.blogspot.com&#x2F;-TPrfhxbYpDY&#x2F;Uh3Refzk02I&#x2F;AAAAAAAALw8&#x2F;5sUJ0UUGYuw&#x2F;s1600&#x2F;New+York+in+The+1960&#39;s+-+70&#39;s+(2).jpg&quot; background-size&#x3D;&quot;cover&quot; background-repeat&#x3D;&quot;no-repeat&quot;&gt;\n      &lt;mj-column width&#x3D;&quot;600px&quot;&gt;\n        &lt;mj-text align&#x3D;&quot;center&quot; color&#x3D;&quot;#fff&quot; font-size&#x3D;&quot;40px&quot; font-family&#x3D;&quot;Helvetica Neue&quot;&gt;Subject&lt;&#x2F;mj-text&gt;\n      &lt;&#x2F;mj-column&gt;\n    &lt;&#x2F;mj-section&gt;\n    &lt;!-- 2 --&gt;\n    &lt;mj-section&gt;\n      &lt;mj-column &gt;\n        &lt;mj-text color&#x3D;&quot;#000&quot; font-size&#x3D;&quot;16px&quot; font-family&#x3D;&quot;Helvetica Neue&quot;&gt;Lorem ipsum dolor sit amet,consectetur adipiscing elit.sit amet,consectetur adipiscing elit.sit amet,consectetur adipiscing elit.sit amet,consectetur adipiscing elit.sit amet,consectetur adipiscing elit.&lt;&#x2F;mj-text&gt;\n      &lt;&#x2F;mj-column&gt;\n    &lt;&#x2F;mj-section&gt;\n    &lt;!-- 3 --&gt;\n    &lt;mj-section&gt;\n      &lt;mj-column &gt;\n       &lt;mj-divider padding-left&#x3D;&quot;0px&quot; padding-right&#x3D;&quot;0px&quot;&gt;&lt;&#x2F;mj-divider&gt;\n      &lt;&#x2F;mj-column&gt;\n    &lt;&#x2F;mj-section&gt;\n    &lt;!-- 4 --&gt;\n    &lt;mj-section background-color&#x3D;&quot;#ffffff&quot;  full-width&#x3D;&quot;full-width&quot;&gt;\n      &lt;mj-column vertical-align&#x3D;&quot;top&quot; width&#x3D;&quot;33.33333333333333%&quot;&gt;\n        &lt;mj-image src&#x3D;&quot;http:&#x2F;&#x2F;191n.mj.am&#x2F;img&#x2F;191n&#x2F;1t&#x2F;hs.png&quot; alt&#x3D;&quot;&quot; width&#x3D;&quot;50px&quot;&gt;&lt;&#x2F;mj-image&gt;\n        &lt;mj-text align&#x3D;&quot;center&quot; color&#x3D;&quot;#9da3a3&quot; font-size&#x3D;&quot;11px&quot; padding-bottom&#x3D;&quot;30px&quot;&gt;&lt;span style&#x3D;&quot;font-size: 14px; color: #e85034&quot;&gt;Best audience&lt;&#x2F;span&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque eleifend sagittis nunc, et fermentum est ullamcorper dignissim.&lt;&#x2F;mj-text&gt;\n      &lt;&#x2F;mj-column&gt;\n      &lt;mj-column vertical-align&#x3D;&quot;top&quot; width&#x3D;&quot;33.33333333333333%&quot;&gt;\n        &lt;mj-image src&#x3D;&quot;http:&#x2F;&#x2F;191n.mj.am&#x2F;img&#x2F;191n&#x2F;1t&#x2F;hm.png&quot; alt&#x3D;&quot;&quot; width&#x3D;&quot;50px&quot;&gt;&lt;&#x2F;mj-image&gt;\n        &lt;mj-text align&#x3D;&quot;center&quot; color&#x3D;&quot;#9da3a3&quot; font-size&#x3D;&quot;11px&quot; padding-bottom&#x3D;&quot;30px&quot;&gt;&lt;span style&#x3D;&quot;font-size: 14px; color: #e85034&quot;&gt;Higher rates&lt;&#x2F;span&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque eleifend sagittis nunc, et fermentum est ullamcorper dignissim.&lt;&#x2F;mj-text&gt;\n      &lt;&#x2F;mj-column&gt;\n      &lt;mj-column vertical-align&#x3D;&quot;top&quot; width&#x3D;&quot;33.33333333333333%&quot;&gt;\n        &lt;mj-image src&#x3D;&quot;http:&#x2F;&#x2F;191n.mj.am&#x2F;img&#x2F;191n&#x2F;1t&#x2F;hl.png&quot; alt&#x3D;&quot;&quot; width&#x3D;&quot;50px&quot;&gt;&lt;&#x2F;mj-image&gt;\n        &lt;mj-text align&#x3D;&quot;center&quot; color&#x3D;&quot;#9da3a3&quot; font-size&#x3D;&quot;11px&quot; padding-bottom&#x3D;&quot;30px&quot; padding-top&#x3D;&quot;3px&quot;&gt;&lt;span style&#x3D;&quot;font-size: 14px; color: #e85034&quot;&gt;24&#x2F;7 Support&lt;&#x2F;span&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque eleifend sagittis nunc, et fermentum est ullamcorper dignissim.&lt;&#x2F;mj-text&gt;\n      &lt;&#x2F;mj-column&gt;\n    &lt;&#x2F;mj-section&gt;\n  &lt;&#x2F;mj-body&gt;\n&lt;&#x2F;mjml&gt;\n复制代码\n\n至此我们就得到一个响应式布局的模板。\n编译mjml demo.mjml -o demo.html\n复制代码\n\n\n编译完成即可看到我们生成的html，打开浏览器进行预览。\n发送测试邮件这里采用 nodemailer包，来发送邮件。 官网地址: nodemailer.\nnpm install nodemailer fs path\n复制代码\n\n&#x2F;&#x2F; send.js\n\nvar nodemailer &#x3D; require(&#39;nodemailer&#39;);\nvar fs &#x3D; require(&#39;fs&#39;)\nvar path &#x3D; require(&#39;path&#39;)\nvar transporter &#x3D; nodemailer.createTransport(&#123;\n    service: &#39;qq&#39;,\n    auth: &#123;\n        user: &#39;11111111@qq.com&#39;, &#x2F;&#x2F; 你的账号\n        pass: &#39;xxxxxxxx&#39; &#x2F;&#x2F;你的qq授权码\n    &#125;\n&#125;);\nvar mailOptions &#x3D; &#123;\n    from: &#39;&quot;nick&quot; &lt;11111111@qq.com&gt;&#39;, &#x2F;&#x2F; 你的账号名 | 你的账号\n    to: &#39;222222@qq.com,333333@qq.com,&#39;, &#x2F;&#x2F; 接受者,可以同时发送多个,以逗号隔开\n    subject: &#39;MJML&#39;, &#x2F;&#x2F; 标题\n    html: fs.createReadStream(path.resolve(__dirname,&#39;demo.html&#39;)) &#x2F;&#x2F; 指定发送文件路径\n&#125;;\n\ntransporter.sendMail(mailOptions, function (err, info) &#123;\n    if (err) &#123;\n        console.log(err);\n        return;\n    &#125;\n    console.log(&#39;发送成功&#39;);\n&#125;);\n\n复制代码\n\nqq授权码获取:打开qq邮箱，找到设置，打开配置，你就能得到qq授权码。\n\n运行命令\nnode send.js\n复制代码\n\n至此邮件已经发送到你的邮箱。\n自动编译后续邮件越写越多，文件目标很多，不太想一个个手动编译成html,所以写个脚本自动编译输出html文件。\n新增 src目录 新增 build.js\n\n&#x2F;&#x2F; build.js\n\nconst fs &#x3D; require(&#39;fs&#39;)\nconst path &#x3D; require(&#39;path&#39;);\nconst child_process &#x3D; require(&#39;child_process&#39;);\n\n&#x2F;**\n * src 目录下文件\n * dist 打包的目标文件\n *&#x2F;\ncopyDir(&#39;.&#x2F;src&#x2F;*&#39;, &#39;.&#x2F;dist&#39;)\n\n\n&#x2F;&#x2F; 复制文件 -&gt; 编译文件\nfunction copyDir(src, dist) &#123;\n    if (fs.existsSync(dist)) &#123;\n        copyFile(src, dist)\n    &#125;else&#123;\n        fs.mkdir(dist, function (err) &#123;\n            if (err) &#123;\n                console.log(err)\n                return\n            &#125;\n            copyFile(src, dist)\n        &#125;)\n    &#125;\n    function copyFile(src, dist)&#123;\n        &#x2F;&#x2F; 如果是windows\n        if(process.platform &#x3D;&#x3D;&#x3D; &#39;win32&#39;)&#123;\n            child_process.exec(&#96;ROBOCOPY src $&#123;dist&#125; &#x2F;E &#x2F;MT:30&#96;,function () &#123;\n                compile()\n            &#125;);\n        &#125;else&#123;\n            child_process.exec(&#96;cp -r $&#123;src&#125; $&#123;dist&#125;&#96;,function () &#123;\n                compile()\n            &#125;);\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F; 编译文件\nfunction compile( src &#x3D; &#39;dist&#39;) &#123;\n    let startPath &#x3D; process.cwd()\n    fs.readdir(src,&#123;withFileTypes:true&#125;,  function (err, files) &#123;\n        files.forEach(file&#x3D;&gt;&#123;\n            if(file.isDirectory())&#123;\n                let dir &#x3D; &#96;$&#123;src&#125;&#x2F;$&#123;file.name&#125;&#96;\n                compile(dir)\n            &#125;else&#123;\n                &#x2F;&#x2F; 获取当前文件名称\n                let fileName &#x3D; file.name.split(&#39;.&#39;)[0]\n                &#x2F;&#x2F; 具体目录\n                process.chdir(src);\n                &#x2F;&#x2F; 如果是windows\n                if(process.platform &#x3D;&#x3D;&#x3D; &#39;win32&#39;)&#123;\n                    &#x2F;&#x2F; 编译MJML文件\n                    const compile &#x3D; child_process.exec(&#96;mjml $&#123;fileName&#125;.mjml -o $&#123;fileName&#125;.html&#96;)\n                    compile.on(&#39;close&#39;, (code) &#x3D;&gt; &#123;\n                        console.log(&#39;编译成功:&#39;,&#96;$&#123;fileName&#125;.mjml&#96;)\n                        let filePath &#x3D; path.join(__dirname,&#96;$&#123;src&#125;&#x2F;$&#123;fileName&#125;.mjml&#96;)\n                        child_process.exec(&#96;del $&#123;filePath&#125;&#96;)\n                    &#125;);\n                &#125;else&#123;\n                    &#x2F;&#x2F; 编译MJML文件\n                    const compile &#x3D; child_process.spawn(&#96;mjml&#96;, [&#96;$&#123;fileName&#125;.mjml&#96;,&#96;-o&#96;,&#96;$&#123;fileName&#125;.html&#96;], &#123;cwd: path.resolve(__dirname, src)&#125;)\n                    compile.on(&#39;close&#39;, code &#x3D;&gt; &#123;\n                        &#x2F;&#x2F; 删除MJML文件\n                        child_process.spawn(&#96;rm&#96;, [&#96;$&#123;fileName&#125;.mjml&#96;], &#123;cwd: path.resolve(__dirname, src)&#125;)\n                        console.log(&#39;编译成功:&#39;,&#96;$&#123;fileName&#125;.mjml&#96;)\n                    &#125;)\n                &#125;\n                &#x2F;&#x2F; 复原目录\n                process.chdir(startPath);\n            &#125;\n        &#125;)\n    &#125;)\n&#125;\n\n复制代码\n\n运行命令\nnode build.js\n复制代码\n\n会自动编译生成和src目录相同的html结构。\n\n结语MJML在几个邮件厂商测试样式偏差不大，值得使用。 如果文章对你有帮助，请帮我点赞收藏，谢谢大家。\n参考HTML Email 编写指南【阮一峰】：地址\ngithub demo地址:github\n","slug":"MJML邮件模版实战","date":"2022-09-07T14:13:14.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"52a992a246e40d85d4ae950cdaebc053","title":"面试题笔记——代码输出结果篇","content":"一、异步&amp;事件循环1. 代码输出结果const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  console.log(1);\n  console.log(2);\n&#125;);\npromise.then(() &#x3D;&gt; &#123;\n  console.log(3);\n&#125;);\nconsole.log(4);\n复制代码\n\n输出结果如下：\n1 \n2 \n4\n复制代码\n\npromise.then 是微任务，它会在所有的宏任务执行完之后才会执行，同时需要promise内部的状态发生变化，因为这里内部没有发生变化，一直处于pending状态，所以不输出3。\n2. 代码输出结果const promise1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  console.log(&#39;promise1&#39;)\n  resolve(&#39;resolve1&#39;)\n&#125;)\nconst promise2 &#x3D; promise1.then(res &#x3D;&gt; &#123;\n  console.log(res)\n&#125;)\nconsole.log(&#39;1&#39;, promise1);\nconsole.log(&#39;2&#39;, promise2);\n复制代码\n\n输出结果如下：\npromise1\n1 Promise&#123;&lt;resolved&gt;: resolve1&#125;\n2 Promise&#123;&lt;pending&gt;&#125;\nresolve1\n复制代码\n\n需要注意的是，直接打印promise1，会打印出它的状态值和参数。\n代码执行过程如下：\n\nscript是一个宏任务，按照顺序执行这些代码；\n首先进入Promise，执行该构造函数中的代码，打印promise1；\n碰到resolve函数, 将promise1的状态改变为resolved, 并将结果保存下来；\n碰到promise1.then这个微任务，将它放入微任务队列；\npromise2是一个新的状态为pending的Promise；\n执行同步代码1， 同时打印出promise1的状态是resolved；\n执行同步代码2，同时打印出promise2的状态是pending；\n宏任务执行完毕，查找微任务队列，发现promise1.then这个微任务且状态为resolved，执行它。\n\n3. 代码输出结果const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  console.log(1);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&quot;timerStart&quot;);\n    resolve(&quot;success&quot;);\n    console.log(&quot;timerEnd&quot;);\n  &#125;, 0);\n  console.log(2);\n&#125;);\npromise.then((res) &#x3D;&gt; &#123;\n  console.log(res);\n&#125;);\nconsole.log(4);\n复制代码\n\n输出结果如下：\n1\n2\n4\ntimerStart\ntimerEnd\nsuccess\n复制代码\n\n代码执行过程如下：\n\n首先遇到Promise构造函数，会先执行里面的内容，打印1；\n遇到定时器steTimeout，它是一个宏任务，放入宏任务队列；\n继续向下执行，打印出2；\n由于Promise的状态此时还是pending，所以promise.then先不执行；\n继续执行下面的同步任务，打印出4；\n此时微任务队列没有任务，继续执行下一轮宏任务，执行steTimeout；\n首先执行timerStart，然后遇到了resolve，将promise的状态改为resolved且保存结果并将之前的promise.then推入微任务队列，再执行timerEnd；\n执行完这个宏任务，就去执行微任务promise.then，打印出resolve的结果。\n\n4. 代码输出结果Promise.resolve().then(() &#x3D;&gt; &#123;\n  console.log(&#39;promise1&#39;);\n  const timer2 &#x3D; setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;timer2&#39;)\n  &#125;, 0)\n&#125;);\nconst timer1 &#x3D; setTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;timer1&#39;)\n  Promise.resolve().then(() &#x3D;&gt; &#123;\n    console.log(&#39;promise2&#39;)\n  &#125;)\n&#125;, 0)\nconsole.log(&#39;start&#39;);\n复制代码\n\n输出结果如下：\nstart\npromise1\ntimer1\npromise2\ntimer2\n复制代码\n\n代码执行过程如下：\n\n首先，Promise.resolve().then是一个微任务，加入微任务队列\n执行timer1，它是一个宏任务，加入宏任务队列\n继续执行下面的同步代码，打印出start\n这样第一轮宏任务就执行完了，开始执行微任务Promise.resolve().then，打印出promise1\n遇到timer2，它是一个宏任务，将其加入宏任务队列，此时宏任务队列有两个任务，分别是timer1、timer2；\n这样第一轮微任务就执行完了，开始执行第二轮宏任务，首先执行定时器timer1，打印timer1；\n遇到Promise.resolve().then，它是一个微任务，加入微任务队列\n开始执行微任务队列中的任务，打印promise2；\n最后执行宏任务timer2定时器，打印出timer2；\n\n5. 代码输出结果const promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n    resolve(&#39;success1&#39;);\n    reject(&#39;error&#39;);\n    resolve(&#39;success2&#39;);\n&#125;);\npromise.then((res) &#x3D;&gt; &#123;\n    console.log(&#39;then:&#39;, res);\n&#125;).catch((err) &#x3D;&gt; &#123;\n    console.log(&#39;catch:&#39;, err);\n&#125;)\n复制代码\n\n输出结果如下：\nthen：success1\n复制代码\n\n这个题目考察的就是Promise的状态在发生变化之后，就不会再发生变化。开始状态由pending变为resolve，说明已经变为已完成状态，下面的两个状态的就不会再执行，同时下面的catch也不会捕获到错误。\n6. 代码输出结果Promise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n复制代码\n\n输出结果如下：\n1\nPromise &#123;&lt;fulfilled&gt;: undefined&#125;\n复制代码\n\nPromise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。\nthen方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。\n7. 代码输出结果const promise1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    resolve(&#39;success&#39;)\n  &#125;, 1000)\n&#125;)\nconst promise2 &#x3D; promise1.then(() &#x3D;&gt; &#123;\n  throw new Error(&#39;error!!!&#39;)\n&#125;)\nconsole.log(&#39;promise1&#39;, promise1)\nconsole.log(&#39;promise2&#39;, promise2)\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;promise1&#39;, promise1)\n  console.log(&#39;promise2&#39;, promise2)\n&#125;, 2000)\n复制代码\n\n输出结果如下：\npromise1 Promise &#123;&lt;pending&gt;&#125;\npromise2 Promise &#123;&lt;pending&gt;&#125;\n\nUncaught (in promise) Error: error!!!\npromise1 Promise &#123;&lt;fulfilled&gt;: &quot;success&quot;&#125;\npromise2 Promise &#123;&lt;rejected&gt;: Error: error!!&#125;\n复制代码\n\n8. 代码输出结果Promise.resolve(1)\n  .then(res &#x3D;&gt; &#123;\n    console.log(res);\n    return 2;\n  &#125;)\n  .catch(err &#x3D;&gt; &#123;\n    return 3;\n  &#125;)\n  .then(res &#x3D;&gt; &#123;\n    console.log(res);\n  &#125;);\n复制代码\n\n输出结果如下：\n1   \n2\n复制代码\n\nPromise是可以链式调用的，由于每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般任务的链式调用一样return this。\n上面的输出结果之所以依次打印出1和2，是因为resolve(1)之后走的是第一个then方法，并没有进catch里，所以第二个then中的res得到的实际上是第一个then的返回值。并且return 2会被包装成resolve(2)，被最后的then打印输出2。\n9. 代码输出结果Promise.resolve().then(() &#x3D;&gt; &#123;\n  return new Error(&#39;error!!!&#39;)\n&#125;).then(res &#x3D;&gt; &#123;\n  console.log(&quot;then: &quot;, res)\n&#125;).catch(err &#x3D;&gt; &#123;\n  console.log(&quot;catch: &quot;, err)\n&#125;)\n复制代码\n\n输出结果如下：\n&quot;then: &quot; &quot;Error: error!!!&quot;\n复制代码\n\n返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的return new Error(&#39;error!!!&#39;)也被包裹成了return Promise.resolve(new Error(&#39;error!!!&#39;))，因此它会被then捕获而不是catch。\n10. 代码输出结果const promise &#x3D; Promise.resolve().then(() &#x3D;&gt; &#123;\n  return promise;\n&#125;)\npromise.catch(console.err)\n复制代码\n\n输出结果如下：\nUncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;\n复制代码\n\n这里其实是一个坑，.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。\n11. 代码输出结果Promise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .then(console.log)\n复制代码\n\n输出结果如下：\n1\n复制代码\n\n看到这个题目，好多的then，实际上只需要记住一个原则：.then 或.catch 的参数期望是函数，传入非函数则会发生值透传。\n第一个then和第二个then中传入的都不是函数，一个是数字，一个是对象，因此发生了透传，将resolve(1) 的值直接传到最后一个then里，直接打印出1。\n12. 代码输出结果Promise.reject(&#39;err!!!&#39;)\n  .then((res) &#x3D;&gt; &#123;\n    console.log(&#39;success&#39;, res)\n  &#125;, (err) &#x3D;&gt; &#123;\n    console.log(&#39;error&#39;, err)\n  &#125;).catch(err &#x3D;&gt; &#123;\n    console.log(&#39;catch&#39;, err)\n  &#125;)\n复制代码\n\n输出结果如下：\nerror err!!!\n复制代码\n\n我们知道，.then函数中的两个参数：\n\n第一个参数是用来处理Promise成功的函数\n第二个则是处理失败的函数\n\n也就是说Promise.resolve(&#39;1&#39;)的值会进入成功的函数，Promise.reject(&#39;2&#39;)的值会进入失败的函数。\n在这道题中，错误直接被then的第二个参数捕获了，所以就不会被catch捕获了，输出结果为：error err!!!&#39;\n但是，如果是像下面这样：\nPromise.resolve()\n  .then(function success (res) &#123;\n    throw new Error(&#39;error!!!&#39;)\n  &#125;, function fail1 (err) &#123;\n    console.log(&#39;fail1&#39;, err)\n  &#125;).catch(function fail2 (err) &#123;\n    console.log(&#39;fail2&#39;, err)\n  &#125;)\n复制代码\n\n在then的第一参数中抛出了错误，那么他就不会被第二个参数不活了，而是被后面的catch捕获到。\n13. 代码输出结果Promise.resolve(&#39;1&#39;)\n  .then(res &#x3D;&gt; &#123;\n    console.log(res)\n  &#125;)\n  .finally(() &#x3D;&gt; &#123;\n    console.log(&#39;finally&#39;)\n  &#125;)\nPromise.resolve(&#39;2&#39;)\n  .finally(() &#x3D;&gt; &#123;\n    console.log(&#39;finally2&#39;)\n  \treturn &#39;我是finally2返回的值&#39;\n  &#125;)\n  .then(res &#x3D;&gt; &#123;\n    console.log(&#39;finally2后面的then函数&#39;, res)\n  &#125;)\n复制代码\n\n输出结果如下：\n1\nfinally2\nfinally\nfinally2后面的then函数 2\n复制代码\n\n.finally()一般用的很少，只要记住以下几点就可以了：\n\n.finally()方法不管Promise对象最后的状态如何都会执行\n.finally()方法的回调函数不接受任何的参数，也就是说你在.finally()函数中是无法知道Promise最终的状态是resolved还是rejected的\n它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。\nfinally本质上是then方法的特例\n\n.finally()的错误捕获：\nPromise.resolve(&#39;1&#39;)\n  .finally(() &#x3D;&gt; &#123;\n    console.log(&#39;finally1&#39;)\n    throw new Error(&#39;我是finally中抛出的异常&#39;)\n  &#125;)\n  .then(res &#x3D;&gt; &#123;\n    console.log(&#39;finally后面的then函数&#39;, res)\n  &#125;)\n  .catch(err &#x3D;&gt; &#123;\n    console.log(&#39;捕获错误&#39;, err)\n  &#125;)\n复制代码\n\n输出结果为：\n&#39;finally1&#39;\n&#39;捕获错误&#39; Error: 我是finally中抛出的异常\n复制代码\n\n14. 代码输出结果function runAsync (x) &#123;\n    const p &#x3D; new Promise(r &#x3D;&gt; setTimeout(() &#x3D;&gt; r(x, console.log(x)), 1000))\n    return p\n&#125;\n\nPromise.all([runAsync(1), runAsync(2), runAsync(3)]).then(res &#x3D;&gt; console.log(res))\n复制代码\n\n输出结果如下：\n1\n2\n3\n[1, 2, 3]\n复制代码\n\n首先，定义了一个Promise，来异步执行函数runAsync，该函数传入一个值x，然后间隔一秒后打印出这个x。\n之后再使用Promise.all来执行这个函数，执行的时候，看到一秒之后输出了1，2，3，同时输出了数组[1, 2, 3]，三个函数是同步执行的，并且在一个回调函数中返回了所有的结果。并且结果和函数的执行顺序是一致的。\n15. 代码输出结果function runAsync (x) &#123;\n  const p &#x3D; new Promise(r &#x3D;&gt; setTimeout(() &#x3D;&gt; r(x, console.log(x)), 1000))\n  return p\n&#125;\nfunction runReject (x) &#123;\n  const p &#x3D; new Promise((res, rej) &#x3D;&gt; setTimeout(() &#x3D;&gt; rej(&#96;Error: $&#123;x&#125;&#96;, console.log(x)), 1000 * x))\n  return p\n&#125;\nPromise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])\n       .then(res &#x3D;&gt; console.log(res))\n       .catch(err &#x3D;&gt; console.log(err))\n复制代码\n\n输出结果如下：\n&#x2F;&#x2F; 1s后输出\n1\n3\n&#x2F;&#x2F; 2s后输出\n2\nError: 2\n&#x2F;&#x2F; 4s后输出\n4\n复制代码\n\n可以看到。catch捕获到了第一个错误，在这道题目中最先的错误就是runReject(2)的结果。如果一组异步操作中有一个异常都不会进入.then()的第一个回调函数参数中。会被.then()的第二个回调函数捕获。\n16. 代码输出结果function runAsync (x) &#123;\n  const p &#x3D; new Promise(r &#x3D;&gt; setTimeout(() &#x3D;&gt; r(x, console.log(x)), 1000))\n  return p\n&#125;\nPromise.race([runAsync(1), runAsync(2), runAsync(3)])\n  .then(res &#x3D;&gt; console.log(&#39;result: &#39;, res))\n  .catch(err &#x3D;&gt; console.log(err))\n复制代码\n\n输出结果如下：\n1\n&#39;result: &#39; 1\n2\n3\n复制代码\n\nthen只会捕获第一个成功的方法，其他的函数虽然还会继续执行，但是不是被then捕获了。\n17. 代码输出结果function runAsync(x) &#123;\n  const p &#x3D; new Promise(r &#x3D;&gt;\n    setTimeout(() &#x3D;&gt; r(x, console.log(x)), 1000)\n  );\n  return p;\n&#125;\nfunction runReject(x) &#123;\n  const p &#x3D; new Promise((res, rej) &#x3D;&gt;\n    setTimeout(() &#x3D;&gt; rej(&#96;Error: $&#123;x&#125;&#96;, console.log(x)), 1000 * x)\n  );\n  return p;\n&#125;\nPromise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)])\n  .then(res &#x3D;&gt; console.log(&quot;result: &quot;, res))\n  .catch(err &#x3D;&gt; console.log(err));\n复制代码\n\n输出结果如下：\n0\nError: 0\n1\n2\n3\n复制代码\n\n可以看到在catch捕获到第一个错误之后，后面的代码还不执行，不过不会再被捕获了。\n注意：all和race传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。\n18. 代码输出结果async function async1() &#123;\n  console.log(&quot;async1 start&quot;);\n  await async2();\n  console.log(&quot;async1 end&quot;);\n&#125;\nasync function async2() &#123;\n  console.log(&quot;async2&quot;);\n&#125;\nasync1();\nconsole.log(&#39;start&#39;)\n复制代码\n\n输出结果如下：\nasync1 start\nasync2\nstart\nasync1 end\n复制代码\n\n代码的执行过程如下：\n\n首先执行函数中的同步代码async1 start，之后遇到了await，它会阻塞async1后面代码的执行，因此会先去执行async2中的同步代码async2，然后跳出async1；\n跳出async1函数后，执行同步代码start；\n在一轮宏任务全部执行完之后，再来执行await后面的内容async1 end。\n\n这里可以理解为await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中。\n19. 代码输出结果async function async1() &#123;\n  console.log(&quot;async1 start&quot;);\n  await async2();\n  console.log(&quot;async1 end&quot;);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;timer1&#39;)\n  &#125;, 0)\n&#125;\nasync function async2() &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;timer2&#39;)\n  &#125;, 0)\n  console.log(&quot;async2&quot;);\n&#125;\nasync1();\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;timer3&#39;)\n&#125;, 0)\nconsole.log(&quot;start&quot;)\n复制代码\n\n输出结果如下：\nasync1 start\nasync2\nstart\nasync1 end\ntimer2\ntimer3\ntimer1\n复制代码\n\n代码的执行过程如下：\n\n首先进入async1，打印出async1 start；\n之后遇到async2，进入async2，遇到定时器timer2，加入宏任务队列，之后打印async2；\n由于async2阻塞了后面代码的执行，所以执行后面的定时器timer3，将其加入宏任务队列，之后打印start；\n然后执行async2后面的代码，打印出async1 end，遇到定时器timer1，将其加入宏任务队列；\n最后，宏任务队列有三个任务，先后顺序为timer2，timer3，timer1，没有微任务，所以直接所有的宏任务按照先进先出的原则执行。\n\n20. 代码输出结果async function async1 () &#123;\n  console.log(&#39;async1 start&#39;);\n  await new Promise(resolve &#x3D;&gt; &#123;\n    console.log(&#39;promise1&#39;)\n  &#125;)\n  console.log(&#39;async1 success&#39;);\n  return &#39;async1 end&#39;\n&#125;\nconsole.log(&#39;srcipt start&#39;)\nasync1().then(res &#x3D;&gt; console.log(res))\nconsole.log(&#39;srcipt end&#39;)\n复制代码\n\n输出结果如下：\nscript start\nasync1 start\npromise1\nscript end\n复制代码\n\n这里需要注意的是在async1中await后面的Promise是没有返回值的，也就是它的状态始终是pending状态，所以在await之后的内容是不会执行的，包括async1后面的 .then。\n21. 代码输出结果async function async1 () &#123;\n  console.log(&#39;async1 start&#39;);\n  await new Promise(resolve &#x3D;&gt; &#123;\n    console.log(&#39;promise1&#39;)\n    resolve(&#39;promise1 resolve&#39;)\n  &#125;).then(res &#x3D;&gt; console.log(res))\n  console.log(&#39;async1 success&#39;);\n  return &#39;async1 end&#39;\n&#125;\nconsole.log(&#39;srcipt start&#39;)\nasync1().then(res &#x3D;&gt; console.log(res))\nconsole.log(&#39;srcipt end&#39;)\n复制代码\n\n这里是对上面一题进行了改造，加上了resolve。\n输出结果如下：\nscript start\nasync1 start\npromise1\nscript end\npromise1 resolve\nasync1 success\nasync1 end\n复制代码\n\n22. 代码输出结果async function async1() &#123;\n  console.log(&quot;async1 start&quot;);\n  await async2();\n  console.log(&quot;async1 end&quot;);\n&#125;\n\nasync function async2() &#123;\n  console.log(&quot;async2&quot;);\n&#125;\n\nconsole.log(&quot;script start&quot;);\n\nsetTimeout(function() &#123;\n  console.log(&quot;setTimeout&quot;);\n&#125;, 0);\n\nasync1();\n\nnew Promise(resolve &#x3D;&gt; &#123;\n  console.log(&quot;promise1&quot;);\n  resolve();\n&#125;).then(function() &#123;\n  console.log(&quot;promise2&quot;);\n&#125;);\nconsole.log(&#39;script end&#39;)\n复制代码\n\n输出结果如下：\nscript start\nasync1 start\nasync2\npromise1\nscript end\nasync1 end\npromise2\nsetTimeout\n复制代码\n\n代码执行过程如下：\n\n开头定义了async1和async2两个函数，但是并未执行，执行script中的代码，所以打印出script start；\n遇到定时器Settimeout，它是一个宏任务，将其加入到宏任务队列；\n之后执行函数async1，首先打印出async1 start；\n遇到await，执行async2，打印出async2，并阻断后面代码的执行，将后面的代码加入到微任务队列；\n然后跳出async1和async2，遇到Promise，打印出promise1；\n遇到resolve，将其加入到微任务队列，然后执行后面的script代码，打印出script end；\n之后就该执行微任务队列了，首先打印出async1 end，然后打印出promise2；\n执行完微任务队列，就开始执行宏任务队列中的定时器，打印出setTimeout。\n\n23. 代码输出结果async function async1 () &#123;\n  await async2();\n  console.log(&#39;async1&#39;);\n  return &#39;async1 success&#39;\n&#125;\nasync function async2 () &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    console.log(&#39;async2&#39;)\n    reject(&#39;error&#39;)\n  &#125;)\n&#125;\nasync1().then(res &#x3D;&gt; console.log(res))\n复制代码\n\n输出结果如下：\nasync2\nUncaught (in promise) error\n复制代码\n\n可以看到，如果async函数中抛出了错误，就会终止错误结果，不会继续向下执行。\n如果想要让错误不足之处后面的代码执行，可以使用catch来捕获：\nasync function async1 () &#123;\n  await Promise.reject(&#39;error!!!&#39;).catch(e &#x3D;&gt; console.log(e))\n  console.log(&#39;async1&#39;);\n  return Promise.resolve(&#39;async1 success&#39;)\n&#125;\nasync1().then(res &#x3D;&gt; console.log(res))\nconsole.log(&#39;script start&#39;)\n复制代码\n\n这样的输出结果就是：\nscript start\nerror!!!\nasync1\nasync1 success\n复制代码\n\n24. 代码输出结果const first &#x3D; () &#x3D;&gt; (new Promise((resolve, reject) &#x3D;&gt; &#123;\n    console.log(3);\n    let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;\n        console.log(7);\n        setTimeout(() &#x3D;&gt; &#123;\n            console.log(5);\n            resolve(6);\n            console.log(p)\n        &#125;, 0)\n        resolve(1);\n    &#125;);\n    resolve(2);\n    p.then((arg) &#x3D;&gt; &#123;\n        console.log(arg);\n    &#125;);\n&#125;));\nfirst().then((arg) &#x3D;&gt; &#123;\n    console.log(arg);\n&#125;);\nconsole.log(4);\n复制代码\n\n输出结果如下：\n3\n7\n4\n1\n2\n5\nPromise&#123;&lt;resolved&gt;: 1&#125;\n复制代码\n\n代码的执行过程如下：\n\n首先会进入Promise，打印出3，之后进入下面的Promise，打印出7；\n遇到了定时器，将其加入宏任务队列；\n执行Promise  p中的resolve，状态变为resolved，返回值为1；\n执行Promise first中的resolve，状态变为resolved，返回值为2；\n遇到p.then，将其加入微任务队列，遇到first().then，将其加入任务队列；\n执行外面的代码，打印出4；\n这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2；\n这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以resolve(6)不会再执行；\n最后console.log(p)打印出Promise&#123;&lt;resolved&gt;: 1&#125;；\n\n25. 代码输出结果const async1 &#x3D; async () &#x3D;&gt; &#123;\n  console.log(&#39;async1&#39;);\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(&#39;timer1&#39;)\n  &#125;, 2000)\n  await new Promise(resolve &#x3D;&gt; &#123;\n    console.log(&#39;promise1&#39;)\n  &#125;)\n  console.log(&#39;async1 end&#39;)\n  return &#39;async1 success&#39;\n&#125; \nconsole.log(&#39;script start&#39;);\nasync1().then(res &#x3D;&gt; console.log(res));\nconsole.log(&#39;script end&#39;);\nPromise.resolve(1)\n  .then(2)\n  .then(Promise.resolve(3))\n  .catch(4)\n  .then(res &#x3D;&gt; console.log(res))\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(&#39;timer2&#39;)\n&#125;, 1000)\n复制代码\n\n输出结果如下：\nscript start\nasync1\npromise1\nscript end\n1\ntimer2\ntimer1\n复制代码\n\n代码的执行过程如下：\n\n首先执行同步带吗，打印出script start；\n遇到定时器timer1将其加入宏任务队列；\n之后是执行Promise，打印出promise1，由于Promise没有返回值，所以后面的代码不会执行；\n然后执行同步代码，打印出script end；\n继续执行下面的Promise，.then和.catch期望参数是一个函数，这里传入的是一个数字，因此就会发生值渗透，将resolve(1)的值传到最后一个then，直接打印出1；\n遇到第二个定时器，将其加入到微任务队列，执行微任务队列，按顺序依次执行两个定时器，但是由于定时器时间的原因，会在两秒后先打印出timer2，在四秒后打印出timer1。\n\n26. 代码输出结果const p1 &#x3D; new Promise((resolve) &#x3D;&gt; &#123;\n  setTimeout(() &#x3D;&gt; &#123;\n    resolve(&#39;resolve3&#39;);\n    console.log(&#39;timer1&#39;)\n  &#125;, 0)\n  resolve(&#39;resovle1&#39;);\n  resolve(&#39;resolve2&#39;);\n&#125;).then(res &#x3D;&gt; &#123;\n  console.log(res)  &#x2F;&#x2F; resolve1\n  setTimeout(() &#x3D;&gt; &#123;\n    console.log(p1)\n  &#125;, 1000)\n&#125;).finally(res &#x3D;&gt; &#123;\n  console.log(&#39;finally&#39;, res)\n&#125;)\n复制代码\n\n执行结果为如下：\nresolve1\nfinally  undefined\ntimer1\nPromise&#123;&lt;resolved&gt;: undefined&#125;\n复制代码\n\n需要注意的是最后一个定时器打印出的p1其实是.finally的返回值，我们知道.finally的返回值如果在没有抛出错误的情况下默认会是上一个Promise的返回值，而这道题中.finally上一个Promise是.then()，但是这个.then()并没有返回值，所以p1打印出来的Promise的值会是undefined，如果在定时器的下面加上一个return 1，则值就会变成1。\n27. 代码输出结果console.log(&#39;1&#39;);\n\nsetTimeout(function() &#123;\n    console.log(&#39;2&#39;);\n    process.nextTick(function() &#123;\n        console.log(&#39;3&#39;);\n    &#125;)\n    new Promise(function(resolve) &#123;\n        console.log(&#39;4&#39;);\n        resolve();\n    &#125;).then(function() &#123;\n        console.log(&#39;5&#39;)\n    &#125;)\n&#125;)\nprocess.nextTick(function() &#123;\n    console.log(&#39;6&#39;);\n&#125;)\nnew Promise(function(resolve) &#123;\n    console.log(&#39;7&#39;);\n    resolve();\n&#125;).then(function() &#123;\n    console.log(&#39;8&#39;)\n&#125;)\n\nsetTimeout(function() &#123;\n    console.log(&#39;9&#39;);\n    process.nextTick(function() &#123;\n        console.log(&#39;10&#39;);\n    &#125;)\n    new Promise(function(resolve) &#123;\n        console.log(&#39;11&#39;);\n        resolve();\n    &#125;).then(function() &#123;\n        console.log(&#39;12&#39;)\n    &#125;)\n&#125;)\n复制代码\n\n输出结果如下：\n1\n7\n6\n8\n2\n4\n3\n5\n9\n11\n10\n12\n复制代码\n\n（1）第一轮事件循环流程分析如下：\n\n整体script作为第一个宏任务进入主线程，遇到console.log，输出1。\n遇到setTimeout，其回调函数被分发到宏任务Event Queue中。暂且记为setTimeout1。\n遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。记为process1。\n遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。记为then1。\n又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，记为setTimeout2。\n\n\n\n\n宏任务Event Queue\n微任务Event Queue\n\n\n\nsetTimeout1\nprocess1\n\n\nsetTimeout2\nthen1\n\n\n上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。发现了process1和then1两个微任务：\n\n执行process1，输出6。\n执行then1，输出8。\n\n第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。\n（2）第二轮时间循环从**setTimeout1**宏任务开始：\n\n首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。\nnew Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。\n\n\n\n\n宏任务Event Queue\n微任务Event Queue\n\n\n\nsetTimeout2\nprocess2\n\n\n\nthen2\n\n\n第二轮事件循环宏任务结束，发现有process2和then2两个微任务可以执行：\n\n输出3。\n输出5。\n\n第二轮事件循环结束，第二轮输出2，4，3，5。\n（3）第三轮事件循环开始，此时只剩setTimeout2了，执行。\n\n直接输出9。\n将process.nextTick()分发到微任务Event Queue中。记为process3。\n直接执行new Promise，输出11。\n将then分发到微任务Event Queue中，记为then3。\n\n\n\n\n宏任务Event Queue\n微任务Event Queue\n\n\n\n\nprocess3\n\n\n\nthen3\n\n\n第三轮事件循环宏任务执行结束，执行两个微任务process3和then3：\n\n输出10。\n输出12。\n\n第三轮事件循环结束，第三轮输出9，11，10，12。\n整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。\n28. 代码输出结果console.log(1)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(2)\n&#125;)\n\nnew Promise(resolve &#x3D;&gt;  &#123;\n  console.log(3)\n  resolve(4)\n&#125;).then(d &#x3D;&gt; console.log(d))\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(5)\n  new Promise(resolve &#x3D;&gt;  &#123;\n    resolve(6)\n  &#125;).then(d &#x3D;&gt; console.log(d))\n&#125;)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(7)\n&#125;)\n\nconsole.log(8)\n复制代码\n\n输出结果如下：\n1\n3\n8\n4\n2\n5\n6\n7\n复制代码\n\n代码执行过程如下：\n\n首先执行script代码，打印出1；\n遇到第一个定时器，加入到宏任务队列；\n遇到Promise，执行代码，打印出3，遇到resolve，将其加入到微任务队列；\n遇到第二个定时器，加入到宏任务队列；\n遇到第三个定时器，加入到宏任务队列；\n继续执行script代码，打印出8，第一轮执行结束；\n执行微任务队列，打印出第一个Promise的resolve结果：4；\n开始执行宏任务队列，执行第一个定时器，打印出2；\n此时没有微任务，继续执行宏任务中的第二个定时器，首先打印出5，遇到Promise，首选打印出6，遇到resolve，将其加入到微任务队列；\n执行微任务队列，打印出6；\n执行宏任务队列中的最后一个定时器，打印出7。\n\n29. 代码输出结果console.log(1);\n    \nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(2);\n  Promise.resolve().then(() &#x3D;&gt; &#123;\n    console.log(3)\n  &#125;);\n&#125;);\n\nnew Promise((resolve, reject) &#x3D;&gt; &#123;\n  console.log(4)\n  resolve(5)\n&#125;).then((data) &#x3D;&gt; &#123;\n  console.log(data);\n&#125;)\n\nsetTimeout(() &#x3D;&gt; &#123;\n  console.log(6);\n&#125;)\n\nconsole.log(7);\n复制代码\n\n代码输出结果如下：\n1\n4\n7\n5\n2\n3\n6\n复制代码\n\n代码执行过程如下：\n\n首先执行scrip代码，打印出1；\n遇到第一个定时器setTimeout，将其加入到宏任务队列；\n遇到Promise，执行里面的同步代码，打印出4，遇到resolve，将其加入到微任务队列；\n遇到第二个定时器setTimeout，将其加入到红任务队列；\n执行script代码，打印出7，至此第一轮执行完成；\n指定微任务队列中的代码，打印出resolve的结果：5；\n执行宏任务中的第一个定时器setTimeout，首先打印出2，然后遇到 Promise.resolve().then()，将其加入到微任务队列；\n执行完这个宏任务，就开始执行微任务队列，打印出3；\n继续执行宏任务队列中的第二个定时器，打印出6。\n\n30. 代码输出结果Promise.resolve().then(() &#x3D;&gt; &#123;\n    console.log(&#39;1&#39;);\n    throw &#39;Error&#39;;\n&#125;).then(() &#x3D;&gt; &#123;\n    console.log(&#39;2&#39;);\n&#125;).catch(() &#x3D;&gt; &#123;\n    console.log(&#39;3&#39;);\n    throw &#39;Error&#39;;\n&#125;).then(() &#x3D;&gt; &#123;\n    console.log(&#39;4&#39;);\n&#125;).catch(() &#x3D;&gt; &#123;\n    console.log(&#39;5&#39;);\n&#125;).then(() &#x3D;&gt; &#123;\n    console.log(&#39;6&#39;);\n&#125;);\n复制代码\n\n执行结果如下：\n1 \n3 \n5 \n6\n复制代码\n\n在这道题目中，我们需要知道，无论是thne还是catch中，只要throw 抛出了错误，就会被catch捕获，如果没有throw出错误，就被继续执行后面的then。\n31. 代码输出结果setTimeout(function () &#123;\n  console.log(1);\n&#125;, 100);\n\nnew Promise(function (resolve) &#123;\n  console.log(2);\n  resolve();\n  console.log(3);\n&#125;).then(function () &#123;\n  console.log(4);\n  new Promise((resove, reject) &#x3D;&gt; &#123;\n    console.log(5);\n    setTimeout(() &#x3D;&gt;  &#123;\n      console.log(6);\n    &#125;, 10);\n  &#125;)\n&#125;);\nconsole.log(7);\nconsole.log(8);\n复制代码\n\n输出结果为：\n2\n3\n7\n8\n4\n5\n6\n1\n复制代码\n\n代码执行过程如下：\n\n首先遇到定时器，将其加入到宏任务队列；\n遇到Promise，首先执行里面的同步代码，打印出2，遇到resolve，将其加入到微任务队列，执行后面同步代码，打印出3；\n继续执行script中的代码，打印出7和8，至此第一轮代码执行完成；\n执行微任务队列中的代码，首先打印出4，如遇到Promise，执行其中的同步代码，打印出5，遇到定时器，将其加入到宏任务队列中，此时宏任务队列中有两个定时器；\n执行宏任务队列中的代码，这里我们需要注意是的第一个定时器的时间为100ms，第二个定时器的时间为10ms，所以先执行第二个定时器，打印出6；\n此时微任务队列为空，继续执行宏任务队列，打印出1。\n\n做完这道题目，我们就需要格外注意，每个定时器的时间，并不是所有定时器的时间都为0哦。\n二、this1. 代码输出结果function foo() &#123;\n  console.log( this.a );\n&#125;\n\nfunction doFoo() &#123;\n  foo();\n&#125;\n\nvar obj &#x3D; &#123;\n  a: 1,\n  doFoo: doFoo\n&#125;;\n\nvar a &#x3D; 2; \nobj.doFoo()\n复制代码\n\n输出结果：2\n在Javascript中，this指向函数执行时的当前对象。在执行foo的时候，执行环境就是doFoo函数，执行环境为全局。所以，foo中的this是指向window的，所以会打印出2。\n2. 代码输出结果var a &#x3D; 10\nvar obj &#x3D; &#123;\n  a: 20,\n  say: () &#x3D;&gt; &#123;\n    console.log(this.a)\n  &#125;\n&#125;\nobj.say() \n\nvar anotherObj &#x3D; &#123; a: 30 &#125; \nobj.say.apply(anotherObj) \n复制代码\n\n输出结果：10 10\n我么知道，箭头函数时不绑定this的，它的this来自原其父级所处的上下文，所以首先会打印全局中的 a 的值10。后面虽然让say方法指向了另外一个对象，但是仍不能改变箭头函数的特性，它的this仍然是指向全局的，所以依旧会输出10。\n但是，如果是普通函数，那么就会有完全不一样的结果：\nvar a &#x3D; 10  \nvar obj &#x3D; &#123;  \n  a: 20,  \n  say()&#123;\n    console.log(this.a)  \n  &#125;  \n&#125;  \nobj.say()   \nvar anotherObj&#x3D;&#123;a:30&#125;   \nobj.say.apply(anotherObj)\n复制代码\n\n输出结果：20 30\n这时，say方法中的this就会指向他所在的对象，输出其中的a的值。\n3. 代码输出结果function a() &#123;\n  console.log(this);\n&#125;\na.call(null);\n复制代码\n\n打印结果：window对象\n根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。\n要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined：\n&#39;use strict&#39;;\n\nfunction a() &#123;\n    console.log(this);\n&#125;\na.call(null); &#x2F;&#x2F; null\na.call(undefined); &#x2F;&#x2F; undefined\n复制代码\n\n4. 代码输出结果var obj &#x3D; &#123; \n  name : &#39;cuggz&#39;, \n  fun : function()&#123; \n    console.log(this.name); \n  &#125; \n&#125; \nobj.fun()     &#x2F;&#x2F; cuggz\nnew obj.fun() &#x2F;&#x2F; undefined\n复制代码\n\n使用new构造函数时，其this指向的是全局环境window。\n6. 代码输出结果var obj &#x3D; &#123;\n   say: function() &#123;\n     var f1 &#x3D; () &#x3D;&gt;  &#123;\n       console.log(&quot;1111&quot;, this);\n     &#125;\n     f1();\n   &#125;,\n   pro: &#123;\n     getPro:() &#x3D;&gt;  &#123;\n        console.log(this);\n     &#125;\n   &#125;\n&#125;\nvar o &#x3D; obj.say;\no();\nobj.say();\nobj.pro.getPro();\n复制代码\n\n输出结果：\n1111 window对象\n1111 obj对象\nwindow对象\n复制代码\n\n解析：\n\no()，o是在全局执行的，而f1是箭头函数，它是没有绑定this的，它的this指向其父级的this，其父级say方法的this指向的是全局作用域，所以会打印出window；\nobj.say()，谁调用say，say 的this就指向谁，所以此时this指向的是obj对象；\nobj.pro.getPro()，我们知道，箭头函数时不绑定this的，getPro处于pro中，而对象不构成单独的作用域，所以箭头的函数的this就指向了全局作用域window。\n\n7. 代码输出结果var myObject &#x3D; &#123;\n    foo: &quot;bar&quot;,\n    func: function() &#123;\n        var self &#x3D; this;\n        console.log(this.foo);  \n        console.log(self.foo);  \n        (function() &#123;\n            console.log(this.foo);  \n            console.log(self.foo);  \n        &#125;());\n    &#125;\n&#125;;\nmyObject.func();\n复制代码\n\n输出结果：bar bar undefined bar\n解析：\n\n首先func是由myObject调用的，this指向myObject。又因为var self &#x3D; this;所以self指向myObject。\n这个立即执行匿名函数表达式是由window调用的，this指向window 。立即执行匿名函数的作用域处于myObject.func的作用域中，在这个作用域找不到self变量，沿着作用域链向上查找self变量，找到了指向 myObject对象的self。\n\n8. 代码输出问题window.number &#x3D; 2;\nvar obj &#x3D; &#123;\n number: 3,\n db1: (function()&#123;\n   console.log(this);\n   this.number *&#x3D; 4;\n   return function()&#123;\n     console.log(this);\n     this.number *&#x3D; 5;\n   &#125;\n &#125;)()\n&#125;\nvar db1 &#x3D; obj.db1;\ndb1();\nobj.db1();\nconsole.log(obj.number);     &#x2F;&#x2F; 15\nconsole.log(window.number);  &#x2F;&#x2F; 40\n复制代码\n\n这道题目看清起来有点乱，但是实际上是考察this指向的:\n\n执行db1()时，this指向全局作用域，所以window.number * 4 &#x3D; 8，然后执行匿名函数， 所以window.number * 5 &#x3D; 40；\n执行obj.db1();时，this指向obj对象，执行匿名函数，所以obj.numer * 5 &#x3D; 15。\n\n9. 代码输出结果var length &#x3D; 10;\nfunction fn() &#123;\n    console.log(this.length);\n&#125;\n \nvar obj &#x3D; &#123;\n  length: 5,\n  method: function(fn) &#123;\n    fn();\n    arguments[0]();\n  &#125;\n&#125;;\n \nobj.method(fn, 1);\n复制代码\n\n输出结果： 10 2\n解析：\n\n第一次执行fn()，this指向window对象，输出10。\n第二次执行arguments0，相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。\n\n10. 代码输出结果var a &#x3D; 1;\nfunction printA()&#123;\n  console.log(this.a);\n&#125;\nvar obj&#x3D;&#123;\n  a:2,\n  foo:printA,\n  bar:function()&#123;\n    printA();\n  &#125;\n&#125;\n\nobj.foo(); &#x2F;&#x2F; 2\nobj.bar(); &#x2F;&#x2F; 1\nvar foo &#x3D; obj.foo;\nfoo(); &#x2F;&#x2F; 1\n复制代码\n\n输出结果： 2 1 1\n解析：\n\nobj.foo()，foo 的this指向obj对象，所以a会输出2；\nobj.bar()，printA在bar方法中执行，所以此时printA的this指向的是window，所以会输出1；\nfoo()，foo是在全局对象中执行的，所以其this指向的是window，所以会输出1；\n\n11. 代码输出结果var x &#x3D; 3;\nvar y &#x3D; 4;\nvar obj &#x3D; &#123;\n    x: 1,\n    y: 6,\n    getX: function() &#123;\n        var x &#x3D; 5;\n        return function() &#123;\n            return this.x;\n        &#125;();\n    &#125;,\n    getY: function() &#123;\n        var y &#x3D; 7;\n        return this.y;\n    &#125;\n&#125;\nconsole.log(obj.getX()) &#x2F;&#x2F; 3\nconsole.log(obj.getY()) &#x2F;&#x2F; 6\n复制代码\n\n输出结果：3 6\n解析：\n\n我们知道，匿名函数的this是指向全局对象的，所以this指向window，会打印出3；\ngetY是由obj调用的，所以其this指向的是obj对象，会打印出6。\n\n12. 代码输出结果 var a &#x3D; 10; \n var obt &#x3D; &#123; \n   a: 20, \n   fn: function()&#123; \n     var a &#x3D; 30; \n     console.log(this.a)\n   &#125; \n &#125;\n obt.fn();  &#x2F;&#x2F; 20\n obt.fn.call(); &#x2F;&#x2F; 10\n (obt.fn)(); &#x2F;&#x2F; 20\n复制代码\n\n输出结果： 20 10 20\n解析：\n\n obt.fn()，fn是由obt调用的，所以其this指向obt对象，会打印出20；\n obt.fn.call()，这里call的参数啥都没写，就表示null，我们知道如果call的参数为undefined或null，那么this就会指向全局对象this，所以会打印出 10；\n (obt.fn)()， 这里给表达式加了括号，而括号的作用是改变表达式的运算顺序，而在这里加与不加括号并无影响；相当于  obt.fn()，所以会打印出 20；\n\n13. 代码输出结果function a(xx)&#123;\n  this.x &#x3D; xx;\n  return this\n&#125;;\nvar x &#x3D; a(5);\nvar y &#x3D; a(6);\n\nconsole.log(x.x)  &#x2F;&#x2F; undefined\nconsole.log(y.x)  &#x2F;&#x2F; 6\n复制代码\n\n输出结果： undefined 6\n解析：\n\n最关键的就是var x &#x3D; a(5)，函数a是在全局作用域调用，所以函数内部的this指向window对象。所以 this.x &#x3D; 5 就相当于：window.x &#x3D; 5。之后 return this，也就是说 var x &#x3D; a(5) 中的x变量的值是window，这里的x将函数内部的x的值覆盖了。然后执行console.log(x.x)， 也就是console.log(window.x)，而window对象中没有x属性，所以会输出undefined。\n当指向y.x时，会给全局变量中的x赋值为6，所以会打印出6。\n\n14. 代码输出结果function foo(something)&#123;\n    this.a &#x3D; something\n&#125;\n\nvar obj1 &#x3D; &#123;\n    foo: foo\n&#125;\n\nvar obj2 &#x3D; &#123;&#125;\n\nobj1.foo(2); \nconsole.log(obj1.a); &#x2F;&#x2F; 2\n\nobj1.foo.call(obj2, 3);\nconsole.log(obj2.a); &#x2F;&#x2F; 3\n\nvar bar &#x3D; new obj1.foo(4)\nconsole.log(obj1.a); &#x2F;&#x2F; 2\nconsole.log(bar.a); &#x2F;&#x2F; 4\n复制代码\n\n输出结果： 2 3 2 4\n解析：\n\n首先执行obj1.foo(2); 会在obj中添加a属性，其值为2。之后执行obj1.a，a是右obj1调用的，所以this指向obj，打印出2；\n执行 obj1.foo.call(obj2, 3) 时，会将foo的this指向obj2，后面就和上面一样了，所以会打印出3；\nobj1.a会打印出2；\n最后就是考察this绑定的优先级了，new 绑定是比隐式绑定优先级高，所以会输出4。\n\n15. 代码输出结果function foo(something)&#123;\n    this.a &#x3D; something\n&#125;\n\nvar obj1 &#x3D; &#123;&#125;\n\nvar bar &#x3D; foo.bind(obj1);\nbar(2);\nconsole.log(obj1.a); &#x2F;&#x2F; 2\n\nvar baz &#x3D; new bar(3);\nconsole.log(obj1.a); &#x2F;&#x2F; 2\nconsole.log(baz.a); &#x2F;&#x2F; 3\n复制代码\n\n输出结果： 2 2 3\n这道题目和上面题目差不多，主要都是考察this绑定的优先级。记住以下结论即可：this绑定的优先级：new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。\n三、作用域&amp;变量提升&amp;闭包1. 代码输出结果(function()&#123;\n   var x &#x3D; y &#x3D; 1;\n&#125;)();\nvar z;\n\nconsole.log(y); &#x2F;&#x2F; 1\nconsole.log(z); &#x2F;&#x2F; undefined\nconsole.log(x); &#x2F;&#x2F; Uncaught ReferenceError: x is not defined\n复制代码\n\n这段代码的关键在于：var x &#x3D; y &#x3D; 1; 实际上这里是从右往左执行的，首先执行y &#x3D; 1, 因为y没有使用var声明，所以它是一个全局变量，然后第二步是将y赋值给x，讲一个全局变量赋值给了一个局部变量，最终，x是一个局部变量，y是一个全局变量，所以打印x是报错。\n2. 代码输出结果var a, b\n(function () &#123;\n   console.log(a);\n   console.log(b);\n   var a &#x3D; (b &#x3D; 3);\n   console.log(a);\n   console.log(b);   \n&#125;)()\nconsole.log(a);\nconsole.log(b);\n复制代码\n\n输出结果：\nundefined \nundefined \n3 \n3 \nundefined \n3\n复制代码\n\n这个题目和上面题目考察的知识点类似，b赋值为3，b此时是一个全局变量，而将3赋值给a，a是一个局部变量，所以最后打印的时候，a仍旧是undefined。\n3. 代码输出结果var friendName &#x3D; &#39;World&#39;;\n(function() &#123;\n  if (typeof friendName &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n    var friendName &#x3D; &#39;Jack&#39;;\n    console.log(&#39;Goodbye &#39; + friendName);\n  &#125; else &#123;\n    console.log(&#39;Hello &#39; + friendName);\n  &#125;\n&#125;)();\n复制代码\n\n输出结果：Goodbye Jack\n我们知道，在 JavaScript中， Function 和 var 都会被提升（变量提升），所以上面的代码就相当于：\nvar name &#x3D; &#39;World!&#39;;\n(function () &#123;\n    var name;\n    if (typeof name &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n        name &#x3D; &#39;Jack&#39;;\n        console.log(&#39;Goodbye &#39; + name);\n    &#125; else &#123;\n        console.log(&#39;Hello &#39; + name);\n    &#125;\n&#125;)();\n复制代码\n\n这样，答案就一目了然了。\n4. 代码输出结果function fn1()&#123;\n  console.log(&#39;fn1&#39;)\n&#125;\nvar fn2\n \nfn1()\nfn2()\n \nfn2 &#x3D; function() &#123;\n  console.log(&#39;fn2&#39;)\n&#125;\n \nfn2()\n复制代码\n\n输出结果：\nfn1\nUncaught TypeError: fn2 is not a function\nfn2\n复制代码\n\n这里也是在考察变量提升，关键在于第一个fn2()，这时fn2仍是一个undefined的变量，所以会报错fn2不是一个函数。\n5. 代码输出结果function a() &#123;\n    var temp &#x3D; 10;\n    function b() &#123;\n        console.log(temp); &#x2F;&#x2F; 10\n    &#125;\n    b();\n&#125;\na();\n\nfunction a() &#123;\n    var temp &#x3D; 10;\n    b();\n&#125;\nfunction b() &#123;\n    console.log(temp); &#x2F;&#x2F; 报错 Uncaught ReferenceError: temp is not defined\n&#125;\na();\n复制代码\n\n在上面的两段代码中，第一段是可以正常输出，这个应该没啥问题，关键在于第二段代码，它会报错Uncaught ReferenceError: temp is not defined。这时因为在b方法执行时，temp 的值为undefined。\n6. 代码输出结果 var a&#x3D;3;\n function c()&#123;\n    alert(a);\n &#125;\n (function()&#123;\n  var a&#x3D;4;\n  c();\n &#125;)();\n复制代码\n\njs中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等\n7. 代码输出问题function fun(n, o) &#123;\n  console.log(o)\n  return &#123;\n    fun: function(m)&#123;\n      return fun(m, n);\n    &#125;\n  &#125;;\n&#125;\nvar a &#x3D; fun(0);  a.fun(1);  a.fun(2);  a.fun(3);\nvar b &#x3D; fun(0).fun(1).fun(2).fun(3);\nvar c &#x3D; fun(0).fun(1);  c.fun(2);  c.fun(3);\n复制代码\n\n输出结果：\nundefined  0  0  0\nundefined  0  1  2\nundefined  0  1  1\n复制代码\n\n这是一道关于闭包的题目，对于fun方法，调用之后返回的是一个对象。我们知道，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。所以 console.log(o); 会输出undefined。而a就是是fun(0)返回的那个对象。也就是说，函数fun中参数 n 的值是0，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0。了解了这一点，其他运算就很简单了，以此类推。\n8. 代码输出结果f &#x3D; function() &#123;return true;&#125;;   \ng &#x3D; function() &#123;return false;&#125;;   \n(function() &#123;   \n   if (g() &amp;&amp; [] &#x3D;&#x3D; ![]) &#123;   \n      f &#x3D; function f() &#123;return false;&#125;;   \n      function g() &#123;return true;&#125;   \n   &#125;   \n&#125;)();   \nconsole.log(f());\n复制代码\n\n输出结果： false\n这里首先定义了两个变量f和g，我们知道变量是可以重新赋值的。后面是一个匿名自执行函数，在 if 条件中调用了函数 g()，由于在匿名函数中，又重新定义了函数g，就覆盖了外部定义的变量g，所以，这里调用的是内部函数 g 方法，返回为 true。第一个条件通过，进入第二个条件。\n第二个条件是[] &#x3D;&#x3D; ![]，先看 ![] ，在 JavaScript 中，当用于布尔运算时，比如在这里，对象的非空引用被视为 true，空引用 null 则被视为 false。由于这里不是一个 null, 而是一个没有元素的数组，所以 [] 被视为 true, 而 ![] 的结果就是 false 了。当一个布尔值参与到条件运算的时候，true 会被看作 1, 而 false 会被看作 0。现在条件变成了 [] &#x3D;&#x3D; 0 的问题了，当一个对象参与条件比较的时候，它会被求值，求值的结果是数组成为一个字符串，[] 的结果就是 ‘’ ，而 ‘’ 会被当作 0 ，所以，条件成立。\n两个条件都成立，所以会执行条件中的代码， f 在定义是没有使用var，所以他是一个全局变量。因此，这里会通过闭包访问到外部的变量 f, 重新赋值，现在执行 f 函数返回值已经成为 false 了。而 g 则不会有这个问题，这里是一个函数内定义的 g，不会影响到外部的 g 函数。所以最后的结果就是 false。\n四、原型&amp;继承1. 代码输出结果function Person(name) &#123;\n    this.name &#x3D; name\n&#125;\nvar p2 &#x3D; new Person(&#39;king&#39;);\nconsole.log(p2.__proto__) &#x2F;&#x2F;Person.prototype\nconsole.log(p2.__proto__.__proto__) &#x2F;&#x2F;Object.prototype\nconsole.log(p2.__proto__.__proto__.__proto__) &#x2F;&#x2F; null\nconsole.log(p2.__proto__.__proto__.__proto__.__proto__)&#x2F;&#x2F;null后面没有了，报错\nconsole.log(p2.__proto__.__proto__.__proto__.__proto__.__proto__)&#x2F;&#x2F;null后面没有了，报错\nconsole.log(p2.constructor)&#x2F;&#x2F;Person\nconsole.log(p2.prototype)&#x2F;&#x2F;undefined p2是实例，没有prototype属性\nconsole.log(Person.constructor)&#x2F;&#x2F;Function 一个空函数\nconsole.log(Person.prototype)&#x2F;&#x2F;打印出Person.prototype这个对象里所有的方法和属性\nconsole.log(Person.prototype.constructor)&#x2F;&#x2F;Person\nconsole.log(Person.prototype.__proto__)&#x2F;&#x2F; Object.prototype\nconsole.log(Person.__proto__) &#x2F;&#x2F;Function.prototype\nconsole.log(Function.prototype.__proto__)&#x2F;&#x2F;Object.prototype\nconsole.log(Function.__proto__)&#x2F;&#x2F;Function.prototype\nconsole.log(Object.__proto__)&#x2F;&#x2F;Function.prototype\nconsole.log(Object.prototype.__proto__)&#x2F;&#x2F;null\n复制代码\n\n这道义题目考察原型、原型链的基础，记住就可以了。\n2. 代码输出结果&#x2F;&#x2F; a\nfunction Foo () &#123;\n getName &#x3D; function () &#123;\n   console.log(1);\n &#125;\n return this;\n&#125;\n&#x2F;&#x2F; b\nFoo.getName &#x3D; function () &#123;\n console.log(2);\n&#125;\n&#x2F;&#x2F; c\nFoo.prototype.getName &#x3D; function () &#123;\n console.log(3);\n&#125;\n&#x2F;&#x2F; d\nvar getName &#x3D; function () &#123;\n console.log(4);\n&#125;\n&#x2F;&#x2F; e\nfunction getName () &#123;\n console.log(5);\n&#125;\n\nFoo.getName();           &#x2F;&#x2F; 2\ngetName();               &#x2F;&#x2F; 4\nFoo().getName();         &#x2F;&#x2F; 1\ngetName();               &#x2F;&#x2F; 1 \nnew Foo.getName();       &#x2F;&#x2F; 2\nnew Foo().getName();     &#x2F;&#x2F; 3\nnew new Foo().getName(); &#x2F;&#x2F; 3\n复制代码\n\n输出结果：2 4 1 1 2 3 3\n解析：\n\nFoo.getName()， Foo为一个函数对象，对象都可以有属性，b 处定义Foo的getName属性为函数，输出2；\ngetName()， 这里看d、e处，d为函数表达式，e为函数声明，两者区别在于变量提升，函数声明的 5 会被后边函数表达式的 4 覆盖；\n** Foo().getName()，** 这里要看a处，在Foo内部将全局的getName重新赋值为 console.log(1) 的函数，执行Foo()返回 this，这个this指向window，Foo().getName() 即为window.getName()，输出 1；\ngetName()， 上面3中，全局的getName已经被重新赋值，所以这里依然输出 1；\nnew Foo.getName()， 这里等价于 new (Foo.getName())，先执行 Foo.getName()，输出 2，然后new一个实例；\nnew Foo().getName()， 这 里等价于 (new Foo()).getName(), 先new一个Foo的实例，再执行这个实例的getName方法，但是这个实例本身没有这个方法，所以去原型链__protot__上边找，实例.protot &#x3D;&#x3D;&#x3D; Foo.prototype，所以输出 3；\nnew new Foo().getName()， 这里等价于new (new Foo().getName())，如上述6，先输出 3，然后new 一个 new Foo().getName() 的实例。\n\n3. 代码输出结果var F &#x3D; function() &#123;&#125;;\nObject.prototype.a &#x3D; function() &#123;\n  console.log(&#39;a&#39;);\n&#125;;\nFunction.prototype.b &#x3D; function() &#123;\n  console.log(&#39;b&#39;);\n&#125;\nvar f &#x3D; new F();\nf.a();\nf.b();\nF.a();\nF.b()\n复制代码\n\n输出结果：\na\nUncaught TypeError: f.b is not a function\na\nb\n复制代码\n\n解析：\n\nf 并不是 Function 的实例，因为它本来就不是构造函数，调用的是 Function 原型链上的相关属性和方法，只能访问到 Object 原型链。所以 f.a() 输出 a  ，而 f.b() 就报错了。\nF 是个构造函数，而 F 是构造函数 Function 的一个实例。因为 F instanceof  Object &#x3D;&#x3D;&#x3D; true，F instanceof Function &#x3D;&#x3D;&#x3D; true，由此可以得出结论：F 是 Object 和 Function 两个的实例，即 F 能访问到 a， 也能访问到 b。所以 F.a() 输出 a ，F.b() 输出 b。\n\n4. 代码输出结果function Foo()&#123;\n    Foo.a &#x3D; function()&#123;\n        console.log(1);\n    &#125;\n    this.a &#x3D; function()&#123;\n        console.log(2)\n    &#125;\n&#125;\n\nFoo.prototype.a &#x3D; function()&#123;\n    console.log(3);\n&#125;\n\nFoo.a &#x3D; function()&#123;\n    console.log(4);\n&#125;\n\nFoo.a();\nlet obj &#x3D; new Foo();\nobj.a();\nFoo.a();\n复制代码\n\n输出结果：4 2 1\n解析：\n\nFoo.a() 这个是调用 Foo 函数的静态方法 a，虽然 Foo 中有优先级更高的属性方法 a，但 Foo 此时没有被调用，所以此时输出 Foo 的静态方法 a 的结果：4\nlet obj &#x3D; new Foo(); 使用了 new 方法调用了函数，返回了函数实例对象，此时 Foo 函数内部的属性方法初始化，原型链建立。\nobj.a() ; 调用 obj 实例上的方法 a，该实例上目前有两个 a 方法：一个是内部属性方法，另一个是原型上的方法。当这两者都存在时，首先查找 ownProperty ，如果没有才去原型链上找，所以调用实例上的 a 输出：2\nFoo.a() ; 根据第2步可知 Foo 函数内部的属性方法已初始化，覆盖了同名的静态方法，所以输出：1\n\n5. 代码输出结果function Dog() &#123;\n  this.name &#x3D; &#39;puppy&#39;\n&#125;\nDog.prototype.bark &#x3D; () &#x3D;&gt; &#123;\n  console.log(&#39;woof!woof!&#39;)\n&#125;\nconst dog &#x3D; new Dog()\nconsole.log(Dog.prototype.constructor &#x3D;&#x3D;&#x3D; Dog &amp;&amp; dog.constructor &#x3D;&#x3D;&#x3D; Dog &amp;&amp; dog instanceof Dog)\n复制代码\n\n输出结果：true\n解析： 因为constructor是prototype上的属性，所以dog.constructor实际上就是指向Dog.prototype.constructor；constructor属性指向构造函数。instanceof而实际检测的是类型是否在实例的原型链上。\nconstructor是prototype上的属性，这一点很容易被忽略掉。constructor和instanceof 的作用是不同的，感性地来说，constructor的限制比较严格，它只能严格对比对象的构造函数是不是指定的值；而instanceof比较松散，只要检测的类型在原型链上，就会返回true。\n6. 代码输出结果var A &#x3D; &#123;n: 4399&#125;;\nvar B &#x3D;  function()&#123;this.n &#x3D; 9999&#125;;\nvar C &#x3D;  function()&#123;var n &#x3D; 8888&#125;;\nB.prototype &#x3D; A;\nC.prototype &#x3D; A;\nvar b &#x3D; new B();\nvar c &#x3D; new C();\nA.n++\nconsole.log(b.n);\nconsole.log(c.n);\n复制代码\n\n输出结果：9999 4400\n解析：\n\nconsole.log(b.n)，在查找b.n是首先查找 b 对象自身有没有 n 属性，如果没有会去原型（prototype）上查找，当执行var b &#x3D; new B()时，函数内部this.n&#x3D;9999(此时this指向 b) 返回b对象，b对象有自身的n属性，所以返回 9999。\nconsole.log(c.n)，同理，当执行var c &#x3D; new C()时，c对象没有自身的n属性，向上查找，找到原型 （prototype）上的 n 属性，因为 A.n++(此时对象A中的n为4400)， 所以返回4400。\n\n7. 代码输出问题function A()&#123;\n&#125;\nfunction B(a)&#123;\n　　this.a &#x3D; a;\n&#125;\nfunction C(a)&#123;\n　　if(a)&#123;\nthis.a &#x3D; a;\n　　&#125;\n&#125;\nA.prototype.a &#x3D; 1;\nB.prototype.a &#x3D; 1;\nC.prototype.a &#x3D; 1;\n \nconsole.log(new A().a);\nconsole.log(new B().a);\nconsole.log(new C(2).a);\n复制代码\n\n输出结果：1 undefined 2\n解析：\n\nconsole.log(new A().a)，new A()为构造函数创建的对象，本身没有a属性，所以向它的原型去找，发现原型的a属性的属性值为1，故该输出值为1；\nconsole.log(new B().a)，ew B()为构造函数创建的对象，该构造函数有参数a，但该对象没有传参，故该输出值为undefined;\nconsole.log(new C(2).a)，new C()为构造函数创建的对象，该构造函数有参数a，且传的实参为2，执行函数内部，发现if为真，执行this.a &#x3D; 2,故属性a的值为2。\n\n8 代码输出问题function Parent() &#123;\n    this.a &#x3D; 1;\n    this.b &#x3D; [1, 2, this.a];\n    this.c &#x3D; &#123; demo: 5 &#125;;\n    this.show &#x3D; function () &#123;\n        console.log(this.a , this.b , this.c.demo );\n    &#125;\n&#125;\n\nfunction Child() &#123;\n    this.a &#x3D; 2;\n    this.change &#x3D; function () &#123;\n        this.b.push(this.a);\n        this.a &#x3D; this.b.length;\n        this.c.demo &#x3D; this.a++;\n    &#125;\n&#125;\n\nChild.prototype &#x3D; new Parent();\nvar parent &#x3D; new Parent();\nvar child1 &#x3D; new Child();\nvar child2 &#x3D; new Child();\nchild1.a &#x3D; 11;\nchild2.a &#x3D; 12;\nparent.show();\nchild1.show();\nchild2.show();\nchild1.change();\nchild2.change();\nparent.show();\nchild1.show();\nchild2.show();\n复制代码\n\n输出结果：\nparent.show(); &#x2F;&#x2F; 1  [1,2,1] 5\n\nchild1.show(); &#x2F;&#x2F; 11 [1,2,1] 5\nchild2.show(); &#x2F;&#x2F; 12 [1,2,1] 5\n\nparent.show(); &#x2F;&#x2F; 1 [1,2,1] 5\n\nchild1.show(); &#x2F;&#x2F; 5 [1,2,1,11,12] 5\n\nchild2.show(); &#x2F;&#x2F; 6 [1,2,1,11,12] 5\n复制代码\n\n这道题目值得神帝，他涉及到的知识点很多，例如this的指向、原型、原型链、类的继承、数据类型等。\n解析：\n\nparent.show()，可以直接获得所需的值，没啥好说的；\nchild1.show()，Child的构造函数原本是指向Child的，题目显式将Child类的原型对象指向了Parent类的一个实例，需要注意Child.prototype指向的是Parent的实例parent，而不是指向Parent这个类。\nchild2.show()，这个也没啥好说的；\nparent.show()，parent是一个Parent类的实例，Child.prorotype指向的是Parent类的另一个实例，两者在堆内存中互不影响，所以上述操作不影响parent实例，所以输出结果不变；\nchild1.show()，child1执行了change()方法后，发生了怎样的变化呢?\n\n\nthis.b.push(this.a)，由于this的动态指向特性，this.b会指向Child.prototype上的b数组,this.a会指向child1的a属性,所以Child.prototype.b变成了**[1,2,1,11]**;\nthis.a &#x3D; this.b.length，这条语句中this.a和this.b的指向与上一句一致，故结果为child1.a变为4;\nthis.c.demo &#x3D; this.a++，由于child1自身属性并没有c这个属性，所以此处的this.c会指向Child.prototype.c，this.a值为4，为原始类型，故赋值操作时会直接赋值，Child.prototype.c.demo的结果为4，而this.a随后自增为5(4 + 1 &#x3D; 5)。\n\n\nchild2执行了change()方法, 而child2和child1均是Child类的实例，所以他们的原型链指向同一个原型对象Child.prototype,也就是同一个parent实例，所以child2.change()中所有影响到原型对象的语句都会影响child1的最终输出结果。\n\n\nthis.b.push(this.a)，由于this的动态指向特性，this.b会指向Child.prototype上的b数组,this.a会指向child2的a属性,所以Child.prototype.b变成了**[1,2,1,11,12]**;\nthis.a &#x3D; this.b.length，这条语句中this.a和this.b的指向与上一句一致，故结果为child2.a变为5;\nthis.c.demo &#x3D; this.a++，由于child2自身属性并没有c这个属性，所以此处的this.c会指向Child.prototype.c，故执行结果为Child.prototype.c.demo的值变为child2.a的值5，而child2.a最终自增为6(5 + 1 &#x3D; 6)。\n\n9. 代码输出结果function SuperType()&#123;\n    this.property &#x3D; true;\n&#125;\n\nSuperType.prototype.getSuperValue &#x3D; function()&#123;\n    return this.property;\n&#125;;\n\nfunction SubType()&#123;\n    this.subproperty &#x3D; false;\n&#125;\n\nSubType.prototype &#x3D; new SuperType();\nSubType.prototype.getSubValue &#x3D; function ()&#123;\n    return this.subproperty;\n&#125;;\n\nvar instance &#x3D; new SubType();\nconsole.log(instance.getSuperValue());\n复制代码\n\n输出结果：true\n实际上，这段代码就是在实现原型链继承，SubType继承了SuperType，本质是重写了SubType的原型对象，代之以一个新类型的实例。SubType的原型被重写了，所以instance.constructor指向的是SuperType。具体如下： \n","slug":"面试题笔记——代码输出结果篇","date":"2022-06-25T10:41:12.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"b9b334bea88dfba73a4e01092c68ab76","title":"性能优化常用方案","content":"一、CDN1. CDN的概念CDN（Content Delivery Network，内容分发网络）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。\n典型的CDN系统由下面三个部分组成：\n\n分发服务系统： 最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标。\n负载均衡系统： 主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。全局负载均衡主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。本地负载均衡主要负责节点内部的设备负载均衡\n运营管理系统： 运营管理系统分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。\n\n2. CDN的作用CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。\n（1）在性能方面，引入CDN的作用在于：\n\n用户收到的内容来自最近的数据中心，延迟更低，内容加载更快\n部分资源请求分配给了CDN，减少了服务器的负载\n\n（2）在安全方面，CDN有助于防御DDoS、MITM等网络攻击：\n\n针对DDoS：通过监控分析异常流量，限制其请求频率\n针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信\n\n除此之外，CDN作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。\n3. CDN的原理CDN和DNS有着密不可分的联系，先来看一下DNS的解析域名过程，在浏览器输入 www.test.com 的解析过程如下： （1） 检查浏览器缓存 （2）检查操作系统缓存，常见的如hosts文件 （3）检查路由器缓存 （4）如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询 （5）如果LDNS服务器没找到，会向根域名服务器(Root Server)请求解析，分为以下几步：\n\n根服务器返回顶级域名(TLD)服务器如.com，.cn，.org等的地址，该例子中会返回.com的地址\n接着向顶级域名服务器发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回.test的地址\n接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标IP，本例子会返回www.test.com的地址\nLocal DNS Server会缓存结果，并返回给用户，缓存在系统中\n\nCDN的工作原理： （1）用户未使用CDN缓存资源的过程：\n\n浏览器通过DNS对域名进行解析（就是上面的DNS解析过程），依次得到此域名对应的IP地址\n浏览器根据得到的IP地址，向域名的服务主机发送数据请求\n服务器向浏览器返回响应数据\n\n（2）用户使用CDN缓存资源的过程：\n\n对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。\nCND专用DNS服务器将CND的全局负载均衡设备IP地址返回给用户\n用户向CDN的全局负载均衡设备发起数据请求\nCDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求\n区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备\n全局负载均衡设备把服务器的IP地址返回给用户\n用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。\n\n如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。\n CNAME（意为：别名）：在域名解析中，实际上解析出来的指定域名对应的IP地址，或者该域名的一个CNAME，然后再根据这个CNAME来查找对应的IP地址。\n4. CDN的使用场景\n使用第三方的CDN服务：如果想要开源一些项目，可以使用第三方的CDN服务\n使用CDN进行静态资源的缓存：将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。\n直播传送：直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。\n\n二、懒加载1. 懒加载的概念懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。\n如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。\n2. 懒加载的特点\n减少无用资源的加载：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。\n提升用户体验: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。\n防止加载过多图片而影响其他资源文件的加载 ：会影响网站应用的正常使用。\n\n3. 懒加载的实现原理图片的加载是由src引起的，当对src赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的data-xxx属性来储存图片的路径，在需要加载图片的时候，将data-xxx中图片的路径赋值给src，这样就实现了图片的按需加载，即懒加载。\n注意：data-xxx 中的xxx可以自定义，这里我们使用data-src来定义。\n懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。\n使用原生JavaScript实现懒加载：\n知识点：\n（1）window.innerHeight 是浏览器可视区的高度\n（2）document.body.scrollTop || document.documentElement.scrollTop 是浏览器滚动的过的距离\n（3）imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）\n（4）图片加载条件：img.offsetTop &lt; window.innerHeight + document.body.scrollTop;\n图示：  代码实现：\n&lt;div class&#x3D;&quot;container&quot;&gt;\n     &lt;img src&#x3D;&quot;loading.gif&quot;  data-src&#x3D;&quot;pic.png&quot;&gt;\n     &lt;img src&#x3D;&quot;loading.gif&quot;  data-src&#x3D;&quot;pic.png&quot;&gt;\n     &lt;img src&#x3D;&quot;loading.gif&quot;  data-src&#x3D;&quot;pic.png&quot;&gt;\n     &lt;img src&#x3D;&quot;loading.gif&quot;  data-src&#x3D;&quot;pic.png&quot;&gt;\n     &lt;img src&#x3D;&quot;loading.gif&quot;  data-src&#x3D;&quot;pic.png&quot;&gt;\n     &lt;img src&#x3D;&quot;loading.gif&quot;  data-src&#x3D;&quot;pic.png&quot;&gt;\n&lt;&#x2F;div&gt;\n&lt;script&gt;\nvar imgs &#x3D; document.querySelectorAll(&#39;img&#39;);\nfunction lozyLoad()&#123;\n\t\tvar scrollTop &#x3D; document.body.scrollTop || document.documentElement.scrollTop;\n\t\tvar winHeight&#x3D; window.innerHeight;\n\t\tfor(var i&#x3D;0;i &lt; imgs.length;i++)&#123;\n\t\t\tif(imgs[i].offsetTop &lt; scrollTop + winHeight )&#123;\n\t\t\t\timgs[i].src &#x3D; imgs[i].getAttribute(&#39;data-src&#39;);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n  window.onscroll &#x3D; lozyLoad();\n&lt;&#x2F;script&gt;\n复制代码\n\n4. 懒加载与预加载的区别这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。\n预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。 通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。\n\n三、回流与重绘1. 回流与重绘的概念及触发条件（1）回流当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。\n下面这些操作会导致回流：\n\n页面的首次渲染\n浏览器的窗口大小发生变化\n元素的内容发生变化\n元素的尺寸或者位置发生变化\n元素的字体大小发生变化\n激活CSS伪类\n查询某些属性或者调用某些方法\n添加或者删除可见的DOM元素\n\n在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：\n\n全局范围：从根节点开始，对整个渲染树进行重新布局\n局部范围：对渲染树的某部分或者一个渲染对象进行重新布局\n\n（2）重绘当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。\n下面这些操作会导致回流：\n\ncolor、background 相关属性：background-color、background-image 等\noutline 相关属性：outline-color、outline-width 、text-decoration\nborder-radius、visibility、box-shadow\n\n注意： 当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。\n2. 如何避免回流与重绘？减少回流与重绘的措施：\n\n操作DOM时，尽量在低层级的DOM节点进行操作\n不要使用table布局， 一个小的改动可能会使整个table进行重新布局\n使用CSS的表达式\n不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。\n使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素\n避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中\n将元素先设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。\n将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。\n\n浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列\n浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。\n上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。\n3. 如何优化动画？对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的position属性设置为absolute或者fixed，将动画脱离文档流，这样他的回流就不会影响到页面了。\n4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？MDN中对documentFragment的解释：\n\n\n\n\n\n\n\n\n\nDocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。\n当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将DocumentFragment 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。\n四、节流与防抖1. 对节流与防抖的理解\n函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\n函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。\n\n防抖函数的应用场景：\n\n按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次\n服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce\n\n节流函数的适⽤场景：\n\n拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动\n缩放场景：监控浏览器resize\n动画场景：避免短时间内多次触发动画引起性能问题\n\n2. 实现节流函数和防抖函数函数防抖的实现：\nfunction debounce(fn, wait) &#123;\n  var timer &#x3D; null;\n\n  return function() &#123;\n    var context &#x3D; this,\n      args &#x3D; [...arguments];\n\n    &#x2F;&#x2F; 如果此时存在定时器的话，则取消之前的定时器重新记时\n    if (timer) &#123;\n      clearTimeout(timer);\n      timer &#x3D; null;\n    &#125;\n\n    &#x2F;&#x2F; 设置定时器，使事件间隔指定事件后执行\n    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n      fn.apply(context, args);\n    &#125;, wait);\n  &#125;;\n&#125;\n复制代码\n\n函数节流的实现：\n&#x2F;&#x2F; 时间戳版\nfunction throttle(fn, delay) &#123;\n  var preTime &#x3D; Date.now();\n\n  return function() &#123;\n    var context &#x3D; this,\n      args &#x3D; [...arguments],\n      nowTime &#x3D; Date.now();\n\n    &#x2F;&#x2F; 如果两次时间间隔超过了指定时间，则执行函数。\n    if (nowTime - preTime &gt;&#x3D; delay) &#123;\n      preTime &#x3D; Date.now();\n      return fn.apply(context, args);\n    &#125;\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; 定时器版\nfunction throttle (fun, wait)&#123;\n  let timeout &#x3D; null\n  return function()&#123;\n    let context &#x3D; this\n    let args &#x3D; [...arguments]\n    if(!timeout)&#123;\n      timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;\n        fun.apply(context, args)\n        timeout &#x3D; null \n      &#125;, wait)\n    &#125;\n  &#125;\n&#125;\n复制代码\n\n五、图片优化1. 如何对项目中的图片进行优化？\n不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。\n\n对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。\n\n小图使用 base64 格式\n\n将多个图标文件整合到一张图片中（雪碧图）\n\n选择正确的图片格式：\n\n对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好\n小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替\n照片使用 JPEG\n\n\n\n2. 常见的图片格式及使用场景（1）BMP，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。\n（2）GIF是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。\n（3）JPEG是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。\n（4）PNG-8是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。\n（5）PNG-24是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。\n（6）SVG是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制Logo、Icon等。\n（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。\n\n在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；\n在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；\nWebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。\n\n六、Webpack优化1. 如何提⾼webpack的打包速度?（1）优化 Loader对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，这是可以优化的。\n首先我们优化 Loader 的文件搜索范围\nmodule.exports &#x3D; &#123;\n  module: &#123;\n    rules: [\n      &#123;\n        &#x2F;&#x2F; js 文件才使用 babel\n        test: &#x2F;.js$&#x2F;,\n        loader: &#39;babel-loader&#39;,\n        &#x2F;&#x2F; 只在 src 文件夹下查找\n        include: [resolve(&#39;src&#39;)],\n        &#x2F;&#x2F; 不会去查找的路径\n        exclude: &#x2F;node_modules&#x2F;\n      &#125;\n    ]\n  &#125;\n&#125;\n复制代码\n\n对于 Babel 来说，希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。\n当然这样做还不够，还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间\nloader: &#39;babel-loader?cacheDirectory&#x3D;true&#39;\n复制代码\n\n（2）HappyPack受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。\nHappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了\nmodule: &#123;\n  loaders: [\n    &#123;\n      test: &#x2F;.js$&#x2F;,\n      include: [resolve(&#39;src&#39;)],\n      exclude: &#x2F;node_modules&#x2F;,\n      &#x2F;&#x2F; id 后面的内容对应下面\n      loader: &#39;happypack&#x2F;loader?id&#x3D;happybabel&#39;\n    &#125;\n  ]\n&#125;,\nplugins: [\n  new HappyPack(&#123;\n    id: &#39;happybabel&#39;,\n    loaders: [&#39;babel-loader?cacheDirectory&#39;],\n    &#x2F;&#x2F; 开启 4 个线程\n    threads: 4\n  &#125;)\n]\n复制代码\n\n（3）DllPluginDllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。DllPlugin的使用方法如下：\n&#x2F;&#x2F; 单独配置在一个文件中\n&#x2F;&#x2F; webpack.dll.conf.js\nconst path &#x3D; require(&#39;path&#39;)\nconst webpack &#x3D; require(&#39;webpack&#39;)\nmodule.exports &#x3D; &#123;\n  entry: &#123;\n    &#x2F;&#x2F; 想统一打包的类库\n    vendor: [&#39;react&#39;]\n  &#125;,\n  output: &#123;\n    path: path.join(__dirname, &#39;dist&#39;),\n    filename: &#39;[name].dll.js&#39;,\n    library: &#39;[name]-[hash]&#39;\n  &#125;,\n  plugins: [\n    new webpack.DllPlugin(&#123;\n      &#x2F;&#x2F; name 必须和 output.library 一致\n      name: &#39;[name]-[hash]&#39;,\n      &#x2F;&#x2F; 该属性需要与 DllReferencePlugin 中一致\n      context: __dirname,\n      path: path.join(__dirname, &#39;dist&#39;, &#39;[name]-manifest.json&#39;)\n    &#125;)\n  ]\n&#125;\n复制代码\n\n然后需要执行这个配置文件生成依赖文件，接下来需要使用 DllReferencePlugin 将依赖文件引入项目中\n&#x2F;&#x2F; webpack.conf.js\nmodule.exports &#x3D; &#123;\n  &#x2F;&#x2F; ...省略其他配置\n  plugins: [\n    new webpack.DllReferencePlugin(&#123;\n      context: __dirname,\n      &#x2F;&#x2F; manifest 就是之前打包出来的 json 文件\n      manifest: require(&#39;.&#x2F;dist&#x2F;vendor-manifest.json&#39;),\n    &#125;)\n  ]\n&#125;\n复制代码\n\n（4）代码压缩在 Webpack3 中，一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 webpack-parallel-uglify-plugin 来并行运行 UglifyJS，从而提高效率。\n在 Webpack4 中，不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。\n（5）其他可以通过一些小的优化点来加快打包速度\n\nresolve.extensions：用来表明文件后缀列表，默认查找顺序是 [&#39;.js&#39;, &#39;.json&#39;]，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面\nresolve.alias：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径\nmodule.noParse：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助\n\n2. 如何减少 Webpack 打包体积（1）按需加载在开发 SPA 项目的时候，项目中都会存在很多路由页面。如果将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，希望首页能加载的文件体积越小越好，这时候就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。\n按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 Promise，当 Promise 成功以后去执行回调。\n（2）Scope HoistingScope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。\n比如希望打包两个文件：\n&#x2F;&#x2F; test.js\nexport const a &#x3D; 1\n&#x2F;&#x2F; index.js\nimport &#123; a &#125; from &#39;.&#x2F;test.js&#39;\n复制代码\n\n对于这种情况，打包出来的代码会类似这样：\n[\n  &#x2F;* 0 *&#x2F;\n  function (module, exports, require) &#123;\n    &#x2F;&#x2F;...\n  &#125;,\n  &#x2F;* 1 *&#x2F;\n  function (module, exports, require) &#123;\n    &#x2F;&#x2F;...\n  &#125;\n]\n复制代码\n\n但是如果使用 Scope Hoisting ，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码：\n[\n  &#x2F;* 0 *&#x2F;\n  function (module, exports, require) &#123;\n    &#x2F;&#x2F;...\n  &#125;\n]\n复制代码\n\n这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了：\nmodule.exports &#x3D; &#123;\n  optimization: &#123;\n    concatenateModules: true\n  &#125;\n&#125;\n复制代码\n\n（3）Tree ShakingTree Shaking 可以实现删除项目中未被引用的代码，比如：\n&#x2F;&#x2F; test.js\nexport const a &#x3D; 1\nexport const b &#x3D; 2\n&#x2F;&#x2F; index.js\nimport &#123; a &#125; from &#39;.&#x2F;test.js&#39;\n复制代码\n\n对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。\n如果使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。\n3. 如何⽤webpack来优化前端性能？⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。\n\n压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css\n利⽤CDN加速: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径\nTree Shaking: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 –optimize-minimize 来实现\nCode Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存\n提取公共第三⽅库: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码\n\n4. 如何提⾼webpack的构建速度？\n多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码\n通过 externals 配置来提取常⽤库\n利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。\n使⽤ Happypack 实现多线程加速编译\n使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度\n使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码\n\n","slug":"性能优化常用方案","date":"2022-05-13T07:21:05.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"b0c39a989b20ba4596f03e3c1987bd23","title":"面试题笔记——REACT篇(下)","content":"\n六、Redux1. 对 Redux 的理解，主要解决什么问题React是视图层框架。Redux是一个用来管理数据状态和UI状态的JavaScript应用工具。随着JavaScript单页应用（SPA）开发日趋复杂， JavaScript需要管理比任何时候都要多的state（状态）， Redux就是降低管理难度的。（Redux支持React、Angular、jQuery甚至纯JavaScript）。\n在 React 中，UI 以组件的形式来搭建，组件之间可以嵌套组合。但 React 中组件间通信的数据流是单向的，顶层组件可以通过 props 属性向下层组件传递数据，而下层组件不能向上层组件传递数据，兄弟组件之间同样不能。这样简单的单向数据流支撑起了 React 中的数据可控性。\n当项目越来越大的时候，管理数据的事件或回调函数将越来越多，也将越来越不好管理。管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等。state 的管理在大项目中相当复杂。\nRedux 提供了一个叫 store 的统一仓储库，组件通过 dispatch 将 state 直接传入store，不用通过其他的组件。并且组件通过 subscribe 从 store获取到 state 的改变。使用了 Redux，所有的组件都可以从 store 中获取到所需的 state，他们也能从store 获取到 state 的改变。这比组件之间互相传递数据清晰明朗的多。\n主要解决的问题： 单纯的Redux只是一个状态机，是没有UI呈现的，react- redux作用是将Redux的状态机和React的UI呈现绑定在一起，当你dispatch action改变state的时候，会自动更新页面。\n2. Redux 原理及工作流程（1）原理 Redux源码主要分为以下几个模块文件\n\ncompose.js 提供从右到左进行函数式编程\ncreateStore.js 提供作为生成唯一store的函数\ncombineReducers.js 提供合并多个reducer的函数，保证store的唯一性\nbindActionCreators.js 可以让开发者在不直接接触dispacth的前提下进行更改state的操作\napplyMiddleware.js 这个方法通过中间件来增强dispatch的功能\n\nconst actionTypes &#x3D; &#123;\n    ADD: &#39;ADD&#39;,\n    CHANGEINFO: &#39;CHANGEINFO&#39;,\n&#125;\n\nconst initState &#x3D; &#123;\n    info: &#39;初始化&#39;,\n&#125;\n\nexport default function initReducer(state&#x3D;initState, action) &#123;\n    switch(action.type) &#123;\n        case actionTypes.CHANGEINFO:\n            return &#123;\n                ...state,\n                info: action.preload.info || &#39;&#39;,\n            &#125;\n        default:\n            return &#123; ...state &#125;;\n    &#125;\n&#125;\n\nexport default function createStore(reducer, initialState, middleFunc) &#123;\n\n    if (initialState &amp;&amp; typeof initialState &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n        middleFunc &#x3D; initialState;\n        initialState &#x3D; undefined;\n    &#125;\n\n    let currentState &#x3D; initialState;\n\n    const listeners &#x3D; [];\n\n    if (middleFunc &amp;&amp; typeof middleFunc &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;\n        &#x2F;&#x2F; 封装dispatch \n        return middleFunc(createStore)(reducer, initialState);\n    &#125;\n\n    const getState &#x3D; () &#x3D;&gt; &#123;\n        return currentState;\n    &#125;\n\n    const dispatch &#x3D; (action) &#x3D;&gt; &#123;\n        currentState &#x3D; reducer(currentState, action);\n\n        listeners.forEach(listener &#x3D;&gt; &#123;\n            listener();\n        &#125;)\n    &#125;\n\n    const subscribe &#x3D; (listener) &#x3D;&gt; &#123;\n        listeners.push(listener);\n    &#125;\n\n    return &#123;\n        getState,\n        dispatch,\n        subscribe\n    &#125;\n&#125;\n复制代码\n\n（2）工作流程\n\nconst store&#x3D; createStore（fn）生成数据;\naction: {type: Symble(‘action01), payload:’payload’ }定义行为;\ndispatch发起action：store.dispatch(doSomething(‘action001’));\nreducer：处理action，返回新的state;\n\n通俗点解释：\n\n首先，用户（通过View）发出Action，发出方式就用到了dispatch方法\n然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State\nState—旦有变化，Store就会调用监听函数，来更新View\n\n以 store 为核心，可以把它看成数据存储中心，但是他要更改数据的时候不能直接修改，数据修改更新的角色由Reducers来担任，store只做存储，中间人，当Reducers的更新完成以后会通过store的订阅来通知react component，组件把新的状态重新获取渲染，组件中也能主动发送action，创建action后这个动作是不会执行的，所以要dispatch这个action，让store通过reducers去做更新React Component 就是react的每个组件。\n3. Redux 中异步的请求怎么处理可以在 componentDidmount 中直接进⾏请求⽆须借助redux。但是在⼀定规模的项⽬中,上述⽅法很难进⾏异步流的管理,通常情况下我们会借助redux的异步中间件进⾏异步处理。redux异步流中间件其实有很多，当下主流的异步中间件有两种redux-thunk、redux-saga。\n（1）使用react-thunk中间件\nredux-thunk优点:\n\n体积⼩: redux-thunk的实现⽅式很简单,只有不到20⾏代码\n使⽤简单: redux-thunk没有引⼊像redux-saga或者redux-observable额外的范式,上⼿简单\n\nredux-thunk缺陷:\n\n样板代码过多: 与redux本身⼀样,通常⼀个请求需要⼤量的代码,⽽且很多都是重复性质的\n耦合严重: 异步操作与redux的action偶合在⼀起,不⽅便管理\n功能孱弱: 有⼀些实际开发中常⽤的功能需要⾃⼰进⾏封装\n\n使用步骤：\n\n配置中间件，在store的创建中配置\n\nimport &#123;createStore, applyMiddleware, compose&#125; from &#39;redux&#39;;\nimport reducer from &#39;.&#x2F;reducer&#39;;\nimport thunk from &#39;redux-thunk&#39;\n\n&#x2F;&#x2F; 设置调试工具\nconst composeEnhancers &#x3D; window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose;\n&#x2F;&#x2F; 设置中间件\nconst enhancer &#x3D; composeEnhancers(\n  applyMiddleware(thunk)\n);\n\nconst store &#x3D; createStore(reducer, enhancer);\n\nexport default store;\n复制代码\n\n\n添加一个返回函数的actionCreator，将异步请求逻辑放在里面\n\n&#x2F;**\n  发送get请求，并生成相应action，更新store的函数\n  @param url &#123;string&#125; 请求地址\n  @param func &#123;function&#125; 真正需要生成的action对应的actionCreator\n  @return &#123;function&#125; \n*&#x2F;\n&#x2F;&#x2F; dispatch为自动接收的store.dispatch函数 \nexport const getHttpAction &#x3D; (url, func) &#x3D;&gt; (dispatch) &#x3D;&gt; &#123;\n    axios.get(url).then(function(res)&#123;\n        const action &#x3D; func(res.data)\n        dispatch(action)\n    &#125;)\n&#125;\n复制代码\n\n\n生成action，并发送action\n\ncomponentDidMount()&#123;\n    var action &#x3D; getHttpAction(&#39;&#x2F;getData&#39;, getInitTodoItemAction)\n    &#x2F;&#x2F; 发送函数类型的action时，该action的函数体会自动执行\n    store.dispatch(action)\n&#125;\n复制代码\n\n（2）使用redux-saga中间件\nredux-saga优点:\n\n异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中\naction摆脱thunk function: dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满 “⿊魔法” thunk function\n异常处理: 受益于 generator function 的 saga 实现，代码异常&#x2F;请求失败 都可以直接通过 try&#x2F;catch 语法直接捕获处理\n功能强⼤: redux-saga提供了⼤量的Saga 辅助函数和Effect 创建器供开发者使⽤,开发者⽆须封装或者简单封装即可使⽤\n灵活: redux-saga可以将多个Saga可以串⾏&#x2F;并⾏组合起来,形成⼀个⾮常实⽤的异步flow\n易测试，提供了各种case的测试⽅案，包括mock task，分⽀覆盖等等\n\nredux-saga缺陷:\n\n额外的学习成本: redux-saga不仅在使⽤难以理解的 generator function,⽽且有数⼗个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和⼀整套思想\n体积庞⼤: 体积略⼤,代码近2000⾏，min版25KB左右\n功能过剩: 实际上并发控制等功能很难⽤到,但是我们依然需要引⼊这些代码\nts⽀持不友好: yield⽆法返回TS类型\n\nredux-saga可以捕获action，然后执行一个函数，那么可以把异步代码放在这个函数中，使用步骤如下：\n\n配置中间件\n\nimport &#123;createStore, applyMiddleware, compose&#125; from &#39;redux&#39;;\nimport reducer from &#39;.&#x2F;reducer&#39;;\nimport createSagaMiddleware from &#39;redux-saga&#39;\nimport TodoListSaga from &#39;.&#x2F;sagas&#39;\n\nconst composeEnhancers &#x3D; window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose;\nconst sagaMiddleware &#x3D; createSagaMiddleware()\n\nconst enhancer &#x3D; composeEnhancers(\n  applyMiddleware(sagaMiddleware)\n);\n\nconst store &#x3D; createStore(reducer, enhancer);\nsagaMiddleware.run(TodoListSaga)\n\nexport default store;\n复制代码\n\n\n将异步请求放在sagas.js中\n\nimport &#123;takeEvery, put&#125; from &#39;redux-saga&#x2F;effects&#39;\nimport &#123;initTodoList&#125; from &#39;.&#x2F;actionCreator&#39;\nimport &#123;GET_INIT_ITEM&#125; from &#39;.&#x2F;actionTypes&#39;\nimport axios from &#39;axios&#39;\n\nfunction* func()&#123;\n    try&#123;\n        &#x2F;&#x2F; 可以获取异步返回数据\n        const res &#x3D; yield axios.get(&#39;&#x2F;getData&#39;)\n        const action &#x3D; initTodoList(res.data)\n        &#x2F;&#x2F; 将action发送到reducer\n        yield put(action)\n    &#125;catch(e)&#123;\n        console.log(&#39;网络请求失败&#39;)\n    &#125;\n&#125;\n\nfunction* mySaga()&#123;\n    &#x2F;&#x2F; 自动捕获GET_INIT_ITEM类型的action，并执行func\n    yield takeEvery(GET_INIT_ITEM, func)\n&#125;\n\nexport default mySaga\n复制代码\n\n\n发送action\n\ncomponentDidMount()&#123;\n  const action &#x3D; getInitTodoItemAction()\n  store.dispatch(action)\n&#125;\n复制代码\n\n4. Redux 怎么实现属性传递，介绍下原理react-redux 数据传输∶ view–&gt;action–&gt;reducer–&gt;store–&gt;view。看下点击事件的数据是如何通过redux传到view上：\n\nview 上的AddClick 事件通过mapDispatchToProps 把数据传到action —&gt; click:()&#x3D;&gt;dispatch(ADD)\naction 的ADD 传到reducer上\nreducer传到store上 const store &#x3D; createStore(reducer);\nstore再通过 mapStateToProps 映射穿到view上text:State.text\n\n代码示例∶\nimport React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport &#123; createStore &#125; from &#39;redux&#39;;\nimport &#123; Provider, connect &#125; from &#39;react-redux&#39;;\nclass App extends React.Component&#123;\n    render()&#123;\n        let &#123; text, click, clickR &#125; &#x3D; this.props;\n        return(\n            &lt;div&gt;\n                &lt;div&gt;数据:已有人&#123;text&#125;&lt;&#x2F;div&gt;\n                &lt;div onClick&#x3D;&#123;click&#125;&gt;加人&lt;&#x2F;div&gt;\n                &lt;div onClick&#x3D;&#123;clickR&#125;&gt;减人&lt;&#x2F;div&gt;\n            &lt;&#x2F;div&gt;\n        )\n    &#125;\n&#125;\nconst initialState &#x3D; &#123;\n    text:5\n&#125;\nconst reducer &#x3D; function(state,action)&#123;\n    switch(action.type)&#123;\n        case &#39;ADD&#39;:\n            return &#123;text:state.text+1&#125;\n        case &#39;REMOVE&#39;:\n            return &#123;text:state.text-1&#125;\n        default:\n            return initialState;\n    &#125;\n&#125;\n\nlet ADD &#x3D; &#123;\n    type:&#39;ADD&#39;\n&#125;\nlet Remove &#x3D; &#123;\n    type:&#39;REMOVE&#39;\n&#125;\n\nconst store &#x3D; createStore(reducer);\n\nlet mapStateToProps &#x3D; function (state)&#123;\n    return&#123;\n        text:state.text\n    &#125;\n&#125;\n\nlet mapDispatchToProps &#x3D; function(dispatch)&#123;\n    return&#123;\n        click:()&#x3D;&gt;dispatch(ADD),\n        clickR:()&#x3D;&gt;dispatch(Remove)\n    &#125;\n&#125;\n\nconst App1 &#x3D; connect(mapStateToProps,mapDispatchToProps)(App);\n\nReactDOM.render(\n    &lt;Provider store &#x3D; &#123;store&#125;&gt;\n        &lt;App1&gt;&lt;&#x2F;App1&gt;\n    &lt;&#x2F;Provider&gt;,document.getElementById(&#39;root&#39;)\n)\n复制代码\n\n5. Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？Redux 的中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点，换而言之，原本 view -→&gt; action -&gt; reducer -&gt; store 的数据流加上中间件后变成了 view -&gt; action -&gt; middleware -&gt; reducer -&gt; store ，在这一环节可以做一些”副作用”的操作，如异步请求、打印日志等。\napplyMiddleware源码：\nexport default function applyMiddleware(...middlewares) &#123;\n    return createStore &#x3D;&gt; (...args) &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 利用传入的createStore和reducer和创建一个store\n        const store &#x3D; createStore(...args)\n        let dispatch &#x3D; () &#x3D;&gt; &#123;\n            throw new Error()\n        &#125;\n        const middlewareAPI &#x3D; &#123;\n            getState: store.getState,\n            dispatch: (...args) &#x3D;&gt; dispatch(...args)\n        &#125;\n        &#x2F;&#x2F; 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍\n        const chain &#x3D; middlewares.map(middleware &#x3D;&gt; middleware(middlewareAPI))\n        &#x2F;&#x2F; 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch\n        dispatch &#x3D; compose(...chain)(store.dispatch)\n        return &#123;\n            ...store,\n            dispatch\n        &#125;\n    &#125;\n&#125;\n复制代码\n\n从applyMiddleware中可以看出∶\n\nredux中间件接受一个对象作为参数，对象的参数上有两个字段 dispatch 和 getState，分别代表着 Redux Store 上的两个同名函数。\n柯里化函数两端一个是 middewares，一个是store.dispatch\n\n6. Redux 请求中间件如何处理并发使用redux-Saga redux-saga是一个管理redux应用异步操作的中间件，用于代替 redux-thunk 的。它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。 redux-saga如何处理并发：\n\ntakeEvery\n\n可以让多个 saga 任务并行被 fork 执行。\nimport &#123;\n    fork,\n    take\n&#125; from &quot;redux-saga&#x2F;effects&quot;\n\nconst takeEvery &#x3D; (pattern, saga, ...args) &#x3D;&gt; fork(function*() &#123;\n    while (true) &#123;\n        const action &#x3D; yield take(pattern)\n        yield fork(saga, ...args.concat(action))\n    &#125;\n&#125;)\n复制代码\n\n\ntakeLatest\n\ntakeLatest 不允许多个 saga 任务并行地执行。一旦接收到新的发起的 action，它就会取消前面所有 fork 过的任务（如果这些任务还在执行的话）。 在处理 AJAX 请求的时候，如果只希望获取最后那个请求的响应， takeLatest 就会非常有用。\nimport &#123;\n    cancel,\n    fork,\n    take\n&#125; from &quot;redux-saga&#x2F;effects&quot;\n\nconst takeLatest &#x3D; (pattern, saga, ...args) &#x3D;&gt; fork(function*() &#123;\n    let lastTask\n    while (true) &#123;\n        const action &#x3D; yield take(pattern)\n        if (lastTask) &#123;\n            yield cancel(lastTask) &#x2F;&#x2F; 如果任务已经结束，则 cancel 为空操作\n        &#125;\n        lastTask &#x3D; yield fork(saga, ...args.concat(action))\n    &#125;\n&#125;)\n复制代码\n\n7. Redux 状态管理器和变量挂载到 window 中有什么区别两者都是存储数据以供后期使用。但是Redux状态更改可回溯——Time travel，数据多了的时候可以很清晰的知道改动在哪里发生，完整的提供了一套状态管理模式。\n随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。\n管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。 如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前所未有的复杂性，难道就这么放弃了吗?当然不是。\n这里的复杂性很大程度上来自于：我们总是将两个难以理清的概念混淆在一起：变化和异步。 可以称它们为曼妥思和可乐。如果把二者分开，能做的很好，但混到一起，就变得一团糟。一些库如 React 视图在视图层禁止异步和直接操作 DOM来解决这个问题。美中不足的是，React 依旧把处理 state 中数据的问题留给了你。Redux就是为了帮你解决这个问题。\n8. mobox 和 redux 有什么区别？（1）共同点\n\n为了解决状态管理混乱，无法有效同步的问题统一维护管理应用状态;\n某一状态只有一个可信数据来源（通常命名为store，指状态容器）;\n操作更新状态方式统一，并且可控（通常以action方式提供更新状态的途径）;\n支持将store与React组件连接，如react-redux，mobx- react;\n\n（2）区别 Redux更多的是遵循Flux模式的一种实现，是一个 JavaScript库，它关注点主要是以下几方面∶\n\nAction∶ 一个JavaScript对象，描述动作相关信息，主要包含type属性和payload属性∶\no type∶ action 类型; o payload∶ 负载数据;\n复制代码\n\nReducer∶ 定义应用状态如何响应不同动作（action），如何更新状态;\n\nStore∶ 管理action和reducer及其关系的对象，主要提供以下功能∶\no 维护应用状态并支持访问状态(getState());\no 支持监听action的分发，更新状态(dispatch(action)); \no 支持订阅store的变更(subscribe(listener));\n复制代码\n\n异步流∶ 由于Redux所有对store状态的变更，都应该通过action触发，异步任务（通常都是业务或获取数据任务）也不例外，而为了不将业务或数据相关的任务混入React组件中，就需要使用其他框架配合管理异步任务流程，如redux-thunk，redux-saga等;\n\n\nMobx是一个透明函数响应式编程的状态管理库，它使得状态管理简单可伸缩∶\n\nAction∶定义改变状态的动作函数，包括如何变更状态;\nStore∶ 集中管理模块状态（State）和动作(action)\nDerivation（衍生）∶ 从应用状态中派生而出，且没有任何其他影响的数据\n\n对比总结：\n\nredux将数据保存在单一的store中，mobx将数据保存在分散的多个store中\nredux使用plain object保存数据，需要手动处理变化后的操作;mobx适用observable保存数据，数据变化后自动处理响应的操作\nredux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数;mobx中的状态是可变的，可以直接对其进行修改\nmobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维;redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用\nmobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测;而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易\n\n9. Redux 和 Vuex 有什么区别，它们的共同思想（1）Redux 和 Vuex区别\n\nVuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可\nVuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可\nVuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）\n\n通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变；取消了action概念，不必传入特定的 action形式进行指定变更；弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;\n（2）共同思想\n\n单—的数据源\n变化可以预测\n\n本质上∶ redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案。\n10. Redux 中间件是怎么拿到store 和 action? 然后怎么处理?redux中间件本质就是一个函数柯里化。redux applyMiddleware Api 源码中每个middleware 接受2个参数， Store 的getState 函数和dispatch 函数，分别获得store和action，最终返回一个函数。该函数会被传入 next 的下一个 middleware 的 dispatch 方法，并返回一个接收 action 的新函数，这个函数可以直接调用 next（action），或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个 middleware 会接受真实的 store的 dispatch 方法作为 next 参数，并借此结束调用链。所以，middleware 的函数签名是（{ getState，dispatch })&#x3D;&gt; next &#x3D;&gt; action。\n11. Redux中的connect有什么作用connect负责连接React和Redux\n（1）获取state\nconnect 通过 context获取 Provider 中的 store，通过 store.getState() 获取整个store tree 上所有state\n（2）包装原组件\n将state和action通过props的方式传入到原组件内部 wrapWithConnect 返回—个 ReactComponent 对 象 Connect，Connect 重 新 render 外部传入的原组件 WrappedComponent ，并把 connect 中传入的 mapStateToProps，mapDispatchToProps与组件上原有的 props合并后，通过属性的方式传给WrappedComponent\n（3）监听store tree变化\nconnect缓存了store tree中state的状态，通过当前state状态 和变更前 state 状态进行比较，从而确定是否调用 this.setState()方法触发Connect及其子组件的重新渲染\n七、Hooks1. 对 React Hook 的理解，它的实现原理是什么React-Hooks 是 React 团队在 React 组件开发实践中，逐渐认知到的一个改进点，这背后其实涉及对类组件和函数组件两种组件形式的思考和侧重。\n（1）类组件： 所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件。以下是一个类组件：\nclass DemoClass extends React.Component &#123;\n  state &#x3D; &#123;\n    text: &quot;&quot;\n  &#125;;\n  componentDidMount() &#123;\n    &#x2F;&#x2F;...\n  &#125;\n  changeText &#x3D; (newText) &#x3D;&gt; &#123;\n    this.setState(&#123;\n      text: newText\n    &#125;);\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;div className&#x3D;&quot;demoClass&quot;&gt;\n        &lt;p&gt;&#123;this.state.text&#125;&lt;&#x2F;p&gt;\n        &lt;button onClick&#x3D;&#123;this.changeText&#125;&gt;修改&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\n复制代码\n\n可以看出，React 类组件内部预置了相当多的“现成的东西”等着我们去调度&#x2F;定制，state 和生命周期就是这些“现成东西”中的典型。要想得到这些东西，难度也不大，只需要继承一个 React.Component 即可。\n当然，这也是类组件的一个不便，它太繁杂了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的。除此之外，由于开发者编写的逻辑在封装后是和组件粘在一起的，这就使得类组件内部的逻辑难以实现拆分和复用。\n（2）函数组件：函数组件就是以函数的形态存在的 React 组件。早期并没有 React-Hooks，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。以下是一个函数组件：\nfunction DemoFunction(props) &#123;\n  const &#123; text &#125; &#x3D; props\n  return (\n    &lt;div className&#x3D;&quot;demoFunction&quot;&gt;\n      &lt;p&gt;&#123;&#96;函数组件接收的内容：[$&#123;text&#125;]&#96;&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n复制代码\n\n相比于类组件，函数组件肉眼可见的特质自然包括轻量、灵活、易于组织和维护、较低的学习成本等。\n通过对比，从形态上可以对两种组件做区分，它们之间的区别如下：\n\n类组件需要继承 class，函数组件不需要；\n类组件可以访问生命周期方法，函数组件不能；\n类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；\n类组件中可以定义并维护 state（状态），而函数组件不可以；\n\n除此之外，还有一些其他的不同。通过上面的区别，我们不能说谁好谁坏，它们各有自己的优势。在 React-Hooks 出现之前，类组件的能力边界明显强于函数组件。\n实际上，类组件和函数组件之间，是面向对象和函数式编程这两套不同的设计思想之间的差异。而函数组件更加契合 React 框架的设计理念：  React 组件本身的定位就是函数，一个输入数据、输出 UI 的函数。作为开发者，我们编写的是声明式的代码，而 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。函数组件就真正地将数据和渲染绑定到了一起。函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分与重用的组件表达形式。\n为了能让开发者更好的的去编写函数式组件。于是，React-Hooks 便应运而生。\nReact-Hooks 是一套能够使函数组件更强大、更灵活的“钩子”。\n函数组件比起类组件少了很多东西，比如生命周期、对 state 的管理等。这就给函数组件的使用带来了非常多的局限性，导致我们并不能使用函数这种形式，写出一个真正的全功能的组件。而React-Hooks 的出现，就是为了帮助函数组件补齐这些（相对于类组件来说）缺失的能力。\n如果说函数组件是一台轻巧的快艇，那么 React-Hooks 就是一个内容丰富的零部件箱。“重装战舰”所预置的那些设备，这个箱子里基本全都有，同时它还不强制你全都要，而是允许你自由地选择和使用你需要的那些能力，然后将这些能力以 Hook（钩子）的形式“钩”进你的组件里，从而定制出一个最适合你的“专属战舰”。\n2. 为什么 useState 要使用数组而不是对象useState 的用法：\nconst [count, setCount] &#x3D; useState(0)\n复制代码\n\n可以看到 useState 返回的是一个数组，那么为什么是返回数组而不是返回对象呢？\n这里用到了解构赋值，所以先来看一下ES6 的解构赋值：\n数组的解构赋值const foo &#x3D; [1, 2, 3];\nconst [one, two, three] &#x3D; foo;\nconsole.log(one);\t&#x2F;&#x2F; 1\nconsole.log(two);\t&#x2F;&#x2F; 2\nconsole.log(three);\t&#x2F;&#x2F; 3\n复制代码\n\n对象的解构赋值const user &#x3D; &#123;\n  id: 888,\n  name: &quot;xiaoxin&quot;\n&#125;;\nconst &#123; id, name &#125; &#x3D; user;\nconsole.log(id);\t&#x2F;&#x2F; 888\nconsole.log(name);\t&#x2F;&#x2F; &quot;xiaoxin&quot;\n复制代码\n\n看完这两个例子，答案应该就出来了：\n\n如果 useState 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净\n如果 useState 返回的是对象，在解构对象的时候必须要和 useState 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值\n\n下面来看看如果 useState 返回对象的情况：\n&#x2F;&#x2F; 第一次使用\nconst &#123; state, setState &#125; &#x3D; useState(false);\n&#x2F;&#x2F; 第二次使用\nconst &#123; state: counter, setState: setCounter &#125; &#x3D; useState(0) \n复制代码\n\n这里可以看到，返回对象的使用方式还是挺麻烦的，更何况实际项目中会使用的更频繁。 总结：useState 返回的是 array 而不是 object 的原因就是为了降低使用的复杂度，返回数组的话可以直接根据顺序解构，而返回对象的话要想使用多次就需要定义别名了。\n3. React Hooks 解决了哪些问题？React Hooks 主要解决了以下问题：\n（1）在组件之间复用状态逻辑很难\nReact 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）解决此类问题可以使用 render props 和 高阶组件。但是这类方案需要重新组织组件结构，这可能会很麻烦，并且会使代码难以理解。由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管可以在 DevTools 过滤掉它们，但这说明了一个更深层次的问题：React 需要为共享状态逻辑提供更好的原生途径。\n可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使我们在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。\n（2）复杂组件变得难以理解\n在组件中，每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。\n在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。\n为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。\n（3）难以理解的 class\n除了代码复用和代码管理会遇到困难外，class 是学习 React 的一大屏障。我们必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。没有稳定的语法提案，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 React 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。\n为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术\n4. React Hook 的使用限制有哪些？React Hooks 的限制主要有两条：\n\n不要在循环、条件或嵌套函数中调用 Hook；\n在 React 的函数组件中调用 Hook。\n\n那为什么会有这样的限制呢？Hooks 的设计初衷是为了改进 React 组件的开发模式。在旧有的开发模式下遇到了三个问题。\n\n组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、render props 及状态管理框架。\n复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。\n人和机器都很容易混淆类。常见的有 this 的问题，但在 React 团队中还有类难以优化的问题，希望在编译优化层面做出一些改进。\n\n这三个问题在一定程度上阻碍了 React 的后续发展，所以为了解决这三个问题，Hooks 基于函数组件开始设计。然而第三个问题决定了 Hooks 只支持函数组件。\n那为什么不要在循环、条件或嵌套函数中调用 Hook 呢？因为 Hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，实质上 React 的源码里不是数组，是链表。\n这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为了避免这样的情况，可以引入 ESLint 的 Hooks 检查插件进行预防。\n5. useEffect 与 useLayoutEffect 的区别（1）共同点\n\n运用效果： useEffect 与 useLayoutEffect 两者都是用于处理副作用，这些副作用包括改变 DOM、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。\n使用方式： useEffect 与 useLayoutEffect 两者底层的函数签名是完全一致的，都是调用的 mountEffectImpl方法，在使用上也没什么差异，基本可以直接替换。\n\n（2）不同点\n\n使用场景： useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景；而 useLayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 useLayoutEffect 做计算量较大的耗时任务从而造成阻塞。\n使用效果： useEffect是按照顺序执行代码的，改变屏幕像素之后执行（先渲染，后改变DOM），当改变屏幕内容时可能会产生闪烁；useLayoutEffect是改变屏幕像素之前就执行了（会推迟页面显示的事件，先改变DOM后渲染），不会产生闪烁。useLayoutEffect总是比useEffect先执行。\n\n在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可。\n6. React Hooks在平时开发中需要注意的问题和原因（1）不要在循环，条件或嵌套函数中调用Hook，必须始终在 React函数的顶层使用Hook\n这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。\n（2）使用useState时候，使用push，pop，splice等直接更改数组对象的坑\n使用push直接更改数组无法获取到新值，应该采用析构方式，但是在class里面不会有这个问题。代码示例：\nfunction Indicatorfilter() &#123;\n  let [num,setNums] &#x3D; useState([0,1,2,3])\n  const test &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 这里坑是直接采用push去更新num\n    &#x2F;&#x2F; setNums(num)是无法更新num的\n    &#x2F;&#x2F; 必须使用num &#x3D; [...num ,1]\n    num.push(1)\n    &#x2F;&#x2F; num &#x3D; [...num ,1]\n    setNums(num)\n  &#125;\nreturn (\n    &lt;div className&#x3D;&#39;filter&#39;&gt;\n      &lt;div onClick&#x3D;&#123;test&#125;&gt;测试&lt;&#x2F;div&gt;\n        &lt;div&gt;\n          &#123;num.map((item,index) &#x3D;&gt; (\n              &lt;div key&#x3D;&#123;index&#125;&gt;&#123;item&#125;&lt;&#x2F;div&gt;\n          ))&#125;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  )\n&#125;\n\nclass Indicatorfilter extends React.Component&lt;any,any&gt;&#123;\n  constructor(props:any)&#123;\n      super(props)\n      this.state &#x3D; &#123;\n          nums:[1,2,3]\n      &#125;\n      this.test &#x3D; this.test.bind(this)\n  &#125;\n\n  test()&#123;\n      &#x2F;&#x2F; class采用同样的方式是没有问题的\n      this.state.nums.push(1)\n      this.setState(&#123;\n          nums: this.state.nums\n      &#125;)\n  &#125;\n\n  render()&#123;\n      let &#123;nums&#125; &#x3D; this.state\n      return(\n          &lt;div&gt;\n              &lt;div onClick&#x3D;&#123;this.test&#125;&gt;测试&lt;&#x2F;div&gt;\n                  &lt;div&gt;\n                      &#123;nums.map((item:any,index:number) &#x3D;&gt; (\n                          &lt;div key&#x3D;&#123;index&#125;&gt;&#123;item&#125;&lt;&#x2F;div&gt;\n                      ))&#125;\n                  &lt;&#x2F;div&gt;\n          &lt;&#x2F;div&gt;\n\n      )\n  &#125;\n&#125;\n复制代码\n\n（3）useState设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useEffect\nTableDeail是一个公共组件，在调用它的父组件里面，我们通过set改变columns的值，以为传递给TableDeail 的 columns是最新的值，所以tabColumn每次也是最新的值，但是实际tabColumn是最开始的值，不会随着columns的更新而更新：\nconst TableDeail &#x3D; (&#123;\n    columns,\n&#125;:TableData) &#x3D;&gt; &#123;\n    const [tabColumn, setTabColumn] &#x3D; useState(columns) \n&#125;\n\n&#x2F;&#x2F; 正确的做法是通过useEffect改变这个值\nconst TableDeail &#x3D; (&#123;\n    columns,\n&#125;:TableData) &#x3D;&gt; &#123;\n    const [tabColumn, setTabColumn] &#x3D; useState(columns) \n    useEffect(() &#x3D;&gt;&#123;setTabColumn(columns)&#125;,[columns])\n&#125;\n\n复制代码\n\n（4）善用useCallback\n父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用useMemo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。\n（5）不要滥用useContext\n可以使用基于 useContext 封装的状态管理工具。\n7. React Hooks 和生命周期的关系？函数组件 的本质是函数，没有 state 的概念的，因此不存在生命周期一说，仅仅是一个 render 函数而已。 但是引入 Hooks 之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念，所谓的生命周期其实就是 useState、 useEffect() 和 useLayoutEffect() 。\n即：Hooks 组件（使用了Hooks的函数组件）有生命周期，而函数组件（未使用Hooks的函数组件）是没有生命周期的。\n下面是具体的 class 与 Hooks 的生命周期对应关系：\n\nconstructor：函数组件不需要构造函数，可以通过调用 **useState 来初始化 state**。如果计算的代价比较昂贵，也可以传一个函数给 useState。\n\nconst [num, UpdateNum] &#x3D; useState(0)\n复制代码\n\n\ngetDerivedStateFromProps：一般情况下，我们不需要使用它，可以在渲染过程中更新 state，以达到实现 getDerivedStateFromProps 的目的。\n\nfunction ScrollView(&#123;row&#125;) &#123;\n  let [isScrollingDown, setIsScrollingDown] &#x3D; useState(false);\n  let [prevRow, setPrevRow] &#x3D; useState(null);\n  if (row !&#x3D;&#x3D; prevRow) &#123;\n    &#x2F;&#x2F; Row 自上次渲染以来发生过改变。更新 isScrollingDown。\n    setIsScrollingDown(prevRow !&#x3D;&#x3D; null &amp;&amp; row &gt; prevRow);\n    setPrevRow(row);\n  &#125;\n  return &#96;Scrolling down: $&#123;isScrollingDown&#125;&#96;;\n&#125;\n复制代码\n\nReact 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。\n\nshouldComponentUpdate：可以用 **React.memo** 包裹一个组件来对它的 props 进行浅比较\n\nconst Button &#x3D; React.memo((props) &#x3D;&gt; &#123;  &#x2F;&#x2F; 具体的组件&#125;);\n复制代码\n\n注意：**React.memo 等效于 **``**PureComponent**，它只浅比较 props。这里也可以使用 useMemo 优化每一个节点。\n\nrender：这是函数组件体本身。\ncomponentDidMount, componentDidUpdate： useLayoutEffect 与它们两的调用阶段是一样的。但是，我们推荐你一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect。useEffect 可以表达所有这些的组合。\n\n&#x2F;&#x2F; componentDidMount\nuseEffect(()&#x3D;&gt;&#123;\n  &#x2F;&#x2F; 需要在 componentDidMount 执行的内容\n&#125;, [])\nuseEffect(() &#x3D;&gt; &#123; \n  &#x2F;&#x2F; 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容\n  document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;; \n  return () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 需要在 count 更改时 componentDidUpdate（先于 document.title &#x3D; ... 执行，遵守先清理后更新）\n    &#x2F;&#x2F; 以及 componentWillUnmount 执行的内容       \n  &#125; &#x2F;&#x2F; 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关\n&#125;, [count]); &#x2F;&#x2F; 仅在 count 更改时更新\n复制代码\n\n请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 ，因此会使得额外操作很方便\n\ncomponentWillUnmount：相当于 useEffect 里面返回的 cleanup 函数\n\n&#x2F;&#x2F; componentDidMount&#x2F;componentWillUnmount\nuseEffect(()&#x3D;&gt;&#123;\n  &#x2F;&#x2F; 需要在 componentDidMount 执行的内容\n  return function cleanup() &#123;\n    &#x2F;&#x2F; 需要在 componentWillUnmount 执行的内容      \n  &#125;\n&#125;, [])\n复制代码\n\n\ncomponentDidCatch and getDerivedStateFromError：目前还没有这些方法的 Hook 等价写法，但很快会加上。\n\n\n\n\nclass 组件\nHooks 组件\n\n\n\nconstructor\nuseState\n\n\ngetDerivedStateFromProps\nuseState 里面 update 函数\n\n\nshouldComponentUpdate\nuseMemo\n\n\nrender\n函数本身\n\n\ncomponentDidMount\nuseEffect\n\n\ncomponentDidUpdate\nuseEffect\n\n\ncomponentWillUnmount\nuseEffect 里面返回的函数\n\n\ncomponentDidCatch\n无\n\n\ngetDerivedStateFromError\n无\n\n\n八、虚拟DOM1. 对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。\n虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对DOM的描述。它设计的最初目的，就是更好的跨平台，比如node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟dom，因为虚拟dom本身是js对象。 在代码渲染到页面之前，vue或者react会把代码转换成一个对象（虚拟DOM）。以对象的形式来描述真实dom结构，最终渲染到页面。在每次数据发生变化前，虚拟dom都会缓存一份，变化之时，现在的虚拟dom会与缓存的虚拟dom进行比较。在vue或者react内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。\n另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。\n为什么要用 Virtual DOM：\n（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能\n下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶\n\n真实DOM∶ 生成HTML字符串＋ 重建所有的DOM元素\nVirtual DOM∶ 生成vNode＋ DOMDiff＋必要的DOM更新\n\nVirtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，我依然可以给你提供过得去的性能。 （2）跨平台 Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。\n2. React diff 算法的原理是什么？实际上，diff 算法探讨的就是虚拟 DOM 树发生变化后，生成 DOM 树更新补丁的方式。它通过对比新旧两株虚拟 DOM 树的变更差异，将更新补丁作用于真实 DOM，以最小成本完成视图更新。  具体的流程如下：\n\n真实的 DOM 首先会映射为虚拟 DOM；\n当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；\n根据 patch 去更新真实的 DOM，反馈到用户的界面上。\n\n 一个简单的例子：\nimport React from &#39;react&#39;\nexport default class ExampleComponent extends React.Component &#123;\n  render() &#123;\n    if(this.props.isVisible) &#123;\n       return &lt;div className&#x3D;&quot;visible&quot;&gt;visbile&lt;&#x2F;div&gt;;\n    &#125;\n     return &lt;div className&#x3D;&quot;hidden&quot;&gt;hidden&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n复制代码\n\n这里，首先假定 ExampleComponent 可见，然后再改变它的状态，让它不可见 。映射为真实的 DOM 操作是这样的，React 会创建一个 div 节点。\n&lt;div class&#x3D;&quot;visible&quot;&gt;visbile&lt;&#x2F;div&gt;\n复制代码\n\n当把 visbile 的值变为 false 时，就会替换 class 属性为 hidden，并重写内部的 innerText 为 hidden。这样一个生成补丁、更新差异的过程统称为 diff 算法。\ndiff算法可以总结为三个策略，分别从树、组件及元素三个层面进行复杂度的优化：\n策略一：忽略节点跨层级操作场景，提升比对效率。（基于树进行对比）\n这一策略需要进行树比对，即对树进行分层比较。树比对的处理手法是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。\n策略二：如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构。（基于组件进行对比）\n在组件比对的过程中：\n\n如果组件是同一类型则进行树比对；\n如果不是则直接放入补丁中。\n\n只要父组件类型不同，就会被重新渲染。这也就是为什么 shouldComponentUpdate、PureComponent 及 React.memo 可以提高性能的原因。\n策略三：同一层级的子节点，可以通过标记 key 的方式进行列表对比。（基于节点进行对比）\n元素比对主要发生在同层级中，通过标记节点操作生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。通过标记 key 的方式，React 可以直接移动 DOM 节点，降低内耗。\n3. React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。\n在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系。\n注意事项：\n\nkey值一定要和具体的元素—一对应；\n尽量不要用数组的index去作为key；\n不要在render的时候用随机数或者其他操作给元素加上不稳定的key，这样造成的性能开销比不加key的情况下更糟糕。\n\n4. 虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么虚拟DOM相对原生的DOM不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 DOM 的操作无论如何都不可能比真实的 DOM 操作更快。在首次渲染大量DOM时，由于多了一层虚拟DOM的计算，虚拟DOM也会比innerHTML插入慢。它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。所以要根据具体的场景进行探讨。\n在整个 DOM 操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写得爽不爽，在于研发体验&#x2F;研发效率。虚拟 DOM 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。虚拟 DOM 并不一定会带来更好的性能，React 官方也从来没有把虚拟 DOM 作为性能层面的卖点对外输出过。虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。\n5. React 与 Vue 的 diff 算法有何不同？diff 算法是指生成更新补丁的方式，主要应用于虚拟 DOM 树变化后，更新真实 DOM。所以 diff 算法一定存在这样一个过程：触发更新 → 生成补丁 → 应用补丁。\nReact 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。\n\n树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。\n组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。\n元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。\n\n以上是经典的 React diff 算法内容。自 React 16 起，引入了 Fiber 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 FiberNode 与 FiberTree 进行重构。fiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点。整个更新过程由 current 与 workInProgress 两株树双缓冲完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。\nVue 的整体 diff 策略与 React 对齐，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。\n九、其他1. React组件命名推荐的方式是哪个？通过引用而不是使用来命名组件displayName。\n使用displayName命名组件：\nexport default React.createClass(&#123;  displayName: &#39;TodoApp&#39;,  &#x2F;&#x2F; ...&#125;)\n复制代码\n\nReact推荐的方法：\nexport default class TodoApp extends React.Component &#123;  &#x2F;&#x2F; ...&#125;\n复制代码\n\n2. react 最新版本解决了什么问题，增加了哪些东西React 16.x的三大新特性 Time Slicing、Suspense、 hooks\n\nTime Slicing（解决CPU速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能\nSuspense （解决网络IO问题） 和lazy配合，实现异步加载组件。 能暂停当前组件的渲染， 当完成某件事以后再继续渲染，解决从react出生到现在都存在的「异步副作用」的问题，而且解决得非的优雅，使用的是 T异步但是同步的写法，这是最好的解决异步问题的方式\n提供了一个内置函数componentDidCatch，当有错误发生时，可以友好地展示 fallback 组件; 可以捕捉到它的子元素（包括嵌套子元素）抛出的异常; 可以复用错误组件。\n\n（1）React16.8 加入hooks，让React函数式组件更加灵活，hooks之前，React存在很多问题：\n\n在组件间复用状态逻辑很难\n复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。\nclass组件的this指向问题\n难以记忆的生命周期\n\nhooks很好的解决了上述问题，hooks提供了很多方法\n\nuseState 返回有状态值，以及更新这个状态值的函数\nuseEffect 接受包含命令式，可能有副作用代码的函数。\nuseContext 接受上下文对象（从 React.createContext返回的值）并返回当前上下文值，\nuseReducer useState 的替代方案。接受类型为 （state，action）&#x3D;&gt; newState的reducer，并返回与dispatch方法配对的当前状态。\nuseCalLback 返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性 o useMemo 纯的一个记忆函数 o useRef 返回一个可变的ref对象，其Current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。\nuseImperativeMethods 自定义使用ref时公开给父组件的实例值\nuseMutationEffect 更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发\nuseLayoutEffect DOM改变后同步触发。使用它来从DOM读取布局并同步重新渲染\n\n（2）React16.9\n\n重命名 Unsafe 的生命周期方法。新的 UNSAFE_前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出\n废弃 javascrip:形式的 URL。以javascript:开头的URL 非常容易遭受攻击，造成安全漏洞。\n废弃”Factory”组件。 工厂组件会导致 React 变大且变慢。\nact（）也支持异步函数，并且你可以在调用它时使用 await。\n使用 &lt;React.ProfiLer&gt; 进行性能评估。在较大的应用中追踪性能回归可能会很方便\n\n（3）React16.13.0\n\n支持在渲染期间调用setState，但仅适用于同一组件\n可检测冲突的样式规则并记录警告\n废弃 unstable_createPortal，使用CreatePortal\n将组件堆栈添加到其开发警告中，使开发人员能够隔离bug并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。\n\n3. react 实现一个全局的 dialogimport React, &#123; Component &#125; from &#39;react&#39;;\nimport &#123; is, fromJS &#125; from &#39;immutable&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport ReactCSSTransitionGroup from &#39;react-addons-css-transition-group&#39;;\nimport &#39;.&#x2F;dialog.css&#39;;\nlet defaultState &#x3D; &#123;\n  alertStatus:false,\n  alertTip:&quot;提示&quot;,\n  closeDialog:function()&#123;&#125;,\n  childs:&#39;&#39;\n&#125;\nclass Dialog extends Component&#123;\n  state &#x3D; &#123;\n    ...defaultState\n  &#125;;\n  &#x2F;&#x2F; css动画组件设置为目标组件\n  FirstChild &#x3D; props &#x3D;&gt; &#123;\n    const childrenArray &#x3D; React.Children.toArray(props.children);\n    return childrenArray[0] || null;\n  &#125;\n  &#x2F;&#x2F;打开弹窗\n  open &#x3D;(options)&#x3D;&gt;&#123;\n    options &#x3D; options || &#123;&#125;;\n    options.alertStatus &#x3D; true;\n    var props &#x3D; options.props || &#123;&#125;;\n    var childs &#x3D; this.renderChildren(props,options.childrens) || &#39;&#39;;\n    console.log(childs);\n    this.setState(&#123;\n      ...defaultState,\n      ...options,\n      childs\n    &#125;)\n  &#125;\n  &#x2F;&#x2F;关闭弹窗\n  close()&#123;\n    this.state.closeDialog();\n    this.setState(&#123;\n      ...defaultState\n    &#125;)\n  &#125;\n  renderChildren(props,childrens) &#123;\n    &#x2F;&#x2F;遍历所有子组件\n    var childs &#x3D; [];\n    childrens &#x3D; childrens || [];\n    var ps &#x3D; &#123;\n        ...props,  &#x2F;&#x2F;给子组件绑定props\n        _close:this.close  &#x2F;&#x2F;给子组件也绑定一个关闭弹窗的事件    \n       &#125;;\n    childrens.forEach((currentItem,index) &#x3D;&gt; &#123;\n        childs.push(React.createElement(\n            currentItem,\n            &#123;\n                ...ps,\n                key:index\n            &#125;\n        ));\n    &#125;)\n    return childs;\n  &#125;\n  shouldComponentUpdate(nextProps, nextState)&#123;\n    return !is(fromJS(this.props), fromJS(nextProps)) || !is(fromJS(this.state), fromJS(nextState))\n  &#125;\n   \n  render()&#123;\n    return (\n      &lt;ReactCSSTransitionGroup\n        component&#x3D;&#123;this.FirstChild&#125;\n        transitionName&#x3D;&#39;hide&#39;\n        transitionEnterTimeout&#x3D;&#123;300&#125;\n        transitionLeaveTimeout&#x3D;&#123;300&#125;&gt;\n        &lt;div className&#x3D;&quot;dialog-con&quot; style&#x3D;&#123;this.state.alertStatus? &#123;display:&#39;block&#39;&#125;:&#123;display:&#39;none&#39;&#125;&#125;&gt;\n            &#123;this.state.childs&#125;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;ReactCSSTransitionGroup&gt;\n    );\n  &#125;\n&#125;\nlet div &#x3D; document.createElement(&#39;div&#39;);\nlet props &#x3D; &#123;\n   \n&#125;;\ndocument.body.appendChild(div);\nlet Box &#x3D; ReactD\n复制代码\n\n子类：\n&#x2F;&#x2F;子类jsx\nimport React, &#123; Component &#125; from &#39;react&#39;;\nclass Child extends Component &#123;\n    constructor(props)&#123;\n        super(props);\n        this.state &#x3D; &#123;date: new Date()&#125;;\n  &#125;\n  showValue&#x3D;()&#x3D;&gt;&#123;\n    this.props.showValue &amp;&amp; this.props.showValue()\n  &#125;\n  render() &#123;\n    return (\n      &lt;div className&#x3D;&quot;Child&quot;&gt;\n        &lt;div className&#x3D;&quot;content&quot;&gt;\n           Child\n           &lt;button onClick&#x3D;&#123;this.showValue&#125;&gt;调用父的方法&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\nexport default Child;\n复制代码\n\ncss：\n.dialog-con&#123;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.3);\n&#125;\n复制代码\n\n4. React 数据持久化有什么实践吗？封装数据持久化组件：\n】let storage&#x3D;&#123;\n    &#x2F;&#x2F; 增加\n    set(key, value)&#123;\n        localStorage.setItem(key, JSON.stringify(value));\n    &#125;,\n    &#x2F;&#x2F; 获取\n    get(key)&#123;\n        return JSON.parse(localStorage.getItem(key));\n    &#125;,\n    &#x2F;&#x2F; 删除\n    remove(key)&#123;\n        localStorage.removeItem(key);\n    &#125;\n&#125;;\nexport default Storage;\n复制代码\n\n在React项目中，通过redux存储全局数据时，会有一个问题，如果用户刷新了网页，那么通过redux存储的全局数据就会被全部清空，比如登录信息等。这时就会有全局数据持久化存储的需求。首先想到的就是localStorage，localStorage是没有时间限制的数据存储，可以通过它来实现数据的持久化存储。\n但是在已经使用redux来管理和存储全局数据的基础上，再去使用localStorage来读写数据，这样不仅是工作量巨大，还容易出错。那么有没有结合redux来达到持久数据存储功能的框架呢？当然，它就是redux-persist。redux-persist会将redux的store中的数据缓存到浏览器的localStorage中。其使用步骤如下：\n（1）首先要安装redux-persist：\nnpm i redux-persist\n复制代码\n\n（2）对于reducer和action的处理不变，只需修改store的生成代码，修改如下：\nimport &#123;createStore&#125; from &#39;redux&#39;\nimport reducers from &#39;..&#x2F;reducers&#x2F;index&#39;\nimport &#123;persistStore, persistReducer&#125; from &#39;redux-persist&#39;;\nimport storage from &#39;redux-persist&#x2F;lib&#x2F;storage&#39;;\nimport autoMergeLevel2 from &#39;redux-persist&#x2F;lib&#x2F;stateReconciler&#x2F;autoMergeLevel2&#39;;\nconst persistConfig &#x3D; &#123;\n    key: &#39;root&#39;,\n    storage: storage,\n    stateReconciler: autoMergeLevel2 &#x2F;&#x2F; 查看 &#39;Merge Process&#39; 部分的具体情况\n&#125;;\nconst myPersistReducer &#x3D; persistReducer(persistConfig, reducers)\nconst store &#x3D; createStore(myPersistReducer)\nexport const persistor &#x3D; persistStore(store)\nexport default store\n复制代码\n\n（3）在index.js中，将PersistGate标签作为网页内容的父标签：\nimport React from &#39;react&#39;;\nimport ReactDOM from &#39;react-dom&#39;;\nimport &#123;Provider&#125; from &#39;react-redux&#39;\nimport store from &#39;.&#x2F;redux&#x2F;store&#x2F;store&#39;\nimport &#123;persistor&#125; from &#39;.&#x2F;redux&#x2F;store&#x2F;store&#39;\nimport &#123;PersistGate&#125; from &#39;redux-persist&#x2F;lib&#x2F;integration&#x2F;react&#39;;\nReactDOM.render(&lt;Provider store&#x3D;&#123;store&#125;&gt;\n            &lt;PersistGate loading&#x3D;&#123;null&#125; persistor&#x3D;&#123;persistor&#125;&gt;\n                &#123;&#x2F;*网页内容*&#x2F;&#125;\n            &lt;&#x2F;PersistGate&gt;\n        &lt;&#x2F;Provider&gt;, document.getElementById(&#39;root&#39;));\n复制代码\n\n这就完成了通过redux-persist实现React持久化本地数据存储的简单应用。\n5. 对 React 和 Vue 的理解，它们的异同相似之处：\n\n都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库\n都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。\n都使用了Virtual DOM（虚拟DOM）提高重绘性能\n都有props的概念，允许组件间的数据传递\n都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性\n\n不同之处：\n1）数据流\nVue默认支持数据双向绑定，而React一直提倡单向数据流\n2）虚拟DOM\nVue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。\n\nVue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\n对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent&#x2F;shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。\n\n3）组件化\nReact与Vue最大的不同是模板的编写。\n\nVue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。\nReact推荐你所有的模板通用JavaScript的语法扩展——JSX书写。\n\n具体来讲：React中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 完组件之后，还需要在 components 中再声明下。\n4）监听数据变化的实现原理不同\n\nVue 通过 getter&#x2F;setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能\nReact 默认是通过比较引用的方式进行的，如果不优化（PureComponent&#x2F;shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。\n\n5）高阶组件\nreact可以通过高阶组件（Higher Order Components– HOC）来扩展，而vue需要通过mixins来扩展。\n原因高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不采用HOC来实现。\n6）构建工具\n两者都有自己的构建工具\n\nReact &#x3D;&#x3D;&gt; Create React APP\nVue &#x3D;&#x3D;&gt; vue-cli\n\n7）跨平台\n\nReact &#x3D;&#x3D;&gt; React Native\nVue &#x3D;&#x3D;&gt; Weex\n\n6. 可以使用TypeScript写React应用吗？怎么操作？（1）如果还未创建 Create React App 项目\n\n直接创建一个具有 typescript 的 Create React App 项目：\n\n npx create-react-app demo --typescript\n复制代码\n\n（2）如果已经创建了 Create React App 项目，需要将 typescript 引入到已有项目中\n\n通过命令将 typescript 引入项目：\n\nnpm install --save typescript @types&#x2F;node @types&#x2F;react @types&#x2F;react-dom @types&#x2F;jest\n复制代码\n\n\n将项目中任何 后缀名为 ‘.js’ 的 JavaScript 文件重命名为 TypeScript 文件即后缀名为 ‘.tsx’（例如 src&#x2F;index.js 重命名为 src&#x2F;index.tsx ）\n\n7. React 设计思路，它的理念是什么？（1）编写简单直观的代码\nReact最大的价值不是高性能的虚拟DOM、封装的事件机制、服务器端渲染，而是声明式的直观的编码方式。react文档第一条就是声明式，React 使创建交互式 UI 变得轻而易举。为应用的每一个状态设计简洁的视图，当数据改变时 React 能有效地更新并正确地渲染组件。 以声明式编写 UI，可以让代码更加可靠，且方便调试。\n（2）简化可复用的组件\nReact框架里面使用了简化的组件模型，但更彻底地使用了组件化的概念。React将整个UI上的每一个功能模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成更大的组件。React的组件具有如下的特性∶\n\n可组合：简单组件可以组合为复杂的组件\n可重用：每个组件都是独立的，可以被多个组件使用\n可维护：和组件相关的逻辑和UI都封装在了组件的内部，方便维护\n可测试：因为组件的独立性，测试组件就变得方便很多。\n\n（3) Virtual DOM\n真实页面对应一个 DOM 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作 DOM 来进行更新。 DOM 操作非常昂贵。在前端开发中，性能消耗最大的就是 DOM 操作，而且这部分代码会让整体项目的代码变得难 以维护。React 把真实 DOM 树转换成 JavaScript 对象树，也就是 Virtual DOM，每次数据更新后，重新计算 Virtual DOM，并和上一次生成的 Virtual DOM 做对比，对发生变化的部分做批量更新。React 也提供了直观的 shouldComponentUpdate 生命周期回调，来减少数据变化后不必要的 Virtual DOM 对比过程，以保证性能。\n（4）函数式编程\nReact 把过去不断重复构建 UI 的过程抽象成了组件，且在给定参数的情况下约定渲染对应的 UI 界面。React 能充分利用很多函数式方法去减少冗余代码。此外，由于它本身就是简单函数，所以易于测试。\n（5）一次学习，随处编写\n无论现在正在使用什么技术栈，都可以随时引入 React来开发新特性，而不需要重写现有代码。\nReact 还可以使用 Node 进行服务器渲染，或使用 React Native 开发原生移动应用。因为 React 组件可以映射为对应的原生控件。在输出的时候，是输出 Web DOM，还是 Android 控件，还是 iOS 控件，就由平台本身决定了。所以，react很方便和其他平台集成\n8. React中props.children和React.Children的区别在React中，当涉及组件嵌套，在父组件中使用props.children把所有子组件显示出来。如下：\nfunction ParentComponent(props)&#123;\n\treturn (\n\t\t&lt;div&gt;\n\t\t\t&#123;props.children&#125;\n\t\t&lt;&#x2F;div&gt;\n\t)\n&#125;\n复制代码\n\n如果想把父组件中的属性传给所有的子组件，需要使用React.Children方法。\n比如，把几个Radio组合起来，合成一个RadioGroup，这就要求所有的Radio具有同样的name属性值。可以这样：把Radio看做子组件，RadioGroup看做父组件，name的属性值在RadioGroup这个父组件中设置。\n首先是子组件：\n&#x2F;&#x2F;子组件\nfunction RadioOption(props) &#123;\n  return (\n    &lt;label&gt;\n      &lt;input type&#x3D;&quot;radio&quot; value&#x3D;&#123;props.value&#125; name&#x3D;&#123;props.name&#125; &#x2F;&gt;\n      &#123;props.label&#125;\n    &lt;&#x2F;label&gt;\n  )\n&#125;\n复制代码\n\n然后是父组件，不仅需要把它所有的子组件显示出来，还需要为每个子组件赋上name属性和值：\n&#x2F;&#x2F;父组件用,props是指父组件的props\nfunction renderChildren(props) &#123;\n    \n  &#x2F;&#x2F;遍历所有子组件\n  return React.Children.map(props.children, child &#x3D;&gt; &#123;\n    if (child.type &#x3D;&#x3D;&#x3D; RadioOption)\n      return React.cloneElement(child, &#123;\n        &#x2F;&#x2F;把父组件的props.name赋值给每个子组件\n        name: props.name\n      &#125;)\n    else\n      return child\n  &#125;)\n&#125;\n&#x2F;&#x2F;父组件\nfunction RadioGroup(props) &#123;\n  return (\n    &lt;div&gt;\n      &#123;renderChildren(props)&#125;\n    &lt;&#x2F;div&gt;\n  )\n&#125;\nfunction App() &#123;\n  return (\n    &lt;RadioGroup name&#x3D;&quot;hello&quot;&gt;\n      &lt;RadioOption label&#x3D;&quot;选项一&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;\n      &lt;RadioOption label&#x3D;&quot;选项二&quot; value&#x3D;&quot;2&quot; &#x2F;&gt;\n      &lt;RadioOption label&#x3D;&quot;选项三&quot; value&#x3D;&quot;3&quot; &#x2F;&gt;\n    &lt;&#x2F;RadioGroup&gt;\n  )\n&#125;\nexport default App;\n复制代码\n\n以上，React.Children.map让我们对父组件的所有子组件又更灵活的控制。\n9. React的状态提升是什么？使用场景有哪些？React的状态提升就是用户对子组件操作，子组件不改变自己的状态，通过自己的props把这个操作改变的数据传递给父组件，改变父组件的状态，从而改变受父组件控制的所有子组件的状态，这也是React单项数据流的特性决定的。官方的原话是：共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)”。\n概括来说就是将多个组件需要共享的状态提升到它们最近的父组件上，在父组件上改变这个状态然后通过props分发给子组件。\n一个简单的例子，父组件中有两个input子组件，如果想在第一个输入框输入数据，来改变第二个输入框的值，这就需要用到状态提升。\nclass Father extends React.Component &#123;\n    constructor(props) &#123;\n        super(props)\n        this.state &#x3D; &#123;\n            Value1: &#39;&#39;,\n            Value2: &#39;&#39;\n        &#125;\n    &#125;\n    value1Change(aa) &#123;\n        this.setState(&#123;\n            Value1: aa\n        &#125;)\n    &#125;\n    value2Change(bb) &#123;\n        this.setState(&#123;\n            Value2: bb\n        &#125;)\n    &#125;\n    render() &#123;\n        return (\n            &lt;div style&#x3D;&#123;&#123; padding: &quot;100px&quot; &#125;&#125;&gt;\n                &lt;Child1 value1&#x3D;&#123;this.state.Value1&#125; onvalue1Change&#x3D;&#123;this.value1Change.bind(this)&#125; &#x2F;&gt;\n                \n\n                &lt;Child2 value2&#x3D;&#123;this.state.Value1&#125; &#x2F;&gt;\n            &lt;&#x2F;div&gt;\n        )\n    &#125;\n&#125;\nclass Child1 extends React.Component &#123;\n    constructor(props) &#123;\n        super(props)\n    &#125;\n    changeValue(e) &#123;\n        this.props.onvalue1Change(e.target.value)\n    &#125;\n    render() &#123;\n        return (\n            &lt;input value&#x3D;&#123;this.props.Value1&#125; onChange&#x3D;&#123;this.changeValue.bind(this)&#125; &#x2F;&gt;\n        )\n    &#125;\n&#125;\nclass Child2 extends React.Component &#123;\n    constructor(props) &#123;\n        super(props)\n    &#125;\n    render() &#123;\n        return (\n            &lt;input value&#x3D;&#123;this.props.value2&#125; &#x2F;&gt;\n        )\n    &#125;\n&#125;\n \nReactDOM.render(\n    &lt;Father &#x2F;&gt;,\n    document.getElementById(&#39;root&#39;)\n)\n复制代码\n\n10. React中constructor和getInitialState的区别?两者都是用来初始化state的。前者是ES6中的语法，后者是ES5中的语法，新版本的React中已经废弃了该方法。\ngetInitialState是ES5中的方法，如果使用createClass方法创建一个Component组件，可以自动调用它的getInitialState方法来获取初始化的State对象，\nvar APP &#x3D; React.creatClass (&#123;\n  getInitialState() &#123;\n    return &#123; \n        userName: &#39;hi&#39;,\n        userId: 0\n     &#125;;\n　&#125;\n&#125;)\n复制代码\n\nReact在ES6的实现中去掉了getInitialState这个hook函数，规定state在constructor中实现，如下：\nClass App extends React.Component&#123;\n    constructor(props)&#123;\n      super(props);\n      this.state&#x3D;&#123;&#125;;\n    &#125;\n  &#125;\n复制代码\n\n11. React的严格模式如何使用，有什么用处？StrictMode 是一个用来突出显示应用程序中潜在问题的工具。与 Fragment 一样，StrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。 可以为应用程序的任何部分启用严格模式。例如：\nimport React from &#39;react&#39;;\nfunction ExampleApplication() &#123;\n  return (\n    &lt;div&gt;\n      &lt;Header &#x2F;&gt;\n      &lt;React.StrictMode&gt;        \n        &lt;div&gt;\n          &lt;ComponentOne &#x2F;&gt;\n          &lt;ComponentTwo &#x2F;&gt;\n        &lt;&#x2F;div&gt;\n      &lt;&#x2F;React.StrictMode&gt;      \n      &lt;Footer &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n复制代码\n\n在上述的示例中，不会对 Header 和 Footer 组件运行严格模式检查。但是，ComponentOne 和 ComponentTwo 以及它们的所有后代元素都将进行检查。\nStrictMode 目前有助于：\n\n识别不安全的生命周期\n关于使用过时字符串 ref API 的警告\n关于使用废弃的 findDOMNode 方法的警告\n检测意外的副作用\n检测过时的 context API\n\n12. 在React中遍历的方法有哪些？（1）遍历数组：map &amp;&amp; forEach\nimport React from &#39;react&#39;;\n\nclass App extends React.Component &#123;\n  render() &#123;\n    let arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;];\n    return (\n      &lt;ul&gt;\n        &#123;\n          arr.map((item, index) &#x3D;&gt; &#123;\n            return &lt;li key&#x3D;&#123;index&#125;&gt;&#123;item&#125;&lt;&#x2F;li&gt;\n          &#125;)\n        &#125;\n      &lt;&#x2F;ul&gt;\n    )\n  &#125;\n&#125;\n\nclass App extends React.Component &#123;\n  render() &#123;\n    let arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;];\n    return (\n      &lt;ul&gt;\n        &#123;\n          arr.forEach((item, index) &#x3D;&gt; &#123;\n            return &lt;li key&#x3D;&#123;index&#125;&gt;&#123;item&#125;&lt;&#x2F;li&gt;\n          &#125;)\n        &#125;\n      &lt;&#x2F;ul&gt;\n    )\n  &#125;\n&#125;\n复制代码\n\n（2）遍历对象：map &amp;&amp; for in\nclass App extends React.Component &#123;\n  render() &#123;\n    let obj &#x3D; &#123;\n      a: 1,\n      b: 2,\n      c: 3\n    &#125;\n    return (\n      &lt;ul&gt;\n        &#123;\n          (() &#x3D;&gt; &#123;\n            let domArr &#x3D; [];\n            for(const key in obj) &#123;\n              if(obj.hasOwnProperty(key)) &#123;\n                const value &#x3D; obj[key]\n                domArr.push(&lt;li key&#x3D;&#123;key&#125;&gt;&#123;value&#125;&lt;&#x2F;li&gt;)\n              &#125;\n            &#125;\n            return domArr;\n          &#125;)()\n        &#125;\n      &lt;&#x2F;ul&gt;\n    )\n  &#125;\n&#125;\n\n&#x2F;&#x2F; Object.entries() 把对象转换成数组\nclass App extends React.Component &#123;\n  render() &#123;\n    let obj &#x3D; &#123;\n      a: 1,\n      b: 2,\n      c: 3\n    &#125;\n    return (\n      &lt;ul&gt;\n        &#123;\n          Object.entries(obj).map(([key, value], index) &#x3D;&gt; &#123;   &#x2F;&#x2F; item是一个数组，把item解构，写法是[key, value]\n            return &lt;li key&#x3D;&#123;key&#125;&gt;&#123;value&#125;&lt;&#x2F;li&gt;\n          &#125;) \n        &#125;\n      &lt;&#x2F;ul&gt;\n    )\n  &#125;\n&#125;\n复制代码\n\n13. 在React中页面重新加载时怎样保留数据？这个问题就设计到了数据持久化， 主要的实现方式有以下几种：\n\nRedux： 将页面的数据存储在redux中，在重新加载页面时，获取Redux中的数据；\ndata.js： 使用webpack构建的项目，可以建一个文件，data.js，将数据保存data.js中，跳转页面后获取；\nsessionStorge： 在进入选择地址页面之前，componentWillUnMount的时候，将数据存储到sessionStorage中，每次进入页面判断sessionStorage中有没有存储的那个值，有，则读取渲染数据；没有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页面，清掉存储的sessionStorage，保证下次进入是初始化的数据\nhistory API： History API 的 pushState 函数可以给历史记录关联一个任意的可序列化 state，所以可以在路由 push 的时候将当前页面的一些信息存到 state 中，下次返回到这个页面的时候就能从 state 里面取出离开前的数据重新渲染。react-router 直接可以支持。这个方法适合一些需要临时存储的场景。\n\n14. 同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？\nreact：包含react所必须的核心代码\nreact-dom：react渲染在不同平台所需要的核心代码\nbabel：将jsx转换成React代码的工具\n\n15. React必须使用JSX吗？React 并不强制要求使用 JSX。当不想在构建环境中配置有关 JSX 编译时，不在 React 中使用 JSX 会更加方便。\n每个 JSX 元素只是调用 React.createElement(component, props, ...children) 的语法糖。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。\n例如，用 JSX 编写的代码：\nclass Hello extends React.Component &#123;\n  render() &#123;\n    return &lt;div&gt;Hello &#123;this.props.toWhat&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\nReactDOM.render(\n  &lt;Hello toWhat&#x3D;&quot;World&quot; &#x2F;&gt;,\n  document.getElementById(&#39;root&#39;)\n);\n复制代码\n\n可以编写为不使用 JSX 的代码：\nclass Hello extends React.Component &#123;\n  render() &#123;\n    return React.createElement(&#39;div&#39;, null, &#96;Hello $&#123;this.props.toWhat&#125;&#96;);\n  &#125;\n&#125;\nReactDOM.render(\n  React.createElement(Hello, &#123;toWhat: &#39;World&#39;&#125;, null),\n  document.getElementById(&#39;root&#39;)\n);\n复制代码\n\n16. 为什么使用jsx的组件中没有看到使用react却需要引入react？本质上来说JSX是React.createElement(component, props, ...children)方法的语法糖。在React 17之前，如果使用了JSX，其实就是在使用React， babel 会把组件转换为 CreateElement 形式。在React 17之后，就不再需要引入，因为 babel 已经可以帮我们自动引入react。\n17. 在React中怎么使用async&#x2F;await？async&#x2F;await是ES7标准中的新特性。如果是使用React官方的脚手架创建的项目，就可以直接使用。如果是在自己搭建的webpack配置的项目中使用，可能会遇到 regeneratorRuntime is not defined 的异常错误。那么我们就需要引入babel，并在babel中配置使用async&#x2F;await。可以利用babel的 transform-async-to-module-method 插件来转换其成为浏览器支持的语法，虽然没有性能的提升，但对于代码编写体验要更好。\n18. React.Children.map和js的map有什么区别？JavaScript中的map不会对为null或者undefined的数据进行处理，而React.Children.map中的map可以处理React.Children为null或者undefined的情况。\n19. 对React SSR的理解服务端渲染是数据与模版组成的html，即 HTML &#x3D; 数据 ＋ 模版。将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序。页面没使用服务渲染，当请求页面时，返回的body里为空，之后执行js将html结构注入到body里，结合css显示出来;\nSSR的优势：\n\n对SEO友好\n所有的模版、图片等资源都存在服务器端\n一个html返回所有数据\n减少HTTP请求\n响应快、用户体验好、首屏渲染快\n\n1）更利于SEO\n不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本使用了React或者其它MVVM框架之后，页面大多数DOM元素都是在客户端根据js动态生成，可供爬虫抓取分析的内容大大减少。另外，浏览器爬虫不会等待我们的数据完成之后再去抓取页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。\n2）更利于首屏渲染\n首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。\nSSR的局限：\n1）服务端压力较大\n本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源;\n2）开发条件受限\n在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制;\n3）学习成本相对较高 除了对webpack、MVVM框架要熟悉，还需要掌握node、 Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。\n时间耗时比较：\n1）数据请求\n由服务端请求首屏数据，而不是客户端请求首屏数据，这是”快”的一个主要原因。服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差\n\n客户端数据请求\n\n\n\n服务端数据请求\n\n 2）html渲染 服务端渲染是先向后端服务器请求数据，然后生成完整首屏 html返回给浏览器；而客户端渲染是等js代码下载、加载、解析完成后再请求数据渲染，等待的过程页面是什么都没有的，就是用户看到的白屏。就是服务端渲染不需要等待js代码下载完成并请求数据，就可以返回一个已有完整数据的首屏页面。\n\n非ssr html渲染\n\n\n\nssr html渲染\n\n\n20. 为什么 React 要用 JSX？JSX 是一个 JavaScript 的语法扩展，或者说是一个类似于 XML 的 ECMAScript 语法扩展。它本身没有太多的语法定义，也不期望引入更多的标准。\n其实 React 本身并不强制使用 JSX。在没有 JSX 的时候，React 实现一个组件依赖于使用 React.createElement 函数。代码如下：\nclass Hello extends React.Component &#123;\n  render() &#123;\n    return React.createElement(\n        &#39;div&#39;,\n        null, \n        &#96;Hello $&#123;this.props.toWhat&#125;&#96;\n      );\n  &#125;\n&#125;\nReactDOM.render(\n  React.createElement(Hello, &#123;toWhat: &#39;World&#39;&#125;, null),\n  document.getElementById(&#39;root&#39;)\n);\n复制代码\n\n而 JSX 更像是一种语法糖，通过类似 XML 的描述方式，描写函数对象。在采用 JSX 之后，这段代码会这样写：\nclass Hello extends React.Component &#123;\n  render() &#123;\n    return &lt;div&gt;Hello &#123;this.props.toWhat&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\nReactDOM.render(\n  &lt;Hello toWhat&#x3D;&quot;World&quot; &#x2F;&gt;,\n  document.getElementById(&#39;root&#39;)\n);\n复制代码\n\n通过对比，可以清晰地发现，代码变得更为简洁，而且代码结构层次更为清晰。\n因为 React 需要将组件转化为虚拟 DOM 树，所以在编写代码时，实际上是在手写一棵结构树。而XML 在树结构的描述上天生具有可读性强的优势。\n但这样可读性强的代码仅仅是给写程序的同学看的，实际上在运行的时候，会使用 Babel 插件将 JSX 语法的代码还原为 React.createElement 的代码。\n总结： JSX 是一个 JavaScript 的语法扩展，结构类似 XML。JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。\nReact 团队并不想引入 JavaScript 本身以外的开发体系。而是希望通过合理的关注点分离保持组件开发的纯粹性。\n22. React 中的高阶组件运用了什么设计模式？使用了装饰模式，高阶组件的运用：\nfunction withWindowWidth(BaseComponent) &#123;\n  class DerivedClass extends React.Component &#123;\n    state &#x3D; &#123;\n      windowWidth: window.innerWidth,\n    &#125;\n    onResize &#x3D; () &#x3D;&gt; &#123;\n      this.setState(&#123;\n        windowWidth: window.innerWidth,\n      &#125;)\n    &#125;\n    componentDidMount() &#123;\n      window.addEventListener(&#39;resize&#39;, this.onResize)\n    &#125;\n    componentWillUnmount() &#123;\n      window.removeEventListener(&#39;resize&#39;, this.onResize);\n    &#125;\n    render() &#123;\n      return &lt;BaseComponent &#123;...this.props&#125; &#123;...this.state&#125;&#x2F;&gt;\n    &#125;\n  &#125;\n  return DerivedClass;\n&#125;\nconst MyComponent &#x3D; (props) &#x3D;&gt; &#123;\n  return &lt;div&gt;Window width is: &#123;props.windowWidth&#125;&lt;&#x2F;div&gt;\n&#125;;\nexport default withWindowWidth(MyComponent);\n复制代码\n\n装饰模式的特点是不需要改变 被装饰对象 本身，而只是在外面套一个外壳接口。JavaScript 目前已经有了原生装饰器的提案，其用法如下：\n@testable\n   class MyTestableClass &#123;\n&#125;\n\n作者：CUGGZ链接：https://juejin.cn/post/6940942549305524238来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","slug":"面试题笔记——REACT篇(下)","date":"2022-04-10T03:03:54.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"0b7c0bb77310ab4c9c1a186c882be3d6","title":"面试题笔记——REACT篇(上)","content":"\n一、组件基础1. React 事件机制&lt;div onClick&#x3D;&#123;this.handleClick.bind(this)&#125;&gt;点我&lt;&#x2F;div&gt;\n复制代码\n\nReact并不是将click事件绑定到了div的真实DOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。\n除此之外，冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件（SyntheticEvent）。因此如果不想要是事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopProppagation()方法。  JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 document 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。\n另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。\n实现合成事件的目的如下：\n\n合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力；\n对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。\n\n2. React的事件和普通的HTML事件有什么不同？区别：\n\n对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；\n对于事件函数处理语法，原生事件为字符串，react 事件为函数；\nreact 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。\n\n合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：\n\n兼容所有浏览器，更好的跨平台；\n将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。\n方便 react 统一管理和事务机制。\n\n事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。\n3. React 组件中怎么做事件代理？它的原理是什么？React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。\n在React底层，主要对合成事件做了两件事：\n\n事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。\n自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。\n\n4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代这三者是目前react解决代码复用的主要方式：\n\n高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。\nrender props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。\n通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。\n\n（1）HOC 官方解释∶\n\n\n\n\n\n\n\n\n\n高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。\n简言之，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。\n&#x2F;&#x2F; hoc的定义\nfunction withSubscription(WrappedComponent, selectData) &#123;\n  return class extends React.Component &#123;\n    constructor(props) &#123;\n      super(props);\n      this.state &#x3D; &#123;\n        data: selectData(DataSource, props)\n      &#125;;\n    &#125;\n    &#x2F;&#x2F; 一些通用的逻辑处理\n    render() &#123;\n      &#x2F;&#x2F; ... 并使用新数据渲染被包装的组件!\n      return &lt;WrappedComponent data&#x3D;&#123;this.state.data&#125; &#123;...this.props&#125; &#x2F;&gt;;\n    &#125;\n  &#125;;\n\n&#x2F;&#x2F; 使用\nconst BlogPostWithSubscription &#x3D; withSubscription(BlogPost,\n  (DataSource, props) &#x3D;&gt; DataSource.getBlogPost(props.id));\n复制代码\n\nHOC的优缺点∶\n\n优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。\n缺点∶ hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖\n\n（2）Render props 官方解释∶\n\n\n\n\n\n\n\n\n\n“render prop”是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术\n具有render prop 的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，”render”的命名可以是任何其他有效的标识符。\n&#x2F;&#x2F; DataProvider组件内部的渲染逻辑如下\nclass DataProvider extends React.Components &#123;\n     state &#x3D; &#123;\n    name: &#39;Tom&#39;\n  &#125;\n\n    render() &#123;\n    return (\n        &lt;div&gt;\n          &lt;p&gt;共享数据组件自己内部的渲染逻辑&lt;&#x2F;p&gt;\n          &#123; this.props.render(this.state) &#125;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 调用方式\n&lt;DataProvider render&#x3D;&#123;data &#x3D;&gt; (\n  &lt;h1&gt;Hello &#123;data.name&#125;&lt;&#x2F;h1&gt;\n)&#125;&#x2F;&gt;\n\n复制代码\n\n由此可以看到，render props的优缺点也很明显∶\n\n优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。\n缺点：无法在 return 语句外访问数据、嵌套写法不够优雅\n\n（3）Hooks 官方解释∶\n\n\n\n\n\n\n\n\n\nHook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。\n&#x2F;&#x2F; 自定义一个获取订阅数据的hook\nfunction useSubscription() &#123;\n  const data &#x3D; DataSource.getComments();\n  return [data];\n&#125;\n&#x2F;&#x2F; \nfunction CommentList(props) &#123;\n  const &#123;data&#125; &#x3D; props;\n  const [subData] &#x3D; useSubscription();\n    ...\n&#125;\n&#x2F;&#x2F; 使用\n&lt;CommentList data&#x3D;&#39;hello&#39; &#x2F;&gt;\n复制代码\n\n以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶\n\n使用直观；\n解决hoc的prop 重名问题；\n解决render props 因共享数据 而出现嵌套地狱的问题；\n能在return之外使用数据的问题。\n\n需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。\n总结∶ Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。\n5. 对React-Fiber的理解，它解决了什么问题？React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿。\n为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。\n所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:\n\n分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验；\n给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。\n\n核心思想: Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。\n6. React.Component 和 React.PureComponent 的区别PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。\n在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。\n不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。\n使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。\n7. Component, Element, Instance 之间有什么区别和联系？\n元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。\n组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。\n实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。\n\n函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。\n8. React.createClass和extends Component的区别有哪些？React.createClass和extends Component的bai区别主要在于：\n（1）语法区别\n\ncreateClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。\ncreateClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。\n\n（2）propType 和 getDefaultProps\n\nReact.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.\nReact.Component：通过设置两个属性propTypes和defaultProps\n\n（3）状态的区别\n\nReact.createClass：通过getInitialState()方法返回一个包含初始值的对象\nReact.Component：通过constructor设置初始状态\n\n（4）this区别\n\nReact.createClass：会正确绑定this\nReact.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。\n\n（5）Mixins\n\nReact.createClass：使用 React.createClass 的话，可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。\n如果使用 ES6 的方式来创建组件，那么 React mixins 的特性将不能被使用了。\n\n9. React 高阶组件是什么，和普通组件有什么区别，适用什么场景官方解释∶\n\n\n\n\n\n\n\n\n\n高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。\n高阶组件（HOC）就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种组件的设计模式，这种设计模式是由react自身的组合性质必然产生的。我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。\n&#x2F;&#x2F; hoc的定义\nfunction withSubscription(WrappedComponent, selectData) &#123;\n  return class extends React.Component &#123;\n    constructor(props) &#123;\n      super(props);\n      this.state &#x3D; &#123;\n        data: selectData(DataSource, props)\n      &#125;;\n    &#125;\n    &#x2F;&#x2F; 一些通用的逻辑处理\n    render() &#123;\n      &#x2F;&#x2F; ... 并使用新数据渲染被包装的组件!\n      return &lt;WrappedComponent data&#x3D;&#123;this.state.data&#125; &#123;...this.props&#125; &#x2F;&gt;;\n    &#125;\n  &#125;;\n\n&#x2F;&#x2F; 使用\nconst BlogPostWithSubscription &#x3D; withSubscription(BlogPost,\n  (DataSource, props) &#x3D;&gt; DataSource.getBlogPost(props.id));\n复制代码\n\n1）HOC的优缺点\n\n优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。\n缺点∶hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖\n\n2）适用场景\n\n代码复用，逻辑抽象\n渲染劫持\nState 抽象和更改\nProps 更改\n\n3）具体应用例子\n\n权限控制： 利用高阶组件的 条件渲染 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别和 页面元素级别\n\n&#x2F;&#x2F; HOC.js\nfunction withAdminAuth(WrappedComponent) &#123;\n    return class extends React.Component &#123;\n        state &#x3D; &#123;\n            isAdmin: false,\n        &#125;\n        async UNSAFE_componentWillMount() &#123;\n            const currentRole &#x3D; await getCurrentUserRole();\n            this.setState(&#123;\n                isAdmin: currentRole &#x3D;&#x3D;&#x3D; &#39;Admin&#39;,\n            &#125;);\n        &#125;\n        render() &#123;\n            if (this.state.isAdmin) &#123;\n                return &lt;WrappedComponent &#123;...this.props&#125; &#x2F;&gt;;\n            &#125; else &#123;\n                return (&lt;div&gt;您没有权限查看该页面，请联系管理员！&lt;&#x2F;div&gt;);\n            &#125;\n        &#125;\n    &#125;;\n&#125;\n\n&#x2F;&#x2F; pages&#x2F;page-a.js\nclass PageA extends React.Component &#123;\n    constructor(props) &#123;\n        super(props);\n        &#x2F;&#x2F; something here...\n    &#125;\n    UNSAFE_componentWillMount() &#123;\n        &#x2F;&#x2F; fetching data\n    &#125;\n    render() &#123;\n        &#x2F;&#x2F; render page with data\n    &#125;\n&#125;\nexport default withAdminAuth(PageA);\n\n\n&#x2F;&#x2F; pages&#x2F;page-b.js\nclass PageB extends React.Component &#123;\n    constructor(props) &#123;\n        super(props);\n    &#x2F;&#x2F; something here...\n        &#125;\n    UNSAFE_componentWillMount() &#123;\n    &#x2F;&#x2F; fetching data\n    &#125;\n    render() &#123;\n    &#x2F;&#x2F; render page with data\n    &#125;\n&#125;\nexport default withAdminAuth(PageB);\n复制代码\n\n\n组件渲染性能追踪： 借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录∶\n\nclass Home extends React.Component &#123;\n        render() &#123;\n            return (&lt;h1&gt;Hello World.&lt;&#x2F;h1&gt;);\n        &#125;\n    &#125;\n    function withTiming(WrappedComponent) &#123;\n        return class extends WrappedComponent &#123;\n            constructor(props) &#123;\n                super(props);\n                this.start &#x3D; 0;\n                this.end &#x3D; 0;\n            &#125;\n            UNSAFE_componentWillMount() &#123;\n                super.componentWillMount &amp;&amp; super.componentWillMount();\n                this.start &#x3D; Date.now();\n            &#125;\n            componentDidMount() &#123;\n                super.componentDidMount &amp;&amp; super.componentDidMount();\n                this.end &#x3D; Date.now();\n                console.log(&#96;$&#123;WrappedComponent.name&#125; 组件渲染时间为 $&#123;this.end - this.start&#125; ms&#96;);\n            &#125;\n            render() &#123;\n                return super.render();\n            &#125;\n        &#125;;\n    &#125;\n\n    export default withTiming(Home);   \n\n\n复制代码\n\n注意：withTiming 是利用 反向继承 实现的一个高阶组件，功能是计算被包裹组件（这里是 Home 组件）的渲染时间。\n\n页面复用\n\nconst withFetching &#x3D; fetching &#x3D;&gt; WrappedComponent &#x3D;&gt; &#123;\n    return class extends React.Component &#123;\n        state &#x3D; &#123;\n            data: [],\n        &#125;\n        async UNSAFE_componentWillMount() &#123;\n            const data &#x3D; await fetching();\n            this.setState(&#123;\n                data,\n            &#125;);\n        &#125;\n        render() &#123;\n            return &lt;WrappedComponent data&#x3D;&#123;this.state.data&#125; &#123;...this.props&#125; &#x2F;&gt;;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; pages&#x2F;page-a.js\nexport default withFetching(fetching(&#39;science-fiction&#39;))(MovieList);\n&#x2F;&#x2F; pages&#x2F;page-b.js\nexport default withFetching(fetching(&#39;action&#39;))(MovieList);\n&#x2F;&#x2F; pages&#x2F;page-other.js\nexport default withFetching(fetching(&#39;some-other-type&#39;))(MovieList);\n复制代码\n\n10. 对componentWillReceiveProps 的理解该方法当props发生变化时执行，初始化render时不执行，在这个回调函数里面，你可以根据属性的变化，通过调用this.setState()来更新你的组件状态，旧的属性还是可以通过this.props来获取,这里调用更新状态是安全的，并不会触发额外的render调用。\n使用好处： 在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。 可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。\ncomponentWillReceiveProps在初始化render的时候不会执行，它会在Component接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染。\n11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？（1）哪些方法会触发 react 重新渲染?\n\nsetState（）方法被调用\n\nsetState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。\nclass App extends React.Component &#123;\n  state &#x3D; &#123;\n    a: 1\n  &#125;;\n\n  render() &#123;\n    console.log(&quot;render&quot;);\n    return (\n      &lt;React.Fragement&gt;\n        &lt;p&gt;&#123;this.state.a&#125;&lt;&#x2F;p&gt;\n        &lt;button\n          onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n            this.setState(&#123; a: 1 &#125;); &#x2F;&#x2F; 这里并没有改变 a 的值\n          &#125;&#125;\n        &gt;\n          Click me\n        &lt;&#x2F;button&gt;\n        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.setState(null)&#125;&gt;setState null&lt;&#x2F;button&gt;\n        &lt;Child &#x2F;&gt;\n      &lt;&#x2F;React.Fragement&gt;\n    );\n  &#125;\n&#125;\n复制代码\n\n\n父组件重新渲染\n\n只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render\n（2）重新渲染 render 会做些什么?\n\n会对新旧 VNode 进行对比，也就是我们所说的Diff算法。\n对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面\n遍历差异对象，根据差异的类型，根据对应对规则更新VNode\n\nReact 的处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。在 Virtual DOM 没有出现之前，最简单的方法就是直接调用 innerHTML。Virtual DOM厉害的地方并不是说它比直接操作 DOM 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 DOM。React 将 render 函数返回的虚拟 DOM 树与老的进行比较，从而确定 DOM 要不要更新、怎么更新。当 DOM 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setState 一个微小的修改，默认会去遍历整棵树。尽管 React 使用高度优化的 Diff 算法，但是这个过程仍然会损耗性能.\n12. React如何判断什么时候重新渲染组件？组件状态的改变可以因为props的改变，或者直接通过setState方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的shouldComponentUpdate方法默认返回true，这就是导致每次更新都重新渲染的原因。\n当React将要渲染组件时会执行shouldComponentUpdate方法来看它是否返回true（组件应该更新，也就是重新渲染）。所以需要重写shouldComponentUpdate方法让它根据情况返回true或者false来告诉React什么时候重新渲染什么时候跳过重新渲染。\n13. React声明组件有哪几种方法，有什么不同？React 声明组件的三种方式：\n\n函数式定义的无状态组件\nES5原生方式React.createClass定义的组件\nES6形式的extends React.Component定义的组件\n\n（1）无状态函数式组件 它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到state状态的操作 组件不会被实例化，整体渲染性能得到提升，不能访问this对象，不能访问生命周期的方法\n（2）ES5 原生方式 React.createClass &#x2F;&#x2F; RFC React.createClass会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。\n（3）E6继承形式 React.Component &#x2F;&#x2F; RCC 目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。\n无状态组件相对于于后者的区别： 与无状态组件相比，React.createClass和React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。\nReact.createClass与React.Component区别：\n① 函数this自绑定\n\nReact.createClass创建的组件，其每一个成员函数的this都有React自动绑定，函数中的this会被正确设置。\nReact.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。\n\n② 组件属性类型propTypes及其默认props属性defaultProps配置不同\n\nReact.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的\nReact.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。\n\n③ 组件初始状态state的配置不同\n\nReact.createClass创建的组件，其状态state是通过getInitialState方法来配置组件相关的状态；\nReact.Component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。\n\n14. 对有状态组件和无状态组件的理解及使用场景（1）有状态组件\n特点：\n\n是类组件\n有继承\n可以使用this\n可以使用react的生命周期\n使用较多，容易频繁触发生命周期钩子函数，影响性能\n内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。\n\n使用场景：\n\n需要使用到状态的。\n需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可实现）\n\n总结： 类组件可以维护自身的状态变量，即组件的 state ，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。\n（2）无状态组件 特点：\n\n不依赖自身的状态state\n可以是类组件或者函数组件。\n可以完全避免使用 this 关键字。（由于使用的是箭头函数事件无需绑定）\n有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件\n组件内部不维护 state ，只根据外部组件传入的 props 进行渲染的组件，当 props 改变时，组件重新渲染。\n\n使用场景：\n\n组件不需要管理 state，纯展示\n\n优点：\n\n简化代码、专注于 render\n组件不需要被实例化，无生命周期，提升性能。 输出（渲染）只取决于输入（属性），无副作用\n视图和数据的解耦分离\n\n缺点：\n\n无法使用 ref\n无生命周期方法\n无法控制组件的重渲染，因为无法使用shouldComponentUpdate 方法，当组件接受到新的属性时则会重渲染\n\n总结： 组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 &lt;Button/&gt;、 &lt;Input /&gt; 等组件。\n15. 对React中Fragment的理解，它的使用场景是什么？在React中，组件返回的元素只能有一个根元素。为了不添加多余的DOM节点，我们可以使用Fragment标签来包裹所有的元素，Fragment标签不会渲染出任何元素。React官方对Fragment的解释：\n\n\n\n\n\n\n\n\n\nReact 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。\nimport React, &#123; Component, Fragment &#125; from &#39;react&#39;\n\n&#x2F;&#x2F; 一般形式\nrender() &#123;\n  return (\n    &lt;React.Fragment&gt;\n      &lt;ChildA &#x2F;&gt;\n      &lt;ChildB &#x2F;&gt;\n      &lt;ChildC &#x2F;&gt;\n    &lt;&#x2F;React.Fragment&gt;\n  );\n&#125;\n&#x2F;&#x2F; 也可以写成以下形式\nrender() &#123;\n  return (\n    &lt;&gt;\n      &lt;ChildA &#x2F;&gt;\n      &lt;ChildB &#x2F;&gt;\n      &lt;ChildC &#x2F;&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码\n\n16. React如何获取组件对应的DOM元素？可以用ref来获取某个子节点的实例，然后通过当前class组件实例的一些特定属性来直接获取子节点实例。ref有三种实现方法:\n\n字符串格式：字符串格式，这是React16版本之前用得最多的，例如：&lt;p ref=&quot;info&quot;&gt;span&lt;/p&gt;\n函数格式：ref对应一个方法，该方法有一个参数，也就是对应的节点实例，例如：&lt;p ref=&#123;ele =&gt; this.info = ele&#125;&gt;&lt;/p&gt;\ncreateRef方法：React 16提供的一个API，使用React.createRef()来实现\n\n 　　　　　　  \n17. React中可以在render访问refs吗？为什么？&lt;&gt;\n  &lt;span id&#x3D;&quot;name&quot; ref&#x3D;&#123;this.spanRef&#125;&gt;&#123;this.state.title&#125;&lt;&#x2F;span&gt;\n  &lt;span&gt;&#123;\n     this.spanRef.current ? &#39;有值&#39; : &#39;无值&#39;\n  &#125;&lt;&#x2F;span&gt;\n&lt;&#x2F;&gt;\n复制代码\n\n不可以，render 阶段 DOM 还没有生成，无法获取 DOM。DOM 的获取需要在 pre-commit 阶段和 commit 阶段： \n18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景React 官方对 Portals 的定义：\n\n\n\n\n\n\n\n\n\nPortal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案\nPortals 是React 16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。通俗来讲，就是我们 render 一个组件，但这个组件的 DOM 结构并不在本组件内。\nPortals语法如下：\nReactDOM.createPortal(child, container);\n复制代码\n\n\n第一个参数 child 是可渲染的 React 子项，比如元素，字符串或者片段等;\n第二个参数 container 是一个 DOM 元素。\n\n一般情况下，组件的render函数返回的元素会被挂载在它的父级组件上：\nimport DemoComponent from &#39;.&#x2F;DemoComponent&#39;;\nrender() &#123;\n  &#x2F;&#x2F; DemoComponent元素会被挂载在id为parent的div的元素上\n  return (\n    &lt;div id&#x3D;&quot;parent&quot;&gt;\n        &lt;DemoComponent &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n复制代码\n\n然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有overflow: hidden或者z-index的样式设置时，组件有可能被其他元素遮挡，这时就可以考虑要不要使用Portal使组件的挂载脱离父组件。例如：对话框，模态窗。\nimport DemoComponent from &#39;.&#x2F;DemoComponent&#39;;\nrender() &#123;\n  &#x2F;&#x2F; DemoComponent元素会被挂载在id为parent的div的元素上\n  return (\n    &lt;div id&#x3D;&quot;parent&quot;&gt;\n        &lt;DemoComponent &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n复制代码\n\n19. 在React中如何避免不必要的render？React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点：\n\nshouldComponentUpdate 和 PureComponent\n\n在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。\n\n利用高阶组件\n\n在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能\n\n使用 React.memo\n\nReact.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。\n20. 对 React-Intl 的理解，它的工作原理？React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。\nReact-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。\n在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。\n21. 对 React context 的理解在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了。\nContext 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。\n可以把context当做是特定一个组件树内共享的store，用来做数据传递。简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。\nJS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。\n假如以JS的作用域链作为类比，React组件提供的Context对象其实就好比一个提供给子组件访问的作用域，而 Context对象的属性可以看成作用域上的活动对象。由于组件 的 Context 由其父节点链上所有组件通 过 getChildContext（）返回的Context对象组合而成，所以，组件通过Context是可以访问到其父组件链上所有节点组件提供的Context的属性。\n22. 为什么React并不推荐优先考虑使用Context？\nContext目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。\n尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context\n对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。\ncontext的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注\n\n23. React中什么是受控组件和非控组件？（1）受控组件 在使用表单来收集用户输入时，例如&lt;input&gt;&lt;select&gt;&lt;textearea&gt;等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为受控组件，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。\n受控组件更新state的流程：\n\n可以通过初始state中设置表单的默认值\n每当表单的值发生变化时，调用onChange事件处理器\n事件处理器通过事件对象e拿到改变后的状态，并更新组件的state\n一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新\n\n受控组件缺陷： 表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。\n（2）非受控组件 如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。\nReact官方的解释：\n\n\n\n\n\n\n\n\n\n要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref来从 DOM 节点中获取表单数据。 因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。\n例如，下面的代码在非受控组件中接收单个属性：\nclass NameForm extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.handleSubmit &#x3D; this.handleSubmit.bind(this);\n  &#125;\n  handleSubmit(event) &#123;\n    alert(&#39;A name was submitted: &#39; + this.input.value);\n    event.preventDefault();\n  &#125;\n  render() &#123;\n    return (\n      &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;\n        &lt;label&gt;\n          Name:\n          &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;(input) &#x3D;&gt; this.input &#x3D; input&#125; &#x2F;&gt;\n        &lt;&#x2F;label&gt;\n        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot; &#x2F;&gt;\n      &lt;&#x2F;form&gt;\n    );\n  &#125;\n&#125;\n复制代码\n\n总结： 页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。\n24. React中refs的作用是什么？有哪些应用场景？Refs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。Refs 应该谨慎使用，如下场景使用 Refs 比较适合：\n\n处理焦点、文本选择或者媒体的控制\n触发必要的动画\n集成第三方 DOM 库\n\nRefs 是使用 React.createRef() 方法创建的，他通过 ref 属性附加到 React 元素上。要在整个组件中使用 Refs，需要将 ref 在构造函数中分配给其实例属性：\nclass MyComponent extends React.Component &#123;\n  constructor(props) &#123;\n    super(props)\n    this.myRef &#x3D; React.createRef()\n  &#125;\n  render() &#123;\n    return &lt;div ref&#x3D;&#123;this.myRef&#125; &#x2F;&gt;\n  &#125;\n&#125;\n复制代码\n\n由于函数组件没有实例，因此不能在函数组件上直接使用 ref：\nfunction MyFunctionalComponent() &#123;\n  return &lt;input &#x2F;&gt;;\n&#125;\nclass Parent extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.textInput &#x3D; React.createRef();\n  &#125;\n  render() &#123;\n    &#x2F;&#x2F; 这将不会工作！\n    return (\n      &lt;MyFunctionalComponent ref&#x3D;&#123;this.textInput&#125; &#x2F;&gt;\n    );\n  &#125;\n&#125;\n复制代码\n\n但可以通过闭合的帮助在函数组件内部进行使用 Refs：\nfunction CustomTextInput(props) &#123;\n  &#x2F;&#x2F; 这里必须声明 textInput，这样 ref 回调才可以引用它\n  let textInput &#x3D; null;\n  function handleClick() &#123;\n    textInput.focus();\n  &#125;\n  return (\n    &lt;div&gt;\n      &lt;input\n        type&#x3D;&quot;text&quot;\n        ref&#x3D;&#123;(input) &#x3D;&gt; &#123; textInput &#x3D; input; &#125;&#125; &#x2F;&gt;\n      &lt;input\n        type&#x3D;&quot;button&quot;\n        value&#x3D;&quot;Focus the text input&quot;\n        onClick&#x3D;&#123;handleClick&#125;\n      &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );  \n&#125;\n复制代码\n\n注意：\n\n不应该过度的使用 Refs\n\nref 的返回值取决于节点的类型：\n\n当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为他的 current 属性以创建 ref。\n当 ref 属性被用于一个自定义的类组件时，ref 对象将接收该组件已挂载的实例作为他的 current。\n\n\n当在父组件中需要访问子组件中的 ref 时可使用传递 Refs 或回调 Refs。\n\n\n26. React组件的构造函数有什么作用？它是必须的吗？构造函数主要用于两个目的：\n\n通过将对象分配给this.state来初始化本地状态\n将事件处理程序方法绑定到实例上\n\n所以，当在React class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方Demo：\nclass LikeButton extends React.Component &#123;\n  constructor() &#123;\n    super();\n    this.state &#x3D; &#123;\n      liked: false\n    &#125;;\n    this.handleClick &#x3D; this.handleClick.bind(this);\n  &#125;\n  handleClick() &#123;\n    this.setState(&#123;liked: !this.state.liked&#125;);\n  &#125;\n  render() &#123;\n    const text &#x3D; this.state.liked ? &#39;liked&#39; : &#39;haven&#39;t liked&#39;;\n    return (\n      &lt;div onClick&#x3D;&#123;this.handleClick&#125;&gt;\n        You &#123;text&#125; this. Click to toggle.\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\nReactDOM.render(\n  &lt;LikeButton &#x2F;&gt;,\n  document.getElementById(&#39;example&#39;)\n);\n复制代码\n\n构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。\n注意：\n\nconstructor () 必须配上 super(), 如果要在constructor 内部使用 this.props 就要 传入props , 否则不用\nJavaScript中的 bind 每次都会返回一个新的函数, 为了性能等考虑, 尽量在constructor中绑定事件\n\n27. React.forwardRef是什么？它有什么作用？React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：\n\n转发 refs 到 DOM 组件\n在高阶组件中转发 refs\n\n28. 类组件与函数组件有什么异同？相同点： 组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。\n我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。\n不同点：\n\n它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。\n之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。\n性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。\n从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。\n类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。\n\n二、数据管理1. React setState 调用的原理 具体的执行过程如下（源码级解析）：\n\n首先调用了setState 入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；\n\nReactComponent.prototype.setState &#x3D; function (partialState, callback) &#123;\n  this.updater.enqueueSetState(this, partialState);\n  if (callback) &#123;\n    this.updater.enqueueCallback(this, callback, &#39;setState&#39;);\n  &#125;\n&#125;;\n复制代码\n\n\nenqueueSetState 方法将新的 state 放进组件的状态队列里，并调用 enqueueUpdate 来处理将要更新的实例对象；\n\nenqueueSetState: function (publicInstance, partialState) &#123;\n  &#x2F;&#x2F; 根据 this 拿到对应的组件实例\n  var internalInstance &#x3D; getInternalInstanceReadyForUpdate(publicInstance, &#39;setState&#39;);\n  &#x2F;&#x2F; 这个 queue 对应的就是一个组件实例的 state 数组\n  var queue &#x3D; internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue &#x3D; []);\n  queue.push(partialState);\n  &#x2F;&#x2F;  enqueueUpdate 用来处理当前的组件实例\n  enqueueUpdate(internalInstance);\n&#125;\n复制代码\n\n\n在 enqueueUpdate 方法中引出了一个关键的对象——batchingStrategy，该对象所具备的isBatchingUpdates 属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用 batchedUpdates 方法来直接发起更新流程。由此可以推测，batchingStrategy 或许正是 React 内部专门用于管控批量更新的对象。\n\nfunction enqueueUpdate(component) &#123;\n  ensureInjected();\n  &#x2F;&#x2F; 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建&#x2F;更新组件的阶段\n  if (!batchingStrategy.isBatchingUpdates) &#123;\n    &#x2F;&#x2F; 若当前没有处于批量创建&#x2F;更新组件的阶段，则立即更新组件\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  &#125;\n  &#x2F;&#x2F; 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber &#x3D;&#x3D; null) &#123;\n    component._updateBatchNumber &#x3D; updateBatchNumber + 1;\n  &#125;\n&#125;\n复制代码\n\n注意： batchingStrategy 对象可以理解为“锁管理器”。这里的“锁”，是指 React 全局唯一的 isBatchingUpdates 变量，isBatchingUpdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 React 调用 batchedUpdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtyComponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。\n2. React setState 调用之后发生了什么？是同步还是异步？（1）React中setState后发生了什么\n在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。\n在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。\n如果在短时间内频繁setState。React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。\n（2）setState 是同步还是异步的\n假如所有setState是同步的，意味着每执行一次setState时（有可能一个同步代码中，多次setState），都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。所以默认是异步的，但是在一些情况下是同步的。\nsetState 并不是单纯同步&#x2F;异步的，它的表现会因调用场景的不同而不同。在源码中，通过 isBatchingUpdates 来判断setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。\n\n异步： 在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。\n同步： 在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。\n\n一般认为，做异步设计是为了性能优化、减少渲染次数：\n\nsetState设计为异步，可以显著的提升性能。如果每次调用 setState都进行一次更新，那么意味着render函数会被频繁调用，界面重新渲染，这样效率是很低的；最好的办法应该是获取到多个更新，之后进行批量更新；\n如果同步更新了state，但是还没有执行render函数，那么state和props不能保持同步。state和props不能保持一致性，会在开发中产生很多的问题；\n\n3. React中的setState批量更新的过程是什么？调用 setState 时，组件的 state 并不会立即改变， setState 只是把要修改的 state 放入一个队列， React 会优化真正的执行时机，并出于性能原因，会将 React 事件处理程序中的多次React 事件处理程序中的多次 setState 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。\nthis.setState(&#123;\n  count: this.state.count + 1    &#x3D;&#x3D;&#x3D;&gt;    入队，[count+1的任务]\n&#125;);\nthis.setState(&#123;\n  count: this.state.count + 1    &#x3D;&#x3D;&#x3D;&gt;    入队，[count+1的任务，count+1的任务]\n&#125;);\n                                          ↓\n                                         合并 state，[count+1的任务]\n                                          ↓\n                                         执行 count+1的任务\n复制代码\n\n需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。\n4. React中有使用过getDefaultProps吗？它有什么作用？通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：\nvar ShowTitle &#x3D; React.createClass(&#123;\n  getDefaultProps:function()&#123;\n    return&#123;\n      title : &quot;React&quot;\n    &#125;\n  &#125;,\n  render : function()&#123;\n    return &lt;h1&gt;&#123;this.props.title&#125;&lt;&#x2F;h1&gt;\n  &#125;\n&#125;);\n复制代码\n\n5. React中setState的第二个参数作用是什么？setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：\nthis.setState(&#123;\n    key1: newState1,\n    key2: newState2,\n    ...\n&#125;, callback) &#x2F;&#x2F; 第二个参数是 state 更新完成后的回调函数\n复制代码\n\n6. React中的setState和replaceState的区别是什么？（1）setState() setState()用于设置状态对象，其语法如下：\nsetState(object nextState[, function callback])\n复制代码\n\n\nnextState，将要设置的新状态，该状态会和当前的state合并\ncallback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。\n\n合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。\n（2）replaceState() replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下：\nreplaceState(object nextState[, function callback])\n复制代码\n\n\nnextState，将要设置的新状态，该状态会替换当前的state。\ncallback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。\n\n总结： setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。\n7. 在React中组件的this.state和setState有什么区别？this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。\n8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程通过connect和mapStateToProps将state注入到组件中：\nimport &#123; connect &#125; from &#39;react-redux&#39;\nimport &#123; setVisibilityFilter &#125; from &#39;@&#x2F;reducers&#x2F;Todo&#x2F;actions&#39;\nimport Link from &#39;@&#x2F;containers&#x2F;Todo&#x2F;components&#x2F;Link&#39;\n\nconst mapStateToProps &#x3D; (state, ownProps) &#x3D;&gt; (&#123;\n    active: ownProps.filter &#x3D;&#x3D;&#x3D; state.visibilityFilter\n&#125;)\n\nconst mapDispatchToProps &#x3D; (dispatch, ownProps) &#x3D;&gt; (&#123;\n    setFilter: () &#x3D;&gt; &#123;\n        dispatch(setVisibilityFilter(ownProps.filter))\n    &#125;\n&#125;)\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(Link)\n复制代码\n\n上面代码中，active就是注入到Link组件中的状态。 mapStateToProps（state，ownProps）中带有两个参数，含义是∶\n\nstate-store管理的全局状态对象，所有都组件状态数据都存储在该对象中。\nownProps 组件通过props传入的参数。\n\nreducer 到组件经历的过程：\n\nreducer对action对象处理，更新组件状态，并将新的状态值返回store。\n通过connect（mapStateToProps，mapDispatchToProps）（Component）对组件 Component进行升级，此时将状态值从store取出并作为props参数传递到组件。\n\n高阶组件实现源码∶\nimport React from &#39;react&#39;\nimport PropTypes from &#39;prop-types&#39;\n\n&#x2F;&#x2F; 高阶组件 contect \nexport const connect &#x3D; (mapStateToProps, mapDispatchToProps) &#x3D;&gt; (WrappedComponent) &#x3D;&gt; &#123;\n    class Connect extends React.Component &#123;\n        &#x2F;&#x2F; 通过对context调用获取store\n        static contextTypes &#x3D; &#123;\n            store: PropTypes.object\n        &#125;\n\n        constructor() &#123;\n            super()\n            this.state &#x3D; &#123;\n                allProps: &#123;&#125;\n            &#125;\n        &#125;\n\n        &#x2F;&#x2F; 第一遍需初始化所有组件初始状态\n        componentWillMount() &#123;\n            const store &#x3D; this.context.store\n            this._updateProps()\n            store.subscribe(() &#x3D;&gt; this._updateProps()); &#x2F;&#x2F; 加入_updateProps()至store里的监听事件列表\n        &#125;\n\n        &#x2F;&#x2F; 执行action后更新props，使组件可以更新至最新状态（类似于setState）\n        _updateProps() &#123;\n            const store &#x3D; this.context.store;\n            let stateProps &#x3D; mapStateToProps ?\n                mapStateToProps(store.getState(), this.props) : &#123;&#125; &#x2F;&#x2F; 防止 mapStateToProps 没有传入\n            let dispatchProps &#x3D; mapDispatchToProps ?\n                mapDispatchToProps(store.dispatch, this.props) : &#123;\n                                    dispatch: store.dispatch\n                                &#125; &#x2F;&#x2F; 防止 mapDispatchToProps 没有传入\n            this.setState(&#123;\n                allProps: &#123;\n                    ...stateProps,\n                    ...dispatchProps,\n                    ...this.props\n                &#125;\n            &#125;)\n        &#125;\n\n        render() &#123;\n            return &lt;WrappedComponent &#123;...this.state.allProps&#125; &#x2F;&gt;\n        &#125;\n    &#125;\n    return Connect\n&#125;\n复制代码\n\n9. React组件的state和props有什么区别？（1）props\nprops是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。\n（2）state\nstate的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。\n（3）区别\n\nprops 是传递给组件的（类似于函数的形参），而state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。\nprops 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。\nstate 是在组件中创建的，一般在 constructor中初始化 state。state 是多变的、可以修改，每次setState都异步更新的。\n\n10. React中的props为什么是只读的？this.props是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。\n提到函数式编程就要提一个概念：纯函数。它有几个特点：\n\n给定相同的输入，总是返回相同的输出。\n过程没有副作用。\n不依赖外部状态。\n\nthis.props就是汲取了纯函数的思想。props的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用\n11. 在React中组件的props改变时更新组件的有哪些方法？在一个组件传入的props更新时重新渲染该组件常用的方法是在componentWillReceiveProps中将新的props更新到组件的state中（这种state被成为派生状态（Derived State）），从而实现重新渲染。React 16.3中还引入了一个新的钩子函数getDerivedStateFromProps来专门实现这一需求。\n（1）componentWillReceiveProps（已废弃）\n在react的componentWillReceiveProps(nextProps)生命周期中，可以在子组件的render函数执行前，通过this.props获取旧的属性，通过nextProps获取新的props，对比两次props是否相同，从而更新子组件自己的state。\n这样的好处是，可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。\n（2）getDerivedStateFromProps（16.3引入）\n这个生命周期函数是为了替代componentWillReceiveProps存在的，所以在需要使用componentWillReceiveProps时，就可以考虑使用getDerivedStateFromProps来进行替代。\n两者的参数是不相同的，而getDerivedStateFromProps是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。\n需要注意的是，如果props传入的内容不需要影响到你的state，那么就需要返回一个null，这个返回值是必须的，所以尽量将其写到函数的末尾：\nstatic getDerivedStateFromProps(nextProps, prevState) &#123;\n    const &#123;type&#125; &#x3D; nextProps;\n    &#x2F;&#x2F; 当传入的type发生变化的时候，更新state\n    if (type !&#x3D;&#x3D; prevState.type) &#123;\n        return &#123;\n            type,\n        &#125;;\n    &#125;\n    &#x2F;&#x2F; 否则，对于state不进行任何操作\n    return null;\n&#125;\n复制代码\n\n12. React中怎么检验props？验证props的目的是什么？React为我们提供了PropTypes以供验证使用。当我们向Props传入的数据无效（向Props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。\nimport PropTypes from &#39;prop-types&#39;;\n\nclass Greeting extends React.Component &#123;\n  render() &#123;\n    return (\n      &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;\n    );\n  &#125;\n&#125;\n\nGreeting.propTypes &#x3D; &#123;\n  name: PropTypes.string\n&#125;;\n复制代码\n\n当然，如果项目汇中使用了TypeScript，那么就可以不用PropTypes来校验，而使用TypeScript定义接口来校验props。\n三、生命周期1. React的生命周期有哪些？React 通常将组件生命周期分为三个阶段：\n\n装载阶段（Mount），组件第一次在DOM树中被渲染的过程；\n更新过程（Update），组件状态发生变化，重新更新渲染的过程；\n卸载过程（Unmount），组件从DOM树中被移除的过程；\n\n\n1）组件挂载阶段挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：\n\nconstructor\ngetDerivedStateFromProps\nrender\ncomponentDidMount\n\n（1）constructor组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 super(props)，否则无法在构造函数中拿到this。\n如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数Constructor。\nconstructor中通常只做两件事：\n\n初始化组件的 state\n给事件处理方法绑定 this\n\nconstructor(props) &#123;\n  super(props);\n  &#x2F;&#x2F; 不要在构造函数中调用 setState，可以直接给 state 设置初始值\n  this.state &#x3D; &#123; counter: 0 &#125;\n  this.handleClick &#x3D; this.handleClick.bind(this)\n&#125;\n复制代码\n\n（2）getDerivedStateFromPropsstatic getDerivedStateFromProps(props, state)\n复制代码\n\n这是个静态方法，所以不能在这个函数里使用 this，有两个参数 props 和 state，分别指接收到的新参数和当前组件的 state 对象，这个函数会返回一个对象用来更新当前的 state 对象，如果不需要更新可以返回 null。\n该函数会在装载时，接收到新的 props 或者调用了 setState 和 forceUpdate 时被调用。如当接收到新的属性想修改 state ，就可以使用。\n&#x2F;&#x2F; 当 props.counter 变化时，赋值给 state \nclass App extends React.Component &#123;\n  constructor(props) &#123;\n    super(props)\n    this.state &#x3D; &#123;\n      counter: 0\n    &#125;\n  &#125;\n  static getDerivedStateFromProps(props, state) &#123;\n    if (props.counter !&#x3D;&#x3D; state.counter) &#123;\n      return &#123;\n        counter: props.counter\n      &#125;\n    &#125;\n    return null\n  &#125;\n  \n  handleClick &#x3D; () &#x3D;&gt; &#123;\n    this.setState(&#123;\n      counter: this.state.counter + 1\n    &#125;)\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;h1 onClick&#x3D;&#123;this.handleClick&#125;&gt;Hello, world!&#123;this.state.counter&#125;&lt;&#x2F;h1&gt;\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n&#125;\n复制代码\n\n现在可以显式传入 counter ，但是这里有个问题，如果想要通过点击实现 state.counter 的增加，但这时会发现值不会发生任何变化，一直保持 props 传进来的值。这是由于在 React 16.4^ 的版本中 setState 和 forceUpdate 也会触发这个生命周期，所以当组件内部 state 变化后，就会重新走这个方法，同时会把 state 值赋值为 props 的值。因此需要多加一个字段来记录之前的 props 值，这样就会解决上述问题。具体如下：\n&#x2F;&#x2F; 这里只列出需要变化的地方\nclass App extends React.Component &#123;\n  constructor(props) &#123;\n    super(props)\n    this.state &#x3D; &#123;\n      &#x2F;&#x2F; 增加一个 preCounter 来记录之前的 props 传来的值\n      preCounter: 0,\n      counter: 0\n    &#125;\n  &#125;\n  static getDerivedStateFromProps(props, state) &#123;\n    &#x2F;&#x2F; 跟 state.preCounter 进行比较\n    if (props.counter !&#x3D;&#x3D; state.preCounter) &#123;\n      return &#123;\n        counter: props.counter,\n        preCounter: props.counter\n      &#125;\n    &#125;\n    return null\n  &#125;\n  handleClick &#x3D; () &#x3D;&gt; &#123;\n    this.setState(&#123;\n      counter: this.state.counter + 1\n    &#125;)\n  &#125;\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;h1 onClick&#x3D;&#123;this.handleClick&#125;&gt;Hello, world!&#123;this.state.counter&#125;&lt;&#x2F;h1&gt;\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n&#125;\n复制代码\n\n（3）renderrender是React 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 state 和属性 props 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：\n\nReact 元素：这里包括原生的 DOM 以及 React 组件；\n数组和 Fragment（片段） ：可以返回多个元素；\nPortals（插槽） ：可以将子元素渲染到不同的 DOM 子树种；\n字符串和数字：被渲染成 DOM 中的 text 节点；\n布尔值或 null：不渲染任何内容。\n\n（4）componentDidMount()componentDidMount()会在组件挂载后（插入 DOM 树中）立即调。该阶段通常进行以下操作：\n\n执行依赖于DOM的操作；\n发送网络请求；（官方建议）\n添加订阅消息（会在componentWillUnmount取消订阅）；\n\n如果在 componentDidMount 中调用 setState ，就会触发一次额外的渲染，多调用了一次 render 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 constructor 中初始化 state 对象。\n在组件装载之后，将计数数字变为1：\nclass App extends React.Component  &#123;\n  constructor(props) &#123;\n    super(props)\n    this.state &#x3D; &#123;\n      counter: 0\n    &#125;\n  &#125;\n  componentDidMount () &#123;\n    this.setState(&#123;\n      counter: 1\n    &#125;)\n  &#125;\n  render ()  &#123;\n    return (\n      &lt;div className&#x3D;&quot;counter&quot;&gt;\n        counter值: &#123; this.state.counter &#125;\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n&#125;\n复制代码\n\n2）组件更新阶段当组件的 props 改变了，或组件内部调用了 setState/forceUpdate，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：\n\ngetDerivedStateFromProps\nshouldComponentUpdate\nrender\ngetSnapshotBeforeUpdate\ncomponentDidUpdate\n\n（1）shouldComponentUpdateshouldComponentUpdate(nextProps, nextState)\n复制代码\n\n在说这个生命周期函数之前，来看两个问题：\n\nsetState 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：\n\nthis.setState(&#123;number: this.state.number&#125;)\n复制代码\n\n\n如果没有调用 setState，props 值也没有变化，是不是组件就不会重新渲染？\n\n第一个问题答案是 会 ，第二个问题如果是父组件重新渲染时，不管传入的 props 有没有变化，都会引起子组件的重新渲染。\n那么有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢？这个时候 shouldComponentUpdate 登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 true，可以比较 this.props 和 nextProps ，this.state 和 nextState 值是否变化，来确认返回 true 或者 false。当返回 false 时，组件的更新过程停止，后续的 render、componentDidUpdate 也不会被调用。\n注意： 添加 shouldComponentUpdate 方法时，不建议使用深度相等检查（如使用 JSON.stringify()），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。\n（2）getSnapshotBeforeUpdategetSnapshotBeforeUpdate(prevProps, prevState)\n复制代码\n\n这个方法在 render 之后，componentDidUpdate 之前调用，有两个参数 prevProps 和 prevState，表示更新之前的 props 和 state，这个函数必须要和 componentDidUpdate 一起使用，并且要有一个返回值，默认是 null，这个返回值作为第三个参数传给 componentDidUpdate。\n（3）componentDidUpdatecomponentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：\n\n当组件更新后，对 DOM 进行操作；\n如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。\n\ncomponentDidUpdate(prevProps, prevState, snapshot)&#123;&#125;\n复制代码\n\n该方法有三个参数：\n\nprevProps: 更新前的props\nprevState: 更新前的state\nsnapshot: getSnapshotBeforeUpdate()生命周期的返回值\n\n3）组件卸载阶段卸载阶段只有一个生命周期函数，componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：\n\n清除 timer，取消网络请求或清除\n取消在 componentDidMount() 中创建的订阅等；\n\n这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 setState，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。\n4）错误处理阶段componentDidCatch(error, info)，此生命周期在后代组件抛出错误后被调用。 它接收两个参数∶\n\nerror：抛出的错误。\ninfo：带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息\n\nReact常见的生命周期如下：  React常见生命周期的过程大致如下：\n\n挂载阶段，首先执行constructor构造方法，来创建组件\n创建完成之后，就会执行render方法，该方法会返回需要渲染的内容\n随后，React会将需要渲染的内容挂载到DOM树上\n挂载完成之后就会执行componentDidMount生命周期函数\n如果我们给组件创建一个props（用于组件通信）、调用setState（更改state中的数据）、调用forceUpdate（强制更新组件）时，都会重新调用render函数\nrender函数重新执行之后，就会重新进行DOM树的挂载\n挂载完成之后就会执行componentDidUpdate生命周期函数\n当移除组件时，就会执行componentWillUnmount生命周期函数\n\nReact主要生命周期总结：\n\ngetDefaultProps：这个函数会在组件创建之前被调用一次（有且仅有一次），它被用来初始化组件的 Props；\ngetInitialState：用于初始化组件的 state 值；\ncomponentWillMount：在组件创建后、render 之前，会走到 componentWillMount 阶段。这个阶段我个人一直没用过、非常鸡肋。后来React 官方已经不推荐大家在 componentWillMount 里做任何事情、到现在 React16 直接废弃了这个生命周期，足见其鸡肋程度了；\nrender：这是所有生命周期中唯一一个你必须要实现的方法。一般来说需要返回一个 jsx 元素，这时 React 会根据 props 和 state 来把组件渲染到界面上；不过有时，你可能不想渲染任何东西，这种情况下让它返回 null 或者 false 即可；\ncomponentDidMount：会在组件挂载后（插入 DOM 树中后）立即调用，标志着组件挂载完成。一些操作如果依赖获取到 DOM 节点信息，我们就会放在这个阶段来做。此外，这还是 React 官方推荐的发起 ajax 请求的时机。该方法和 componentWillMount 一样，有且仅有一次调用。\n\n2. React 废弃了哪些生命周期？为什么？被废弃的三个函数都是在render之前，因为fber的出现，很可能因为高优先级任务的出现而打断现有任务导致它们会被执行多次。另外的一个原因则是，React想约束使用者，好的框架能够让人不得已写出容易维护和扩展的代码，这一点又是从何谈起，可以从新增加以及即将废弃的生命周期分析入手\n1) componentWillMount\n首先这个函数的功能完全可以使用componentDidMount和 constructor来代替，异步获取的数据的情况上面已经说明了，而如果抛去异步获取数据，其余的即是初始化而已，这些功能都可以在constructor中执行，除此之外，如果在 willMount 中订阅事件，但在服务端这并不会执行 willUnMount事件，也就是说服务端会导致内存泄漏所以componentWilIMount完全可以不使用，但使用者有时候难免因为各 种各样的情况在 componentWilMount中做一些操作，那么React为了约束开发者，干脆就抛掉了这个API\n2) componentWillReceiveProps\n在老版本的 React 中，如果组件自身的某个 state 跟其 props 密切相关的话，一直都没有一种很优雅的处理方式去更新 state，而是需要在 componentWilReceiveProps 中判断前后两个 props 是否相同，如果不同再将新的 props更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。类似的业务需求也有很多，如一个可以横向滑动的列表，当前高亮的 Tab 显然隶属于列表自身的时，根据传入的某个值，直接定位到某个 Tab。为了解决这些问题，React引入了第一个新的生命周期：getDerivedStateFromProps。它有以下的优点∶\n\ngetDSFP是静态方法，在这里不能使用this，也就是一个纯函数，开发者不能写出副作用的代码\n开发者只能通过prevState而不是prevProps来做对比，保证了state和props之间的简单关系以及不需要处理第一次渲染时prevProps为空的情况\n基于第一点，将状态变化（setState）和昂贵操作（tabChange）区分开，更加便于 render 和 commit 阶段操作或者说优化。\n\n3) componentWillUpdate\n与 componentWillReceiveProps 类似，许多开发者也会在 componentWillUpdate 中根据 props 的变化去触发一些回调 。 但不论是 componentWilReceiveProps 还 是 componentWilUpdate，都有可能在一次更新中被调用多次，也就是说写在这里的回调函数也有可能会被调用多次，这显然是不可取的。与 componentDidMount 类 似， componentDidUpdate 也不存在这样的问题，一次更新中 componentDidUpdate 只会被调用一次，所以将原先写在 componentWillUpdate 中 的 回 调 迁 移 至 componentDidUpdate 就可以解决这个问题。\n另外一种情况则是需要获取DOM元素状态，但是由于在fber中，render可打断，可能在wilMount中获取到的元素状态很可能与实际需要的不同，这个通常可以使用第二个新增的生命函数的解决 getSnapshotBeforeUpdate(prevProps, prevState)\n4) getSnapshotBeforeUpdate(prevProps, prevState)\n返回的值作为componentDidUpdate的第三个参数。与willMount不同的是，getSnapshotBeforeUpdate会在最终确定的render执行之前执行，也就是能保证其获取到的元素状态与didUpdate中获取到的元素状态相同。官方参考代码：\nclass ScrollingList extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.listRef &#x3D; React.createRef();\n  &#125;\n\n  getSnapshotBeforeUpdate(prevProps, prevState) &#123;\n    &#x2F;&#x2F; 我们是否在 list 中添加新的 items ？\n    &#x2F;&#x2F; 捕获滚动​​位置以便我们稍后调整滚动位置。\n    if (prevProps.list.length &lt; this.props.list.length) &#123;\n      const list &#x3D; this.listRef.current;\n      return list.scrollHeight - list.scrollTop;\n    &#125;\n    return null;\n  &#125;\n\n  componentDidUpdate(prevProps, prevState, snapshot) &#123;\n    &#x2F;&#x2F; 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，\n    &#x2F;&#x2F; 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。\n    &#x2F;&#x2F;（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）\n    if (snapshot !&#x3D;&#x3D; null) &#123;\n      const list &#x3D; this.listRef.current;\n      list.scrollTop &#x3D; list.scrollHeight - snapshot;\n    &#125;\n  &#125;\n\n  render() &#123;\n    return (\n      &lt;div ref&#x3D;&#123;this.listRef&#125;&gt;&#123;&#x2F;* ...contents... *&#x2F;&#125;&lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n复制代码\n\n3. React 16.X 中 props 改变后在哪个生命周期中处理在getDerivedStateFromProps中进行处理。\n这个生命周期函数是为了替代componentWillReceiveProps存在的，所以在需要使用componentWillReceiveProps时，就可以考虑使用getDerivedStateFromProps来进行替代。\n两者的参数是不相同的，而getDerivedStateFromProps是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。\n需要注意的是，如果props传入的内容不需要影响到你的state，那么就需要返回一个null，这个返回值是必须的，所以尽量将其写到函数的末尾：\nstatic getDerivedStateFromProps(nextProps, prevState) &#123;\n    const &#123;type&#125; &#x3D; nextProps;\n    &#x2F;&#x2F; 当传入的type发生变化的时候，更新state\n    if (type !&#x3D;&#x3D; prevState.type) &#123;\n        return &#123;\n            type,\n        &#125;;\n    &#125;\n    &#x2F;&#x2F; 否则，对于state不进行任何操作\n    return null;\n&#125;\n复制代码\n\n4. React 性能优化在哪个生命周期？它优化的原理是什么？react的父级组件的render函数重新渲染会引起子组件的render方法的重新渲染。但是，有的时候子组件的接受父组件的数据没有变动。子组件render的执行会影响性能，这时就可以使用shouldComponentUpdate来解决这个问题。\n使用方法如下：\nshouldComponentUpdate(nexrProps) &#123;\n    if (this.props.num &#x3D;&#x3D;&#x3D; nexrProps.num) &#123;\n        return false\n    &#125;\n    return true;\n&#125;\n复制代码\n\nshouldComponentUpdate提供了两个参数nextProps和nextState，表示下一次props和一次state的值，当函数返回false时候，render()方法不执行，组件也就不会渲染，返回true时，组件照常重渲染。此方法就是拿当前props中值和下一次props中的值进行对比，数据相等时，返回false，反之返回true。\n需要注意，在进行新旧对比的时候，是浅对比，也就是说如果比较的数据时引用数据类型，只要数据的引用的地址没变，即使内容变了，也会被判定为true。\n面对这个问题，可以使用如下方法进行解决： （1）使用setState改变数据之前，先采用ES6中assgin进行拷贝，但是assgin只深拷贝的数据的第一层，所以说不是最完美的解决办法：\nconst o2 &#x3D; Object.assign(&#123;&#125;,this.state.obj)\n    o2.student.count &#x3D; &#39;00000&#39;;\n    this.setState(&#123;\n        obj: o2,\n    &#125;)\n复制代码\n\n（2）使用JSON.parse(JSON.stringfy())进行深拷贝，但是遇到数据为undefined和函数时就会错。\nconst o2 &#x3D; JSON.parse(JSON.stringify(this.state.obj))\n    o2.student.count &#x3D; &#39;00000&#39;;\n    this.setState(&#123;\n        obj: o2,\n    &#125;)\n复制代码\n\n5. state 和 props 触发更新的生命周期分别有什么区别？state 更新流程：  这个过程当中涉及的函数：\n\nshouldComponentUpdate: 当组件的 state 或 props 发生改变时，都会首先触发这个生命周期函数。它会接收两个参数：nextProps, nextState——它们分别代表传入的新 props 和新的 state 值。拿到这两个值之后，我们就可以通过一些对比逻辑来决定是否有 re-render（重渲染）的必要了。如果该函数的返回值为 false，则生命周期终止，反之继续；\n\n\n\n\n\n\n\n\n\n\n注意：此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()\n\ncomponentWillUpdate：当组件的 state 或 props 发生改变时，会在渲染之前调用 componentWillUpdate。componentWillUpdate 是 React16 废弃的三个生命周期之一。过去，我们可能希望能在这个阶段去收集一些必要的信息（比如更新前的 DOM 信息等等），现在我们完全可以在 React16 的 getSnapshotBeforeUpdate 中去做这些事；\ncomponentDidUpdate：componentDidUpdate() 会在UI更新后会被立即调用。它接收 prevProps（上一次的 props 值）作为入参，也就是说在此处我们仍然可以进行 props 值对比（再次说明 componentWillUpdate 确实鸡肋哈）。\n\n​\nprops 更新流程：  相对于 state 更新，props 更新后唯一的区别是增加了对 componentWillReceiveProps 的调用。关于 componentWillReceiveProps，需要知道这些事情：\n\ncomponentWillReceiveProps：它在Component接受到新的 props 时被触发。componentWillReceiveProps 会接收一个名为 nextProps 的参数（对应新的 props 值）。该生命周期是 React16 废弃掉的三个生命周期之一。在它被废弃前，可以用它来比较 this.props 和 nextProps 来重新setState。在 React16 中，用一个类似的新生命周期 getDerivedStateFromProps 来代替它。\n\n6. React中发起网络请求应该在哪个生命周期中进行？为什么？对于异步请求，最好放在componentDidMount中去操作，对于同步的状态改变，可以放在componentWillMount中，一般用的比较少。\n如果认为在componentWillMount里发起请求能提早获得结果，这种想法其实是错误的，通常componentWillMount比componentDidMount早不了多少微秒，网络上任何一点延迟，这一点差异都可忽略不计。\nreact的生命周期： constructor() -&gt; componentWillMount() -&gt; render() -&gt; componentDidMount()\n上面这些方法的调用是有次序的，由上而下依次调用。\n\nconstructor被调用是在组件准备要挂载的最开始，此时组件尚未挂载到网页上。\ncomponentWillMount方法的调用在constructor之后，在render之前，在这方法里的代码调用setState方法不会触发重新render，所以它一般不会用来作加载数据之用。\ncomponentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重新渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。与组件上的数据无关的加载，也可以在constructor里做，但constructor是做组件state初绐化工作，并不是做加载数据这工作的，constructor里也不能setState，还有加载的时间太长或者出错，页面就无法加载出来。所以有副作用的代码都会集中在componentDidMount方法里。\n\n总结：\n\n跟服务器端渲染（同构）有关系，如果在componentWillMount里面获取数据，fetch data会执行两次，一次在服务器端一次在客户端。在componentDidMount中可以解决这个问题，componentWillMount同样也会render两次。\n在componentWillMount中fetch data，数据一定在render后才能到达，如果忘记了设置初始状态，用户体验不好。\nreact16.0以后，componentWillMount可能会被执行多次。\n\n7. React 16中新生命周期有哪些关于 React16 开始应用的新生命周期：  可以看出，React16 自上而下地对生命周期做了另一种维度的解读：\n\nRender 阶段：用于计算一些必要的状态信息。这个阶段可能会被 React 暂停，这一点和 React16 引入的 Fiber 架构（我们后面会重点讲解）是有关的；\nPre-commit阶段：所谓“commit”，这里指的是“更新真正的 DOM 节点”这个动作。所谓 Pre-commit，就是说我在这个阶段其实还并没有去更新真实的 DOM，不过 DOM 信息已经是可以读取的了；\nCommit 阶段：在这一步，React 会完成真实 DOM 的更新工作。Commit 阶段，我们可以拿到真实 DOM（包括 refs）。\n\n与此同时，新的生命周期在流程方面，仍然遵循“挂载”、“更新”、“卸载”这三个广义的划分方式。它们分别对应到：\n\n挂载过程：\n\nconstructor\ngetDerivedStateFromProps\nrender\ncomponentDidMount\n\n\n更新过程：\n\ngetDerivedStateFromProps\nshouldComponentUpdate\nrender\ngetSnapshotBeforeUpdate\ncomponentDidUpdate\n\n\n卸载过程：\n\ncomponentWillUnmount\n\n\n\n四、组件通信React组件间通信常见的几种情况:\n\n父组件向子组件通信\n子组件向父组件通信\n跨级组件通信\n非嵌套关系的组件通信\n\n1. 父子组件的通信方式？父组件向子组件通信：父组件通过 props 向子组件传递需要的信息。\n&#x2F;&#x2F; 子组件: Child\nconst Child &#x3D; props &#x3D;&gt;&#123;\n  return &lt;p&gt;&#123;props.name&#125;&lt;&#x2F;p&gt;\n&#125;\n&#x2F;&#x2F; 父组件 Parent\nconst Parent &#x3D; ()&#x3D;&gt;&#123;\n    return &lt;Child name&#x3D;&quot;react&quot;&gt;&lt;&#x2F;Child&gt;\n&#125;\n复制代码\n\n子组件向父组件通信：: props+回调的方式。\n&#x2F;&#x2F; 子组件: Child\nconst Child &#x3D; props &#x3D;&gt;&#123;\n  const cb &#x3D; msg &#x3D;&gt;&#123;\n      return ()&#x3D;&gt;&#123;\n          props.callback(msg)\n      &#125;\n  &#125;\n  return (\n      &lt;button onClick&#x3D;&#123;cb(&quot;你好!&quot;)&#125;&gt;你好&lt;&#x2F;button&gt;\n  )\n&#125;\n&#x2F;&#x2F; 父组件 Parent\nclass Parent extends Component &#123;\n    callback(msg)&#123;\n        console.log(msg)\n    &#125;\n    render()&#123;\n        return &lt;Child callback&#x3D;&#123;this.callback.bind(this)&#125;&gt;&lt;&#x2F;Child&gt;    \n    &#125;\n&#125;\n复制代码\n\n2. 跨级组件的通信方式？父组件向子组件的子组件通信，向更深层子组件通信：\n\n使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。\n使用context，context相当于一个大容器，可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。\n\n&#x2F;&#x2F; context方式实现跨级组件通信 \n&#x2F;&#x2F; Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据\nconst BatteryContext &#x3D; createContext();\n&#x2F;&#x2F;  子组件的子组件 \nclass GrandChild extends Component &#123;\n    render()&#123;\n        return (\n            &lt;BatteryContext.Consumer&gt;\n                &#123;\n                    color &#x3D;&gt; &lt;h1 style&#x3D;&#123;&#123;&quot;color&quot;:color&#125;&#125;&gt;我是红色的:&#123;color&#125;&lt;&#x2F;h1&gt;\n                &#125;\n            &lt;&#x2F;BatteryContext.Consumer&gt;\n        )\n    &#125;\n&#125;\n&#x2F;&#x2F;  子组件\nconst Child &#x3D; () &#x3D;&gt;&#123;\n    return (\n        &lt;GrandChild&#x2F;&gt;\n    )\n&#125;\n&#x2F;&#x2F; 父组件\nclass Parent extends Component &#123;\n      state &#x3D; &#123;\n          color:&quot;red&quot;\n      &#125;\n      render()&#123;\n          const &#123;color&#125; &#x3D; this.state\n          return (\n          &lt;BatteryContext.Provider value&#x3D;&#123;color&#125;&gt;\n              &lt;Child&gt;&lt;&#x2F;Child&gt;\n          &lt;&#x2F;BatteryContext.Provider&gt;\n          )\n      &#125;\n&#125;\n复制代码\n\n3. 非嵌套关系组件的通信方式？即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。\n\n可以使用自定义事件通信（发布订阅模式）\n可以通过redux等进行全局状态管理\n如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。\n\n4. 如何解决 props 层级过深的问题\n使用Context API：提供一种组件之间的状态共享，而不必通过显式组件树逐层传递props；\n使用Redux等状态库。\n\n5. 组件通信的方式有哪些\n⽗组件向⼦组件通讯: ⽗组件可以向⼦组件通过传 props 的⽅式，向⼦组件进⾏通讯\n⼦组件向⽗组件通讯: props+回调的⽅式，⽗组件向⼦组件传递props进⾏通讯，此props为作⽤域为⽗组件⾃身的函 数，⼦组件调⽤该函数，将⼦组件想要传递的信息，作为参数，传递到⽗组件的作⽤域中\n兄弟组件通信: 找到这两个兄弟节点共同的⽗节点,结合上⾯两种⽅式由⽗节点转发信息进⾏通信\n跨层级通信: Context 设计⽬的是为了共享那些对于⼀个组件树⽽⾔是“全局”的数据，例如当前认证的⽤户、主题或⾸选语⾔，对于跨越多层的全局数据通过 Context 通信再适合不过\n发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引⼊event模块进⾏通信\n全局状态管理⼯具: 借助Redux或者Mobx等全局状态管理⼯具进⾏通信,这种⼯具会维护⼀个全局状态中⼼Store,并根据不同的事件产⽣新的状态\n\n五、路由1. React-Router的实现原理是什么？客户端路由实现的思想：\n\n基于 hash 的路由：通过监听hashchange事件，感知 hash 的变化\n\n改变 hash 可以直接通过 location.hash&#x3D;xxx\n\n\n基于 H5 history 路由：\n\n改变 url 可以通过 history.pushState 和 resplaceState 等，会将URL压入堆栈，同时能够应用 history.go() 等 API\n监听 url 的变化可以通过自定义事件触发实现\n\n\n\nreact-router 实现的思想：\n\n基于 history 库来实现上述不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知\n通过维护的列表，在每次 URL 发生变化的回收，通过配置的 路由路径，匹配到对应的 Component，并且 render\n\n2. 如何配置 React-Router 实现路由切换（1）使用&lt;Route&gt; 组件\n路由匹配是通过比较 &lt;Route&gt; 的 path 属性和当前地址的 pathname 来实现的。当一个 &lt;Route&gt; 匹配成功时，它将渲染其内容，当它不匹配时就会渲染 null。没有路径的 &lt;Route&gt; 将始终被匹配。\n&#x2F;&#x2F; when location &#x3D; &#123; pathname: &#39;&#x2F;about&#39; &#125;\n&lt;Route path&#x3D;&#39;&#x2F;about&#39; component&#x3D;&#123;About&#125;&#x2F;&gt; &#x2F;&#x2F; renders &lt;About&#x2F;&gt;\n&lt;Route path&#x3D;&#39;&#x2F;contact&#39; component&#x3D;&#123;Contact&#125;&#x2F;&gt; &#x2F;&#x2F; renders null\n&lt;Route component&#x3D;&#123;Always&#125;&#x2F;&gt; &#x2F;&#x2F; renders &lt;Always&#x2F;&gt;\n复制代码\n\n（2）结合使用 &lt;Switch&gt; 组件和 &lt;Route&gt; 组件\n&lt;Switch&gt; 用于将 &lt;Route&gt; 分组。\n&lt;Switch&gt;\n    &lt;Route exact path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;Home&#125; &#x2F;&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125; &#x2F;&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;contact&quot; component&#x3D;&#123;Contact&#125; &#x2F;&gt;\n&lt;&#x2F;Switch&gt;\n复制代码\n\n&lt;Switch&gt; 不是分组 &lt;Route&gt; 所必须的，但他通常很有用。 一个 &lt;Switch&gt; 会遍历其所有的子 &lt;Route&gt;元素，并仅渲染与当前地址匹配的第一个元素。\n（3）使用 &lt;Link&gt;、 &lt;NavLink&gt;、&lt;Redirect&gt; 组件\n&lt;Link&gt; 组件来在你的应用程序中创建链接。无论你在何处渲染一个&lt;Link&gt; ，都会在应用程序的 HTML 中渲染锚（&lt;a&gt;）。\n&lt;Link to&#x3D;&quot;&#x2F;&quot;&gt;Home&lt;&#x2F;Link&gt;   \n&#x2F;&#x2F; &lt;a href&#x3D;&#39;&#x2F;&#39;&gt;Home&lt;&#x2F;a&gt;\n复制代码\n\n是一种特殊类型的 当它的 to属性与当前地址匹配时，可以将其定义为”活跃的”。\n&#x2F;&#x2F; location &#x3D; &#123; pathname: &#39;&#x2F;react&#39; &#125;\n&lt;NavLink to&#x3D;&quot;&#x2F;react&quot; activeClassName&#x3D;&quot;hurray&quot;&gt;\n    React\n&lt;&#x2F;NavLink&gt;\n&#x2F;&#x2F; &lt;a href&#x3D;&#39;&#x2F;react&#39; className&#x3D;&#39;hurray&#39;&gt;React&lt;&#x2F;a&gt;\n复制代码\n\n当我们想强制导航时，可以渲染一个&lt;Redirect&gt;，当一个&lt;Redirect&gt;渲染时，它将使用它的to属性进行定向。\n3. React-Router怎么设置重定向？使用&lt;Redirect&gt;组件实现路由的重定向：\n&lt;Switch&gt;\n  &lt;Redirect from&#x3D;&#39;&#x2F;users&#x2F;:id&#39; to&#x3D;&#39;&#x2F;users&#x2F;profile&#x2F;:id&#39;&#x2F;&gt;\n  &lt;Route path&#x3D;&#39;&#x2F;users&#x2F;profile&#x2F;:id&#39; component&#x3D;&#123;Profile&#125;&#x2F;&gt;\n&lt;&#x2F;Switch&gt;\n复制代码\n\n当请求 /users/:id 被重定向去 &#39;/users/profile/:id&#39;：\n\n属性 from: string：需要匹配的将要被重定向路径。\n属性 to: string：重定向的 URL 字符串\n属性 to: object：重定向的 location 对象\n属性 push: bool：若为真，重定向操作将会把新地址加入到访问历史记录里面，并且无法回退到前面的页面。\n\n4. react-router 里的 Link 标签和 a 标签的区别从最终渲染的 DOM 来看，这两者都是链接，都是 标签，区别是∶ &lt;Link&gt;是react-router 里实现路由跳转的链接，一般配合&lt;Route&gt; 使用，react-router接管了其默认的链接跳转行为，区别于传统的页面跳转，&lt;Link&gt; 的“跳转”行为只会触发相匹配的&lt;Route&gt;对应的页面内容更新，而不会刷新整个页面。\n&lt;Link&gt;做了3件事情:\n\n有onclick那就执行onclick\nclick的时候阻止a标签默认事件\n根据跳转href(即是to)，用history (web前端路由两种方式之一，history &amp; hash)跳转，此时只是链接变了，并没有刷新页面而&lt;a&gt;标签就是普通的超链接了，用于从当前页面跳转到href指向的另一 个页面(非锚点情况)。\n\na标签默认事件禁掉之后做了什么才实现了跳转?\nlet domArr &#x3D; document.getElementsByTagName(&#39;a&#39;)\n[...domArr].forEach(item&#x3D;&gt;&#123;\n    item.addEventListener(&#39;click&#39;,function () &#123;\n        location.href &#x3D; this.href\n    &#125;)\n&#125;)\n复制代码\n\n5. React-Router如何获取URL的参数和历史对象？（1）获取URL的参数\n\nget传值\n\n路由配置还是普通的配置，如：&#39;admin&#39;，传参方式如：&#39;admin?id=&#39;1111&#39;&#39;。通过this.props.location.search获取url获取到一个字符串&#39;?id=&#39;1111&#39; 可以用url，qs，querystring，浏览器提供的api URLSearchParams对象或者自己封装的方法去解析出id的值。\n\n动态路由传值\n\n路由需要配置成动态路由：如path=&#39;/admin/:id&#39;，传参方式，如&#39;admin/111&#39;。通过this.props.match.params.id 取得url中的动态路由id部分的值，除此之外还可以通过useParams（Hooks）来获取\n\n通过query或state传值\n\n传参方式如：在Link组件的to属性中可以传递对象&#123;pathname:&#39;/admin&#39;,query:&#39;111&#39;,state:&#39;111&#39;&#125;;。通过this.props.location.state或this.props.location.query来获取即可，传递的参数可以是对象、数组等，但是存在缺点就是只要刷新页面，参数就会丢失。\n（2）获取历史对象\n\n如果React &gt;&#x3D; 16.8 时可以使用 React Router中提供的Hooks\n\nimport &#123; useHistory &#125; from &quot;react-router-dom&quot;;\nlet history &#x3D; useHistory();\n复制代码\n\n2.使用this.props.history获取历史对象\nlet history &#x3D; this.props.history;\n复制代码\n\n6. React-Router 4怎样在路由变化时重新渲染同一个组件？当路由变化时，即组件的props发生了变化，会调用componentWillReceiveProps等生命周期钩子。那需要做的只是： 当路由改变时，根据路由，也去请求数据：\nclass NewsList extends Component &#123;\n  componentDidMount () &#123;\n     this.fetchData(this.props.location);\n  &#125;\n  \n  fetchData(location) &#123;\n    const type &#x3D; location.pathname.replace(&#39;&#x2F;&#39;, &#39;&#39;) || &#39;top&#39;\n    this.props.dispatch(fetchListData(type))\n  &#125;\n  componentWillReceiveProps(nextProps) &#123;\n     if (nextProps.location.pathname !&#x3D; this.props.location.pathname) &#123;\n         this.fetchData(nextProps.location);\n     &#125; \n  &#125;\n  render () &#123;\n    ...\n  &#125;\n&#125;\n复制代码\n\n利用生命周期componentWillReceiveProps，进行重新render的预处理操作。\n7. React-Router的路由有几种模式？React-Router 支持使用 hash（对应 HashRouter）和 browser（对应 BrowserRouter） 两种路由规则， react-router-dom 提供了 BrowserRouter 和 HashRouter 两个组件来实现应用的 UI 和 URL 同步：\n\nBrowserRouter 创建的 URL 格式：xxx.com&#x2F;path\nHashRouter 创建的 URL 格式：xxx.com&#x2F;#&#x2F;path\n\n（1）BrowserRouter\n它使用 HTML5 提供的 history API（pushState、replaceState 和 popstate 事件）来保持 UI 和 URL 的同步。由此可以看出，BrowserRouter 是使用 HTML 5 的 history API 来控制路由跳转的：\n&lt;BrowserRouter\n    basename&#x3D;&#123;string&#125;\n    forceRefresh&#x3D;&#123;bool&#125;\n    getUserConfirmation&#x3D;&#123;func&#125;\n    keyLength&#x3D;&#123;number&#125;\n&#x2F;&gt;\n复制代码\n\n其中的属性如下：\n\nbasename 所有路由的基准 URL。basename 的正确格式是前面有一个前导斜杠，但不能有尾部斜杠；\n\n&lt;BrowserRouter basename&#x3D;&quot;&#x2F;calendar&quot;&gt;\n    &lt;Link to&#x3D;&quot;&#x2F;today&quot; &#x2F;&gt;\n&lt;&#x2F;BrowserRouter&gt;\n复制代码\n\n等同于\n&lt;a href&#x3D;&quot;&#x2F;calendar&#x2F;today&quot; &#x2F;&gt;\n复制代码\n\n\nforceRefresh 如果为 true，在导航的过程中整个页面将会刷新。一般情况下，只有在不支持 HTML5 history API 的浏览器中使用此功能；\ngetUserConfirmation 用于确认导航的函数，默认使用 window.confirm。例如，当从 &#x2F;a 导航至 &#x2F;b 时，会使用默认的 confirm 函数弹出一个提示，用户点击确定后才进行导航，否则不做任何处理；\n\n&#x2F;&#x2F; 这是默认的确认函数\nconst getConfirmation &#x3D; (message, callback) &#x3D;&gt; &#123;\n  const allowTransition &#x3D; window.confirm(message);\n  callback(allowTransition);\n&#125;\n&lt;BrowserRouter getUserConfirmation&#x3D;&#123;getConfirmation&#125; &#x2F;&gt;\n复制代码\n\n\n\n\n\n\n\n\n\n\n需要配合&lt;Prompt&gt; 一起使用。\n\nKeyLength 用来设置 Location.Key 的长度。\n\n（2）HashRouter\n使用 URL 的 hash 部分（即 window.location.hash）来保持 UI 和 URL 的同步。由此可以看出，HashRouter 是通过 URL 的 hash 属性来控制路由跳转的：\n&lt;HashRouter\n    basename&#x3D;&#123;string&#125;\n    getUserConfirmation&#x3D;&#123;func&#125;\n    hashType&#x3D;&#123;string&#125;  \n&#x2F;&gt;\n复制代码\n\n其参数如下：\n\nbasename, getUserConfirmation 和 BrowserRouter 功能一样；\n\nhashType window.location.hash 使用的 hash 类型，有如下几种：\n\nslash - 后面跟一个斜杠，例如 #&#x2F; 和 #&#x2F;sunshine&#x2F;lollipops；\nnoslash - 后面没有斜杠，例如 # 和 #sunshine&#x2F;lollipops；\nhashbang - Google 风格的 ajax crawlable，例如 #!&#x2F; 和 #!&#x2F;sunshine&#x2F;lollipops。\n\n\n\n8. React-Router 4的Switch有什么用？Switch 通常被用来包裹 Route，用于渲染与路径匹配的第一个子 &lt;Route&gt; 或 &lt;Redirect&gt;，它里面不能放其他元素。\n假如不加 &lt;Switch&gt; ：\nimport &#123; Route &#125; from &#39;react-router-dom&#39;\n\n&lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n&lt;Route path&#x3D;&quot;&#x2F;login&quot; component&#x3D;&#123;Login&#125;&gt;&lt;&#x2F;Route&gt;\n复制代码\n\nRoute 组件的 path 属性用于匹配路径，因为需要匹配 / 到 Home，匹配 /login 到 Login，所以需要两个 Route，但是不能这么写。这样写的话，当 URL 的 path 为 “&#x2F;login” 时，&lt;Route path=&quot;/&quot; /&gt;和&lt;Route path=&quot;/login&quot; /&gt; 都会被匹配，因此页面会展示 Home 和 Login 两个组件。这时就需要借助 &lt;Switch&gt; 来做到只显示一个匹配组件：\nimport &#123; Switch, Route&#125; from &#39;react-router-dom&#39;\n    \n&lt;Switch&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n    &lt;Route path&#x3D;&quot;&#x2F;login&quot; component&#x3D;&#123;Login&#125;&gt;&lt;&#x2F;Route&gt;\n&lt;&#x2F;Switch&gt;\n复制代码\n\n此时，再访问 “&#x2F;login” 路径时，却只显示了 Home 组件。这是就用到了exact属性，它的作用就是精确匹配路径，经常与&lt;Switch&gt; 联合使用。只有当 URL 和该 &lt;Route&gt; 的 path 属性完全一致的情况下才能匹配上：\nimport &#123; Switch, Route&#125; from &#39;react-router-dom&#39;\n   \n&lt;Switch&gt;\n   &lt;Route exact path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n   &lt;Route exact path&#x3D;&quot;&#x2F;login&quot; component&#x3D;&#123;Login&#125;&gt;&lt;&#x2F;Route&gt;\n&lt;&#x2F;Switch&gt;\n","slug":"面试题笔记——REACT篇(上)","date":"2022-04-08T06:06:03.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"af425ac0390f0c4b127b06f565469692","title":"ahooks 整体架构源码解析","content":"React hooks utils 库自从 React 16.8 版本推出 React hooks，越来越多的项目使用 Function Component。React hooks utils 库随即诞生，它主要解决的两个问题如下：\n\n公共逻辑的抽象。\n解决 React hooks 存在的弊端，比如闭包等。\n\n那现在社区有哪些比较优秀的 React Hooks utils 库呢？\nreact-use 是社区比较活跃的 React hooks utils 库，它的 star 数达到了 29.6k。它的功能非常强大，拥有的 hooks 已经 100+。假如你需要功能比较齐全，可以考虑选择 react-use。\n如果不需要非常齐全的功能，只需要一些常见的功能，react-use 可能会稍微冗余了，可以考虑我们今天的主角——ahooks，目前它的 star 数为 9.2k，也算是社区比较活跃。\nahooks简介官方介绍如下：\n\n\n\n\n\n\n\n\n\nahooks，发音 [eɪ hʊks]，是一套高质量可靠的 React Hooks 库。在当前 React 项目研发过程中，一套好用的 React Hooks 库是必不可少的，希望 ahooks 能成为您的选择。\n特点它具有如下特点：\n\n易学易用。\n\n支持 SSR。\n\n将访问 DOM&#x2F;BOM 的方法放在 useEffect 中（服务端不会执行），避免服务端执行时报错。\n源码中可以看到很多 isBrowser 的判断，主要是区分开浏览器环境和服务器环境。\n\n\n对输入输出函数做了特殊处理，且避免闭包问题。\n\n输入的函数，永远都是使用最新的一份。这个是通过 useRef 进行实现。\n输出函数，地址都是不会变化的，这个是通过 useMemoizedFn（ahooks 封装的）实现的，其实现也是通过 useRef 实现。后面我们会提到。\n\n\n包含大量提炼自业务的高级 Hooks。\n\n包含丰富的基础 Hooks。\n\n使用 TypeScript 构建，提供完整的类型定义文件。可以学习一些 TypeScript 的技巧。\n\n\nhooks 种类ahooks 基于 UI、SideEffect、LifeCycle、State、DOM 等分类提供了常用的 Hooks。如下所示：\n\nahooks 整体架构项目启动我们先从 ahooks 中 folk 一份，clone 下来。\nyarn run init\nyarn start\n复制代码\n\n如果你能成功跑起服务，就会看到和官方文档一模一样的页面。\n整体结构从仓库的根目录的 package.json 中可以得到以下信息。\n\n文档是使用 dumi。是一款为组件开发场景而生的文档工具。\n该项目是一个 monoRepo。它的项目管理是通过 lerna 进行管理的。\n单元测试是通过 jest 实现。\n\n它的目录结构中，可以看到 docs 中存放仓库公共文档。packages 中存放两个包，hooks 和 use-url-state。整体的结构跟 dumi 中给出的 lerna 项目的结构相似。其中每个包下面的每个组件都可以书写对应的文档，不一样的是，hooks 中每个组件多了 __tests__ 文件夹，这个是用来写单元测试的。\n\n可以用以下一张图，大致总结一下 ahooks 的工程架构：\n\nhooks刚刚也提到，ahooks 是采用了 monoRepo 的方式，我们的源码都是在 packages 中，我们来看下 hooks。先看 packages/hooks/package.json。另外要使用 useUrlState 这个 hook，需要独立安装 @ahooksjs/use-url-state，其源码在 packages/use-url-state 中。我理解官方的用意应该是这个库依赖于 react-router，可能有一些项目不需要用到，把它提出来有助于减少包的大小。\nnpm i @ahooksjs&#x2F;use-url-state -S\n复制代码\n\n回到 packages/hooks。重点关注一下 dependencies 和 peerDependencies。可以看到其实它内部还是使用了一些其他的工具库的，比如 lodash（估计是避免重复造轮子，但感觉这样会导致包会变大）。后面我们也会对这些工具库做一个探索。\n&quot;dependencies&quot;: &#123;\n  &quot;@types&#x2F;js-cookie&quot;: &quot;^2.x.x&quot;,\n  &quot;ahooks-v3-count&quot;: &quot;^1.0.0&quot;,\n  &quot;dayjs&quot;: &quot;^1.9.1&quot;,\n  &quot;intersection-observer&quot;: &quot;^0.12.0&quot;,\n  &quot;js-cookie&quot;: &quot;^2.x.x&quot;,\n  &quot;lodash&quot;: &quot;^4.17.21&quot;,\n  &quot;resize-observer-polyfill&quot;: &quot;^1.5.1&quot;,\n  &quot;screenfull&quot;: &quot;^5.0.0&quot;\n&#125;,\n&quot;peerDependencies&quot;: &#123;\n  &quot;react&quot;: &quot;^16.8.0 || ^17.0.0 || ^18.0.0&quot;\n&#125;,\n复制代码\n\n另外解释下 peerDependencies。\n\n\n\n\n\n\n\n\n\npeerDependencies 的目的是提示宿主环境去安装满足插件 peerDependencies 所指定依赖的包，然后在插件 import 或者 require 所依赖的包的时候，永远都是引用宿主环境统一安装的 npm 包，最终解决插件与所依赖包不一致的问题。这里的宿主环境一般指的就是我们自己的项目本身了。\n这对于封装 npm 包非常重要。当你写的包 a 里面依赖另一个包 b，而这个包 b 是引用这个包 a 的业务的常用的包的时候，建议写在 peerDependencies 里，避免重复下载&#x2F;多个版本共存。\n","slug":"ahooks 整体架构源码解析","date":"2022-01-13T14:06:14.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"045012ff9de07809836ee76fe6879635","title":"如何优雅地在 React 中使用TypeScript","content":"一、组件声明在React中，组件的声明方式有两种：函数组件和类组件， 来看看这两种类型的组件声明时是如何定义TS类型的。\n1. 类组件类组件的定义形式有两种：React.Component&lt;P, S=&#123;&#125;&gt; 和 React.PureComponent&lt;P, S=&#123;&#125; SS=&#123;&#125;&gt;，它们都是泛型接口，接收两个参数，第一个是props类型的定义，第二个是state类型的定义，这两个参数都不是必须的，没有时可以省略：\ninterface IProps &#123;\n  name: string;\n&#125;\n\ninterface IState &#123;\n  count: number;\n&#125;\n\nclass App extends React.Component&lt;IProps, IState&gt; &#123;\n  state &#x3D; &#123;\n    count: 0\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &#123;this.state.count&#125;\n        &#123;this.props.name&#125;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\nexport default App;\n复制代码\n\nReact.PureComponent&lt;P, S=&#123;&#125; SS=&#123;&#125;&gt; 也是差不多的：\nclass App extends React.PureComponent&lt;IProps, IState&gt; &#123;&#125;\n复制代码\n\nReact.PureComponent是有第三个参数的，它表示getSnapshotBeforeUpdate的返回值。\n那PureComponent和Component 的区别是什么呢？它们的主要区别是PureComponent中的shouldComponentUpdate 是由自身进行处理的，不需要我们自己处理，所以PureComponent可以在一定程度上提升性能。\n有时候可能会见到这种写法，实际上和上面的效果是一样的：\nimport React, &#123;PureComponent, Component&#125; from &quot;react&quot;;\n\nclass App extends PureComponent&lt;IProps, IState&gt; &#123;&#125;\n\nclass App extends Component&lt;IProps, IState&gt; &#123;&#125;\n复制代码\n\n那如果定义时候我们不知道组件的props的类型，只有在调用时才知道组件类型，该怎么办呢？这时泛型就发挥作用了：\n&#x2F;&#x2F; 定义组件\nclass MyComponent&lt;P&gt; extends React.Component&lt;P&gt; &#123;\n  internalProp: P;\n  constructor(props: P) &#123;\n    super(props);\n    this.internalProp &#x3D; props;\n  &#125;\n  render() &#123;\n    return (\n    \t &lt;span&gt;hello world&lt;&#x2F;span&gt;\n    );\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用组件\ntype IProps &#x3D; &#123; name: string; age: number; &#125;;\n\n&lt;MyComponent&lt;IProps&gt; name&#x3D;&quot;React&quot; age&#x3D;&#123;18&#125; &#x2F;&gt;;          &#x2F;&#x2F; Success\n&lt;MyComponent&lt;IProps&gt; name&#x3D;&quot;TypeScript&quot; age&#x3D;&quot;hello&quot; &#x2F;&gt;;  &#x2F;&#x2F; Error\n复制代码\n\n2. 函数组件通常情况下，函数组件我是这样写的：\ninterface IProps &#123;\n  name: string\n&#125;\n\nconst App &#x3D; (props: IProps) &#x3D;&gt; &#123;\n  const &#123;name&#125; &#x3D; props;\n\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;h1&gt;hello world&lt;&#x2F;h1&gt;\n      &lt;h2&gt;&#123;name&#125;&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nexport default App;\n复制代码\n\n除此之外，函数类型还可以使用React.FunctionComponent&lt;P=&#123;&#125;&gt;来定义，也可以使用其简写React.FC&lt;P=&#123;&#125;&gt;，两者效果是一样的。它是一个泛型接口，可以接收一个参数，参数表示props的类型，这个参数不是必须的。它们就相当于这样：\ntype React.FC&lt;P &#x3D; &#123;&#125;&gt; &#x3D; React.FunctionComponent&lt;P&gt;\n复制代码\n\n最终的定义形式如下：\ninterface IProps &#123;\n  name: string\n&#125;\n\nconst App: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const &#123;name&#125; &#x3D; props;\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;h1&gt;hello world&lt;&#x2F;h1&gt;\n      &lt;h2&gt;&#123;name&#125;&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\nexport default App;\n复制代码\n\n当使用这种形式来定义函数组件时，props中默认会带有children属性，它表示该组件在调用时，其内部的元素，来看一个例子，首先定义一个组件，组件中引入了Child1和Child2组件：\nimport Child1 from &quot;.&#x2F;child1&quot;;\nimport Child2 from &quot;.&#x2F;child2&quot;;\n\ninterface IProps &#123;\n  name: string;\n&#125;\nconst App: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const &#123; name &#125; &#x3D; props;\n  return (\n    &lt;Child1 name&#x3D;&#123;name&#125;&gt;\n      &lt;Child2 name&#x3D;&#123;name&#125; &#x2F;&gt;\n      TypeScript\n    &lt;&#x2F;Child1&gt;\n  );\n&#125;;\n\nexport default App;\n复制代码\n\nChild1组件结构如下：\ninterface IProps &#123;\n  name: string;\n&#125;\nconst Child1: React.FC&lt;IProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n  const &#123; name, children &#125; &#x3D; props;\n  console.log(children);\n  return (\n    &lt;div className&#x3D;&quot;App&quot;&gt;\n      &lt;h1&gt;hello child1&lt;&#x2F;h1&gt;\n      &lt;h2&gt;&#123;name&#125;&lt;&#x2F;h2&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\nexport default Child1;\n复制代码\n\n我们在Child1组件中打印了children属性，它的值是一个数组，包含Child2对象和后面的文本：\n\n使用 React.FC 声明函数组件和普通声明的区别如下：\n\nReact.FC 显式地定义了返回类型，其他方式是隐式推导的；\nReact.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全；\nReact.FC 为 children 提供了隐式的类型（ReactElement | null）。\n\n那如果我们在定义组件时不知道props的类型，只有调用时才知道，那就还是用泛型来定义props的类型。对于使用function定义的函数组件：\n&#x2F;&#x2F; 定义组件\nfunction MyComponent&lt;P&gt;(props: P) &#123;\n  return (\n  \t&lt;span&gt;\n    \t&#123;props&#125;\n    &lt;&#x2F;span&gt;\n  );\n&#125;\n\n&#x2F;&#x2F; 使用组件\ntype IProps &#x3D; &#123; name: string; age: number; &#125;;\n\n&lt;MyComponent&lt;IProps&gt; name&#x3D;&quot;React&quot; age&#x3D;&#123;18&#125; &#x2F;&gt;;          &#x2F;&#x2F; Success\n&lt;MyComponent&lt;IProps&gt; name&#x3D;&quot;TypeScript&quot; age&#x3D;&quot;hello&quot; &#x2F;&gt;;  &#x2F;&#x2F; Error\n复制代码\n\n如果使用箭头函数定义的函数组件，直接这样调用时错误的：\nconst MyComponent &#x3D; &lt;P&gt;(props: P) &#123;\n  return (\n  \t&lt;span&gt;\n    \t&#123;props&#125;\n    &lt;&#x2F;span&gt;\n  );\n&#125;\n复制代码\n\n必须使用extends关键字来定义泛型参数才能被成功解析：\nconst MyComponent &#x3D; &lt;P extends any&gt;(props: P) &#123;\n  return (\n  \t&lt;span&gt;\n    \t&#123;props&#125;\n    &lt;&#x2F;span&gt;\n  );\n&#125;\n复制代码\n\n二、React内置类型1. JSX.Element先来看看JSX.Element类型的声明：\ndeclare global &#123;\n  namespace JSX &#123;\n    interface Element extends React.ReactElement&lt;any, any&gt; &#123; &#125;\n  &#125;\n&#125;\n复制代码\n\n可以看到，JSX.Element是ReactElement的子类型，它没有增加属性，两者是等价的。也就是说两种类型的变量可以相互赋值。 ​\nJSX.Element 可以通过执行 React.createElement 或是转译 JSX 获得：\nconst jsx &#x3D; &lt;div&gt;hello&lt;&#x2F;div&gt;\nconst ele &#x3D; React.createElement(&quot;div&quot;, null, &quot;hello&quot;);\n复制代码\n\n2. React.ReactElementReact 的类型声明文件中提供了 React.ReactElement＜T＞，它可以让我们通过传入＜T&#x2F;＞来注解类组件的实例化，它在声明文件中的定义如下：\ninterface ReactElement&lt;P &#x3D; any, T extends string | JSXElementConstructor&lt;any&gt; &#x3D; string | JSXElementConstructor&lt;any&gt;&gt; &#123;\n   type: T;\n   props: P;\n   key: Key | null;\n&#125;\n复制代码\n\nReactElement是一个接口，包含type,props,key三个属性值。该类型的变量值只能是两种： null 和 ReactElement实例。 ​\n通常情况下，函数组件返回ReactElement（JXS.Element）的值。\n3. React.ReactNodeReactNode类型的声明如下：\ntype ReactText &#x3D; string | number;\ntype ReactChild &#x3D; ReactElement | ReactText;\n\ninterface ReactNodeArray extends Array&lt;ReactNode&gt; &#123;&#125;\ntype ReactFragment &#x3D; &#123;&#125; | ReactNodeArray;\ntype ReactNode &#x3D; ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;\n复制代码\n\n可以看到，ReactNode是一个联合类型，它可以是string、number、ReactElement、null、boolean、ReactNodeArray。由此可知。ReactElement类型的变量可以直接赋值给ReactNode类型的变量，但反过来是不行的。\n类组件的 render 成员函数会返回 ReactNode 类型的值：\nclass MyComponent extends React.Component &#123;\n\trender() &#123;\n    \treturn &lt;div&gt;hello world&lt;&#x2F;div&gt;\n    &#125;\n&#125;\n&#x2F;&#x2F; 正确\nconst component: React.ReactNode&lt;MyComponent&gt; &#x3D; &lt;MyComponent &#x2F;&gt;;\n&#x2F;&#x2F; 错误\nconst component: React.ReactNode&lt;MyComponent&gt; &#x3D; &lt;OtherComponent &#x2F;&gt;;\n复制代码\n\n上面的代码中，给component变量设置了类型是Mycomponent类型的react实例，这时只能给其赋值其为MyComponent的实例组件。 ​\n通常情况下，类组件通过 render() 返回 ReactNode的值。\n4. CSSProperties先来看看React的声明文件中对CSSProperties 的定义：\nexport interface CSSProperties extends CSS.Properties&lt;string | number&gt; &#123;\n  &#x2F;**\n   * The index signature was removed to enable closed typing for style\n   * using CSSType. You&#39;re able to use type assertion or module augmentation\n   * to add properties or an index signature of your own.\n   *\n   * For examples and more information, visit:\n   * https:&#x2F;&#x2F;github.com&#x2F;frenic&#x2F;csstype#what-should-i-do-when-i-get-type-errors\n   *&#x2F;\n&#125;\n复制代码\n\nReact.CSSProperties是React基于TypeScript定义的CSS属性类型，可以将一个方法的返回值设置为该类型：\nimport * as React from &quot;react&quot;;\n\nconst classNames &#x3D; require(&quot;.&#x2F;sidebar.css&quot;);\n\ninterface Props &#123;\n  isVisible: boolean;\n&#125;\n\nconst divStyle &#x3D; (props: Props): React.CSSProperties &#x3D;&gt; (&#123;\n  width: props.isVisible ? &quot;23rem&quot; : &quot;0rem&quot;\n&#125;);\n\nexport const SidebarComponent: React.StatelessComponent&lt;Props&gt; &#x3D; props &#x3D;&gt; (\n  &lt;div id&#x3D;&quot;mySidenav&quot; className&#x3D;&#123;classNames.sidenav&#125; style&#x3D;&#123;divStyle(props)&#125;&gt;\n    &#123;props.children&#125;\n  &lt;&#x2F;div&gt;\n);\n复制代码\n\n这里divStyle组件的返回值就是React.CSSProperties类型。\n我们还可以定义一个CSSProperties类型的变量：\nconst divStyle: React.CSSProperties &#x3D; &#123;\n    width: &quot;11rem&quot;,\n    height: &quot;7rem&quot;,\n    backgroundColor: &#96;rgb($&#123;props.color.red&#125;,$&#123;props.color.green&#125;, $&#123;props.color.blue&#125;)&#96;\n&#125;;\n复制代码\n\n这个变量可以在HTML标签的style属性上使用：\n&lt;div style&#x3D;&#123;divStyle&#125; &#x2F;&gt;\n复制代码\n\n在React的类型声明文件中，style属性的类型如下：\nstyle?: CSSProperties | undefined;\n复制代码\n\n三、React Hooks1. useState默认情况下，React会为根据设置的state的初始值来自动推导state以及更新函数的类型：\n\n如果已知state 的类型，可以通过以下形式来自定义state的类型：\nconst [count, setCount] &#x3D; useState&lt;number&gt;(1)\n复制代码\n\n如果初始值为null，需要显式地声明 state 的类型：\nconst [count, setCount] &#x3D; useState&lt;number | null&gt;(null); \n复制代码\n\n如果state是一个对象，想要初始化一个空对象，可以使用断言来处理：\nconst [user, setUser] &#x3D; React.useState&lt;IUser&gt;(&#123;&#125; as IUser);\n复制代码\n\n实际上，这里将空对象{}断言为IUser接口就是欺骗了TypeScript的编译器，由于后面的代码可能会依赖这个对象，所以应该在使用前及时初始化 user 的值，否则就会报错。\n下面是声明文件中 useState 的定义：\nfunction useState&lt;S&gt;(initialState: S | (() &#x3D;&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;];\n&#x2F;&#x2F; convenience overload when first argument is omitted\n\t&#x2F;**\n\t * Returns a stateful value, and a function to update it.\n   *\n   * @version 16.8.0\n   * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#usestate\n   *&#x2F;\n    \nfunction useState&lt;S &#x3D; undefined&gt;(): [S | undefined, Dispatch&lt;SetStateAction&lt;S | undefined&gt;&gt;];\n  &#x2F;**\n   * An alternative to &#96;useState&#96;.\n   *\n   * &#96;useReducer&#96; is usually preferable to &#96;useState&#96; when you have complex state logic that involves\n   * multiple sub-values. It also lets you optimize performance for components that trigger deep\n   * updates because you can pass &#96;dispatch&#96; down instead of callbacks.\n   *\n   * @version 16.8.0\n   * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#usereducer\n   *&#x2F;\n复制代码\n\n可以看到，这里定义两种形式，分别是有初始值和没有初始值的形式。\n2. useEffectuseEffect的主要作用就是处理副作用，它的第一个参数是一个函数，表示要清除副作用的操作，第二个参数是一组值，当这组值改变时，第一个参数的函数才会执行，这让我们可以控制何时运行函数来处理副作用：\nuseEffect(\n  () &#x3D;&gt; &#123;\n    const subscription &#x3D; props.source.subscribe();\n    return () &#x3D;&gt; &#123;\n      subscription.unsubscribe();\n    &#125;;\n  &#125;,\n  [props.source]\n);\n复制代码\n\n当函数的返回值不是函数或者effect函数中未定义的内容时，如下：\nuseEffect(\n    () &#x3D;&gt; &#123;\n      subscribe();\n      return null; \n    &#125;\n);\n复制代码\n\nTypeScript就会报错：\n\n来看看useEffect在类型声明文件中的定义：\n&#x2F;&#x2F; Destructors are only allowed to return void.\ntype Destructor &#x3D; () &#x3D;&gt; void | &#123; [UNDEFINED_VOID_ONLY]: never &#125;;\n\n&#x2F;&#x2F; NOTE: callbacks are _only_ allowed to return either void, or a destructor.\ntype EffectCallback &#x3D; () &#x3D;&gt; (void | Destructor);\n\n&#x2F;&#x2F; TODO (TypeScript 3.0): ReadonlyArray&lt;unknown&gt;\ntype DependencyList &#x3D; ReadonlyArray&lt;any&gt;;\n\nfunction useEffect(effect: EffectCallback, deps?: DependencyList): void;\n&#x2F;&#x2F; NOTE: this does not accept strings, but this will have to be fixed by removing strings from type Ref&lt;T&gt;\n  &#x2F;**\n   * &#96;useImperativeHandle&#96; customizes the instance value that is exposed to parent components when using\n   * &#96;ref&#96;. As always, imperative code using refs should be avoided in most cases.\n   *\n   * &#96;useImperativeHandle&#96; should be used with &#96;React.forwardRef&#96;.\n   *\n   * @version 16.8.0\n   * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#useimperativehandle\n   *&#x2F;\n复制代码\n\n可以看到，useEffect的第一个参数只允许返回一个函数。\n3. useRef当使用 useRef 时，我们可以访问一个可变的引用对象。可以将初始值传递给 useRef，它用于初始化可变 ref 对象公开的当前属性。当我们使用useRef时，需要给其指定类型：\nconst nameInput &#x3D; React.useRef&lt;HTMLInputElement&gt;(null)\n复制代码\n\n这里给实例的类型指定为了input输入框类型。 ​\n当useRef的初始值为null时，有两种创建的形式，第一种：\nconst nameInput &#x3D; React.useRef&lt;HTMLInputElement&gt;(null)\nnameInput.current.innerText &#x3D; &quot;hello world&quot;;\n复制代码\n\n这种形式下，ref1.current是只读的（read-only），所以当我们将它的innerText属性重新赋值时会报以下错误：\nCannot assign to &#39;current&#39; because it is a read-only property.\n复制代码\n\n那该怎么将current属性变为动态可变得的，先来看看类型声明文件中 useRef 是如何定义的：\n function useRef&lt;T&gt;(initialValue: T): MutableRefObject&lt;T&gt;;\n &#x2F;&#x2F; convenience overload for refs given as a ref prop as they typically start with a null value\n &#x2F;**\n   * &#96;useRef&#96; returns a mutable ref object whose &#96;.current&#96; property is initialized to the passed argument\n   * (&#96;initialValue&#96;). The returned object will persist for the full lifetime of the component.\n   *\n   * Note that &#96;useRef()&#96; is useful for more than the &#96;ref&#96; attribute. It’s handy for keeping any mutable\n   * value around similar to how you’d use instance fields in classes.\n   *\n   * Usage note: if you need the result of useRef to be directly mutable, include &#96;| null&#96; in the type\n   * of the generic argument.\n   *\n   * @version 16.8.0\n   * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#useref\n   *&#x2F;\n复制代码\n\n这段代码的第十行的告诉我们，如果需要useRef的直接可变，就需要在泛型参数中包含’| null’，所以这就是当初始值为null的第二种定义形式：\nconst nameInput &#x3D; React.useRef&lt;HTMLInputElement | null&gt;(null);\n复制代码\n\n这种形式下，nameInput.current就是可写的。不过两种类型在使用时都需要做类型检查：\nnameInput.current?.innerText &#x3D; &quot;hello world&quot;;\n复制代码\n\n那么问题来了，为什么第一种写法在没有操作current时没有报错呢？因为useRef在类型定义式具有多个重载声明，第一种方式就是执行的以下函数重载：\nfunction useRef&lt;T&gt;(initialValue: T|null): RefObject&lt;T&gt;;\n&#x2F;&#x2F; convenience overload for potentially undefined initialValue &#x2F; call with 0 arguments\n&#x2F;&#x2F; has a default to stop it from defaulting to &#123;&#125; instead\n&#x2F;**\n  * &#96;useRef&#96; returns a mutable ref object whose &#96;.current&#96; property is initialized to the passed argument\n  * (&#96;initialValue&#96;). The returned object will persist for the full lifetime of the component.\n  *\n  * Note that &#96;useRef()&#96; is useful for more than the &#96;ref&#96; attribute. It’s handy for keeping any mutable\n  * value around similar to how you’d use instance fields in classes.\n  *\n  * @version 16.8.0\n  * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#useref\n  *&#x2F;\n复制代码\n\n从上useRef的声明中可以看到，function useRef的返回值类型化是MutableRefObject，这里面的T就是参数的类型T，所以最终nameInput 的类型就是React.MutableRefObject。 ​\n注意，上面用到了HTMLInputElement类型，这是一个标签类型，这个操作就是用来访问DOM元素的。\n4. useCallback先来看看类型声明文件中对useCallback的定义：\n function useCallback&lt;T extends (...args: any[]) &#x3D;&gt; any&gt;(callback: T, deps: DependencyList): T;\n &#x2F;**\n  * &#96;useMemo&#96; will only recompute the memoized value when one of the &#96;deps&#96; has changed.\n  *\n  * Usage note: if calling &#96;useMemo&#96; with a referentially stable function, also give it as the input in\n  * the second argument.\n  *\n  * &#96;&#96;&#96;ts\n  * function expensive () &#123; ... &#125;\n  *\n  * function Component () &#123;\n  *   const expensiveResult &#x3D; useMemo(expensive, [expensive])\n  *   return ...\n  * &#125;\n  * &#96;&#96;&#96;\n  *\n  * @version 16.8.0\n  * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#usememo\n  *&#x2F;\n复制代码\n\nuseCallback接收一个回调函数和一个依赖数组，只有当依赖数组中的值发生变化时才会重新执行回调函数。来看一个例子：\nconst add &#x3D; (a: number, b: number) &#x3D;&gt; a + b;\n\nconst memoizedCallback &#x3D; useCallback(\n  (a) &#x3D;&gt; &#123;\n    add(a, b);\n  &#125;,\n  [b]\n);\n\n复制代码\n\n这里我们没有给回调函数中的参数a定义类型，所以下面的调用方式都不会报错：\nmemoizedCallback(&quot;hello&quot;);\nmemoizedCallback(5)\n复制代码\n\n尽管add方法的两个参数都是number类型，但是上述调用都能够用执行。所以为了更加严谨，我们需要给回调函数定义具体的类型：\nconst memoizedCallback &#x3D; useCallback(\n  (a: number) &#x3D;&gt; &#123;\n    add(a, b);\n  &#125;,\n  [b]\n);\n复制代码\n\n这时候如果再给回调函数传入字符串就会报错了：\n 所有，需要注意，在使用useCallback时需要给回调函数的参数指定类型。\n5. useMemo先来看看类型声明文件中对useMemo的定义：\nfunction useMemo&lt;T&gt;(factory: () &#x3D;&gt; T, deps: DependencyList | undefined): T;\n   &#x2F;**\n    * &#96;useDebugValue&#96; can be used to display a label for custom hooks in React DevTools.\n    *\n    * NOTE: We don’t recommend adding debug values to every custom hook.\n    * It’s most valuable for custom hooks that are part of shared libraries.\n    *\n    * @version 16.8.0\n    * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#usedebugvalue\n    *&#x2F;\n复制代码\n\nuseMemo和useCallback是非常类似的，但是它返回的是一个值，而不是函数。所以在定义useMemo时需要定义返回值的类型：\nlet a &#x3D; 1;\nsetTimeout(() &#x3D;&gt; &#123;\n  a +&#x3D; 1;\n&#125;, 1000);\n\nconst calculatedValue &#x3D; useMemo&lt;number&gt;(() &#x3D;&gt; a ** 2, [a]);\n复制代码\n\n如果返回值不一致，就会报错：\nconst calculatedValue &#x3D; useMemo&lt;number&gt;(() &#x3D;&gt; a + &quot;hello&quot;, [a]);\n&#x2F;&#x2F; 类型“() &#x3D;&gt; string”的参数不能赋给类型“() &#x3D;&gt; number”的参数\n复制代码\n\n6. useContextuseContext需要提供一个上下文对象，并返回所提供的上下文的值，当提供者更新上下文对象时，引用这些上下文对象的组件就会重新渲染：\nconst ColorContext &#x3D; React.createContext(&#123; color: &quot;green&quot; &#125;);\n\nconst Welcome &#x3D; () &#x3D;&gt; &#123;\n  const &#123; color &#125; &#x3D; useContext(ColorContext);\n  return &lt;div style&#x3D;&#123;&#123; color &#125;&#125;&gt;hello world&lt;&#x2F;div&gt;;\n&#125;;\n复制代码\n\n在使用useContext时，会自动推断出提供的上下文对象的类型，所以并不需要我们手动设置context的类型。当前，我们也可以使用泛型来设置context的类型：\ninterface IColor &#123;\n\tcolor: string;\n&#125;\n\nconst ColorContext &#x3D; React.createContext&lt;IColor&gt;(&#123; color: &quot;green&quot; &#125;);\n复制代码\n\n下面是useContext在类型声明文件中的定义：\nfunction useContext&lt;T&gt;(context: Context&lt;T&gt;&#x2F;*, (not public API) observedBits?: number|boolean *&#x2F;): T;\n&#x2F;**\n  * Returns a stateful value, and a function to update it.\n  *\n  * @version 16.8.0\n  * @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#usestate\n  *&#x2F;\n复制代码\n\n7. useReducer有时我们需要处理一些复杂的状态，并且可能取决于之前的状态。这时候就可以使用useReducer，它接收一个函数，这个函数会根据之前的状态来计算一个新的state。其语法如下：\nconst [state, dispatch] &#x3D; useReducer(reducer, initialArg, init);\n复制代码\n\n来看下面的例子：\nconst reducer &#x3D; (state, action) &#x3D;&gt; &#123;\n  switch (action.type) &#123;\n    case &#39;increment&#39;:\n      return &#123;count: state.count + 1&#125;;\n    case &#39;decrement&#39;:\n      return &#123;count: state.count - 1&#125;;\n    default:\n      throw new Error();\n  &#125;\n&#125;\n\nconst Counter &#x3D; () &#x3D;&gt; &#123;\n  const initialState &#x3D; &#123;count: 0&#125;\n  const [state, dispatch] &#x3D; useReducer(reducer, initialState);\n  \n  return (\n    &lt;&gt;\n      Count: &#123;state.count&#125;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码\n\n当前的状态是无法推断出来的，可以给reducer函数添加类型，通过给reducer函数定义state和action来推断 useReducer 的类型，下面来修改上面的例子：\ntype ActionType &#x3D; &#123;\n  type: &#39;increment&#39; | &#39;decrement&#39;;\n&#125;;\n\ntype State &#x3D; &#123; count: number &#125;;\n\nconst initialState: State &#x3D; &#123;count: 0&#125;\nconst reducer &#x3D; (state: State, action: ActionType) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; ...\n&#125;\n复制代码\n\n这样，在Counter函数中就可以推断出类型。当我们视图使用一个不存在的类型时，就会报错：\ndispatch(&#123;type: &#39;reset&#39;&#125;);\n&#x2F;&#x2F; Error! type &#39;&quot;reset&quot;&#39; is not assignable to type &#39;&quot;increment&quot; | &quot;decrement&quot;&#39;\n复制代码\n\n除此之外，还可以使用泛型的形式来实现reducer函数的类型定义：\ntype ActionType &#x3D; &#123;\n  type: &#39;increment&#39; | &#39;decrement&#39;;\n&#125;;\n\ntype State &#x3D; &#123; count: number &#125;;\n\nconst reducer: React.Reducer&lt;State, ActionType&gt; &#x3D; (state, action) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; ...\n&#125;\n复制代码\n\n其实dispatch方法也是有类型的：\n\n可以看到，dispatch的类型是：React.Dispatch，上面示例的完整代码如下：\nimport React, &#123; useReducer &#125; from &quot;react&quot;;\n\ntype ActionType &#x3D; &#123;\n  type: &quot;increment&quot; | &quot;decrement&quot;;\n&#125;;\n\ntype State &#x3D; &#123; count: number &#125;;\n\nconst Counter: React.FC &#x3D; () &#x3D;&gt; &#123;\n  const reducer: React.Reducer&lt;State, ActionType&gt; &#x3D; (state, action) &#x3D;&gt; &#123;\n    switch (action.type) &#123;\n      case &quot;increment&quot;:\n        return &#123; count: state.count + 1 &#125;;\n      case &quot;decrement&quot;:\n        return &#123; count: state.count - 1 &#125;;\n      default:\n        throw new Error();\n    &#125;\n  &#125;;\n\n  const initialState: State &#x3D; &#123;count: 0&#125;\n  const [state, dispatch] &#x3D; useReducer(reducer, initialState);\n\n  return (\n    &lt;&gt;\n      Count: &#123;state.count&#125;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &quot;increment&quot; &#125;)&#125;&gt;+&lt;&#x2F;button&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &quot;decrement&quot; &#125;)&#125;&gt;-&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;;\n\nexport default Counter;\n\n复制代码\n\n四、事件处理1. Event 事件类型在开发中我们会经常在事件处理函数中使用event事件对象，比如在input框输入时实时获取输入的值；使用鼠标事件时，通过 clientX、clientY 获取当前指针的坐标等等。 ​\n我们知道，Event是一个对象，并且有很多属性，这时很多人就会把 event 类型定义为any，这样的话TypeScript就失去了它的意义，并不会对event事件进行静态检查，如果一个键盘事件触发了下面的方法，也不会报错：\nconst handleEvent &#x3D; (e: any) &#x3D;&gt; &#123;\n    console.log(e.clientX, e.clientY)\n&#125;\n复制代码\n\n由于Event事件对象中有很多的属性，所以我们也不方便把所有属性及其类型定义在一个interface中，所以React在声明文件中给我们提供了Event事件对象的类型声明。\n常见的Event 事件对象如下：\n\n剪切板事件对象：ClipboardEvent&lt;T &#x3D; Element&gt;\n拖拽事件对象：DragEvent&lt;T &#x3D; Element&gt;\n焦点事件对象：FocusEvent&lt;T &#x3D; Element&gt;\n表单事件对象：FormEvent&lt;T &#x3D; Element&gt;\nChange事件对象：ChangeEvent&lt;T &#x3D; Element&gt;\n键盘事件对象：KeyboardEvent&lt;T &#x3D; Element&gt;\n鼠标事件对象：MouseEvent&lt;T &#x3D; Element, E &#x3D; NativeMouseEvent&gt;\n触摸事件对象：TouchEvent&lt;T &#x3D; Element&gt;\n滚轮事件对象：WheelEvent&lt;T &#x3D; Element&gt;\n动画事件对象：AnimationEvent&lt;T &#x3D; Element&gt;\n过渡事件对象：TransitionEvent&lt;T &#x3D; Element&gt;\n\n可以看到，这些Event事件对象的泛型中都会接收一个Element元素的类型，这个类型就是我们绑定这个事件的标签元素的类型，标签元素类型将在下面的第五部分介绍。\n来看一个简单的例子：\ntype State &#x3D; &#123;\n  text: string;\n&#125;;\n\nconst App: React.FC &#x3D; () &#x3D;&gt; &#123;  \n  const [text, setText] &#x3D; useState&lt;string&gt;(&quot;&quot;)\n\n  const onChange &#x3D; (e: React.FormEvent&lt;HTMLInputElement&gt;): void &#x3D;&gt; &#123;\n    setText(e.currentTarget.value);\n  &#125;;\n  \n  return (\n    &lt;div&gt;\n      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;text&#125; onChange&#x3D;&#123;onChange&#125; &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n复制代码\n\n这里就给onChange方法的事件对象定义为了FormEvent类型，并且作用的对象时一个HTMLInputElement类型的标签（input标签） ​\n可以来看下MouseEvent事件对象和ChangeEvent事件对象的类型声明，其他事件对象的声明形似也类似：\ninterface MouseEvent&lt;T &#x3D; Element, E &#x3D; NativeMouseEvent&gt; extends UIEvent&lt;T, E&gt; &#123;\n  altKey: boolean;\n  button: number;\n  buttons: number;\n  clientX: number;\n  clientY: number;\n  ctrlKey: boolean;\n  &#x2F;**\n    * See [DOM Level 3 Events spec](https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;uievents-key&#x2F;#keys-modifier). for a list of valid (case-sensitive) arguments to this method.\n    *&#x2F;\n  getModifierState(key: string): boolean;\n  metaKey: boolean;\n  movementX: number;\n  movementY: number;\n  pageX: number;\n  pageY: number;\n  relatedTarget: EventTarget | null;\n  screenX: number;\n  screenY: number;\n  shiftKey: boolean;\n&#125;\n\ninterface ChangeEvent&lt;T &#x3D; Element&gt; extends SyntheticEvent&lt;T&gt; &#123;\n  target: EventTarget &amp; T;\n&#125;\n复制代码\n\n在很多事件对象的声明文件中都可以看到 EventTarget 的身影。这是因为，DOM的事件操作（监听和触发），都定义在EventTarget接口上。EventTarget 的类型声明如下：\n\ninterface EventTarget &#123;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject | null, options?: boolean | AddEventListenerOptions): void;\n    dispatchEvent(evt: Event): boolean;\n    removeEventListener(type: string, listener?: EventListenerOrEventListenerObject | null, options?: EventListenerOptions | boolean): void;\n&#125;\n复制代码\n\n比如在change事件中，会使用的e.target来获取当前的值，它的的类型就是EventTarget。来看下面的例子：\n&lt;input\n\tonChange&#x3D;&#123;e &#x3D;&gt; onSourceChange(e)&#125;\n\tplaceholder&#x3D;&quot;最多30个字&quot;\n&#x2F;&gt;\n\nconst onSourceChange &#x3D; (e: React.ChangeEvent&lt;HTMLInputElement&gt;) &#x3D;&gt; &#123;\n    if (e.target.value.length &gt; 30) &#123;\n      message.error(&#39;请长度不能超过30个字，请重新输入&#39;);\n      return;\n    &#125;\n    setSourceInput(e.target.value);\n&#125;;\n复制代码\n\n这里定义了一个input输入框，当触发onChange事件时，会调用onSourceChange方法，该方法的参数e的类型就是：React.ChangeEvent，而e.target的类型就是EventTarget：\n\n在来看一个例子：\nquestionList.map(item &#x3D;&gt; (\n    &lt;div\n    \tkey&#x3D;&#123;item.id&#125;\n  \trole&#x3D;&quot;button&quot;\n  \tonClick&#x3D;&#123;e &#x3D;&gt; handleChangeCurrent(item, e)&#125;\n    &gt;\n    &#x2F;&#x2F; 组件内容...\n    &lt;&#x2F;div&gt;\n)\n\nconst handleChangeCurrent &#x3D; (item: IData, e: React.MouseEvent&lt;HTMLDivElement&gt;) &#x3D;&gt; &#123;\n    e.stopPropagation();\n    setCurrent(item);\n&#125;;\n复制代码\n\n这点代码中，点击某个盒子，就将它设置为当前的盒子，方便执行其他操作。当鼠标点击盒子时，会触发handleChangeCurren方法，该方法有两个参数，第二个参数是event对象，在方法中执行了e.stopPropagation();是为了阻止冒泡事件，这里的stopPropagation()实际上并不是鼠标事件MouseEvent的属性，它是合成事件上的属性，来看看声明文件中的定义：\ninterface MouseEvent&lt;T &#x3D; Element, E &#x3D; NativeMouseEvent&gt; extends UIEvent&lt;T, E&gt; &#123;\n  &#x2F;&#x2F;...     \n&#125;\n\ninterface UIEvent&lt;T &#x3D; Element, E &#x3D; NativeUIEvent&gt; extends SyntheticEvent&lt;T, E&gt; &#123;\n  &#x2F;&#x2F;...\n&#125;\n\ninterface SyntheticEvent&lt;T &#x3D; Element, E &#x3D; Event&gt; extends BaseSyntheticEvent&lt;E, EventTarget &amp; T, EventTarget&gt; &#123;&#125;\n\ninterface BaseSyntheticEvent&lt;E &#x3D; object, C &#x3D; any, T &#x3D; any&gt; &#123;\n  nativeEvent: E;\n  currentTarget: C;\n  target: T;\n  bubbles: boolean;\n  cancelable: boolean;\n  defaultPrevented: boolean;\n  eventPhase: number;\n  isTrusted: boolean;\n  preventDefault(): void;\n  isDefaultPrevented(): boolean;\n  stopPropagation(): void;\n  isPropagationStopped(): boolean;\n  persist(): void;\n  timeStamp: number;\n  type: string;\n&#125;\n复制代码\n\n可以看到，这里的stopPropagation()是一层层的继承来的，最终来自于BaseSyntheticEvent合成事件类型。原生的事件集合SyntheticEvent就是继承自合成时间类型。SyntheticEvent&lt;T &#x3D; Element, E &#x3D; Event&gt;泛型接口接收当前的元素类型和事件类型，如果不介意这两个参数的类型，完全可以这样写：\n&lt;input \n  onChange&#x3D;&#123;(e: SyntheticEvent&lt;Element, Event&gt;)&#x3D;&gt;&#123;\n    &#x2F;&#x2F;... \n  &#125;&#125;\n&#x2F;&gt;\n复制代码\n\n2. 事件处理函数类型说完事件对象类型，再来看看事件处理函数的类型。React也为我们提供了贴心的提供了事件处理函数的类型声明，来看看所有的事件处理函数的类型声明：\ntype EventHandler&lt;E extends SyntheticEvent&lt;any&gt;&gt; &#x3D; &#123; bivarianceHack(event: E): void &#125;[&quot;bivarianceHack&quot;];\n\ntype ReactEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;SyntheticEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 剪切板事件处理函数\ntype ClipboardEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;ClipboardEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 复合事件处理函数\ntype CompositionEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;CompositionEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 拖拽事件处理函数\ntype DragEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;DragEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 焦点事件处理函数\ntype FocusEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;FocusEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 表单事件处理函数\ntype FormEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;FormEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; Change事件处理函数\ntype ChangeEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;ChangeEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 键盘事件处理函数\ntype KeyboardEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;KeyboardEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 鼠标事件处理函数\ntype MouseEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;MouseEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 触屏事件处理函数\ntype TouchEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;TouchEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 指针事件处理函数\ntype PointerEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;PointerEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 界面事件处理函数\ntype UIEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;UIEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 滚轮事件处理函数\ntype WheelEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;WheelEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 动画事件处理函数\ntype AnimationEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;AnimationEvent&lt;T&gt;&gt;;\n&#x2F;&#x2F; 过渡事件处理函数\ntype TransitionEventHandler&lt;T &#x3D; Element&gt; &#x3D; EventHandler&lt;TransitionEvent&lt;T&gt;&gt;;\n复制代码\n\n这里面的T的类型也都是Element，指的是触发该事件的HTML标签元素的类型，下面第五部分会介绍。 ​\nEventHandler会接收一个E，它表示事件处理函数中 Event 对象的类型。bivarianceHack 是事件处理函数的类型定义，函数接收一个 Event 对象，并且其类型为接收到的泛型变量 E 的类型, 返回值为 void。 ​\n还看上面的那个例子：\ntype State &#x3D; &#123;\n  text: string;\n&#125;;\n\nconst App: React.FC &#x3D; () &#x3D;&gt; &#123;  \n  const [text, setText] &#x3D; useState&lt;string&gt;(&quot;&quot;)\n\n  const onChange: React.ChangeEventHandler&lt;HTMLInputElement&gt; &#x3D; (e) &#x3D;&gt; &#123;\n    setText(e.currentTarget.value);\n  &#125;;\n  \n  return (\n    &lt;div&gt;\n      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;text&#125; onChange&#x3D;&#123;onChange&#125; &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;\n\n复制代码\n\n这里给onChange方法定义了方法的类型，它是一个ChangeEventHandler的类型，并且作用的对象时一个HTMLImnputElement类型的标签（input标签）。\n五、HTML标签类型1. 常见标签类型在项目的依赖文件中可以找到HTML标签相关的类型声明文件：\n\n所有的HTML标签的类型都被定义在 intrinsicElements 接口中，常见的标签及其类型如下：\na: HTMLAnchorElement;\nbody: HTMLBodyElement;\nbr: HTMLBRElement;\nbutton: HTMLButtonElement;\ndiv: HTMLDivElement;\nh1: HTMLHeadingElement;\nh2: HTMLHeadingElement;\nh3: HTMLHeadingElement;\nhtml: HTMLHtmlElement;\nimg: HTMLImageElement;\ninput: HTMLInputElement;\nul: HTMLUListElement;\nli: HTMLLIElement;\nlink: HTMLLinkElement;\np: HTMLParagraphElement;\nspan: HTMLSpanElement;\nstyle: HTMLStyleElement;\ntable: HTMLTableElement;\ntbody: HTMLTableSectionElement;\nvideo: HTMLVideoElement;\naudio: HTMLAudioElement;\nmeta: HTMLMetaElement;\nform: HTMLFormElement; \n复制代码\n\n那什么时候会使用到标签类型呢，上面第四部分的Event事件类型和事件处理函数类型中都使用到了标签的类型。上面的很多的类型都需要传入一个ELement类型的泛型参数，这个泛型参数就是对应的标签类型值，可以根据标签来选择对应的标签类型。这些类型都继承自HTMLElement类型，如果使用时对类型类型要求不高，可以直接写HTMLELement。比如下面的例子：\n&lt;Button\n\ttype&#x3D;&quot;text&quot;\n\tonClick&#x3D;&#123;(e: React.MouseEvent&lt;HTMLElement&gt;) &#x3D;&gt; &#123;\n  handleOperate();\n  e.stopPropagation();\n&#125;&#125;\n  &gt;\n    &lt;img\n\tsrc&#x3D;&#123;cancelChangeIcon&#125;\n\talt&#x3D;&quot;&quot;\n    &#x2F;&gt;\n    取消修改\n&lt;&#x2F;Button&gt;\n复制代码\n\n其实，在直接操作DOM时也会用到标签类型，虽然我们现在通常会使用框架来开发，但是有时候也避免不了直接操作DOM。比如我在工作中，项目中的某一部分组件是通过npm来引入的其他组的组件，而在很多时候，我有需要动态的去个性化这个组件的样式，最直接的办法就是通过原生JavaScript获取到DOM元素，来进行样式的修改，这时候就会用到标签类型。 ​\n来看下面的例子：\ndocument.querySelectorAll(&#39;.paper&#39;).forEach(item &#x3D;&gt; &#123;\n  const firstPageHasAddEle &#x3D; (item.firstChild as HTMLDivElement).classList.contains(&#39;add-ele&#39;);\n  \n  if (firstPageHasAddEle) &#123;\n    item.removeChild(item.firstChild as ChildNode);\n  &#125;\n&#125;)\n复制代码\n\n这是我最近写的一段代码（略微删改），在第一页有个add-ele元素的时候就删除它。这里我们将item.firstChild断言成了HTMLDivElement类型，如果不断言，item.firstChild的类型就是ChildNode，而ChildNode类型中是不存在classList属性的，所以就就会报错，当我们把他断言成HTMLDivElement类型时，就不会报错了。很多时候，标签类型可以和断言（as）一起使用。 ​\n后面在removeChild时又使用了as断言，为什么呢？item.firstChild不是已经自动识别为ChildNode类型了吗？因为TS会认为，我们可能不能获取到类名为paper的元素，所以item.firstChild的类型就被推断为ChildNode | null，我们有时候比TS更懂我们定义的元素，知道页面一定存在paper 元素，所以可以直接将item.firstChild断言成ChildNode类型。\n2. 标签属性类型众所周知，每个HTML标签都有自己的属性，比如Input框就有value、width、placeholder、max-length等属性，下面是Input框的属性类型定义：\ninterface InputHTMLAttributes&lt;T&gt; extends HTMLAttributes&lt;T&gt; &#123;\n  accept?: string | undefined;\n  alt?: string | undefined;\n  autoComplete?: string | undefined;\n  autoFocus?: boolean | undefined;\n  capture?: boolean | string | undefined;\n  checked?: boolean | undefined;\n  crossOrigin?: string | undefined;\n  disabled?: boolean | undefined;\n  enterKeyHint?: &#39;enter&#39; | &#39;done&#39; | &#39;go&#39; | &#39;next&#39; | &#39;previous&#39; | &#39;search&#39; | &#39;send&#39; | undefined;\n  form?: string | undefined;\n  formAction?: string | undefined;\n  formEncType?: string | undefined;\n  formMethod?: string | undefined;\n  formNoValidate?: boolean | undefined;\n  formTarget?: string | undefined;\n  height?: number | string | undefined;\n  list?: string | undefined;\n  max?: number | string | undefined;\n  maxLength?: number | undefined;\n  min?: number | string | undefined;\n  minLength?: number | undefined;\n  multiple?: boolean | undefined;\n  name?: string | undefined;\n  pattern?: string | undefined;\n  placeholder?: string | undefined;\n  readOnly?: boolean | undefined;\n  required?: boolean | undefined;\n  size?: number | undefined;\n  src?: string | undefined;\n  step?: number | string | undefined;\n  type?: string | undefined;\n  value?: string | ReadonlyArray&lt;string&gt; | number | undefined;\n  width?: number | string | undefined;\n\n  onChange?: ChangeEventHandler&lt;T&gt; | undefined;\n&#125;\n复制代码\n\n如果我们需要直接操作DOM，就可能会用到元素属性类型，常见的元素属性类型如下：\n\nHTML属性类型：HTMLAttributes\n按钮属性类型：ButtonHTMLAttributes\n表单属性类型：FormHTMLAttributes\n图片属性类型：ImgHTMLAttributes\n输入框属性类型：InputHTMLAttributes\n链接属性类型：LinkHTMLAttributes\nmeta属性类型：MetaHTMLAttributes\n选择框属性类型：SelectHTMLAttributes\n表格属性类型：TableHTMLAttributes\n输入区属性类型：TextareaHTMLAttributes\n视频属性类型：VideoHTMLAttributes\nSVG属性类型：SVGAttributes\nWebView属性类型：WebViewHTMLAttributes\n\n一般情况下，我们是很少需要在项目中显式的去定义标签属性的类型。如果子级去封装组件库的话，这些属性就能发挥它们的作用了。来看例子（来源于网络，仅供学习）：\nimport React from &#39;react&#39;;\nimport classNames from &#39;classnames&#39;\n\nexport enum ButtonSize &#123;\n    Large &#x3D; &#39;lg&#39;,\n    Small &#x3D; &#39;sm&#39;\n&#125;\n\nexport enum ButtonType &#123;\n    Primary &#x3D; &#39;primary&#39;,\n    Default &#x3D; &#39;default&#39;,\n    Danger &#x3D; &#39;danger&#39;,\n    Link &#x3D; &#39;link&#39;\n&#125;\n\ninterface BaseButtonProps &#123;\n    className?: string;\n    disabled?: boolean;\n    size?: ButtonSize;\n    btnType?: ButtonType;\n    children: React.ReactNode;\n    href?: string;    \n&#125;\n\ntype NativeButtonProps &#x3D; BaseButtonProps &amp; React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt; &#x2F;&#x2F; 使用 交叉类型（&amp;） 获得我们自己定义的属性和原生 button 的属性\ntype AnchorButtonProps &#x3D; BaseButtonProps &amp; React.AnchorHTMLAttributes&lt;HTMLAnchorElement&gt; &#x2F;&#x2F; 使用 交叉类型（&amp;） 获得我们自己定义的属性和原生 a标签 的属性\n\nexport type ButtonProps &#x3D; Partial&lt;NativeButtonProps &amp; AnchorButtonProps&gt; &#x2F;&#x2F;使用 Partial&lt;&gt; 使两种属性可选\n\nconst Button: React.FC&lt;ButtonProps&gt; &#x3D; (props) &#x3D;&gt; &#123;\n    const &#123; \n        disabled,\n        className, \n        size,\n        btnType,\n        children,\n        href,\n        ...restProps  \n    &#125; &#x3D; props;\n\n    const classes &#x3D; classNames(&#39;btn&#39;, className, &#123;\n        [&#96;btn-$&#123;btnType&#125;&#96;]: btnType,\n        [&#96;btn-$&#123;size&#125;&#96;]: size,\n        &#39;disabled&#39;: (btnType &#x3D;&#x3D;&#x3D; ButtonType.Link) &amp;&amp; disabled  &#x2F;&#x2F; 只有 a 标签才有 disabled 类名，button没有\n    &#125;)\n\n    if(btnType &#x3D;&#x3D;&#x3D; ButtonType.Link &amp;&amp; href) &#123;\n        return (\n            &lt;a \n            \tclassName&#x3D;&#123;classes&#125;\n            \thref&#x3D;&#123;href&#125;\n            \t&#123;...restProps&#125;\n            &gt;\n                &#123;children&#125;\n            &lt;&#x2F;a&gt;\n        )\n\n    &#125; else &#123;\n        return (\n            &lt;button \n            \tclassName&#x3D;&#123;classes&#125;\n            \tdisabled&#x3D;&#123;disabled&#125; &#x2F;&#x2F; button元素默认有disabled属性，所以即便没给他设置样式也会和普通button有一定区别\n\n            \t&#123;...restProps&#125;\n            &gt;\n                &#123;children&#125;\n            &lt;&#x2F;button&gt;\n        )\n    &#125;\n&#125;\n\nButton.defaultProps &#x3D; &#123;\n    disabled: false,\n    btnType: ButtonType.Default\n&#125;\n\nexport default Button;\n复制代码\n\n这段代码就是用来封装一个buttom按钮，在button的基础上添加了一些自定义属性，比如上面将button的类型使用交叉类型（&amp;）获得自定义属性和原生 button 属性 ：\ntype NativeButtonProps &#x3D; BaseButtonProps &amp; React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt; \n复制代码\n\n可以看到，标签属性类型在封装组件库时还是很有用的，更多用途可以自己探索~\n六、工具泛型在项目中使用一些工具泛型可以提高我们的开发效率，少写很多类型定义。下面来看看有哪些常见的工具泛型，以及其使用方式。\n1. PartialPartial 作用是将传入的属性变为可选项。适用于对类型结构不明确的情况。它使用了两个关键字：keyof和in，先来看看他们都是什么含义。keyof 可以用来取得接口的所有 key 值：\ninterface IPerson &#123;\n  name: string;\n  age: number;\n  height: number;\n&#125;\ntype T &#x3D; keyof IPerson \n&#x2F;&#x2F; T 类型为： &quot;name&quot; | &quot;age&quot; | &quot;number&quot;\n复制代码\n\nin关键字可以遍历枚举类型,：\ntype Person &#x3D; &quot;name&quot; | &quot;age&quot; | &quot;number&quot;\ntype Obj &#x3D;  &#123;\n  [p in Keys]: any\n&#125; \n&#x2F;&#x2F; Obj类型为： &#123; name: any, age: any, number: any &#125;\n复制代码\n\nkeyof 可以产生联合类型, in 可以遍历枚举类型, 所以经常一起使用, 下面是Partial工具泛型的定义：\n&#x2F;**\n * Make all properties in T optional\n * 将T中的所有属性设置为可选\n *&#x2F;\ntype Partial&lt;T&gt; &#x3D; &#123;\n    [P in keyof T]?: T[P];\n&#125;;\n复制代码\n\n这里，keyof T 获取 T 所有属性名, 然后使用 in 进行遍历, 将值赋给 P, 最后 T[P] 取得相应属性的值。中间的?就用来将属性设置为可选。\n使用示例如下：\ninterface IPerson &#123;\n  name: string;\n  age: number;\n  height: number;\n&#125;\n\nconst person: Partial&lt;IPerson&gt; &#x3D; &#123;\n  name: &quot;zhangsan&quot;;\n&#125;\n复制代码\n\n2. RequiredRequired 的作用是将传入的属性变为必选项，和上面的工具泛型恰好相反，其声明如下：\n&#x2F;**\n * Make all properties in T required\n * 将T中的所有属性设置为必选\n *&#x2F;\ntype Required&lt;T&gt; &#x3D; &#123;\n    [P in keyof T]-?: T[P];\n&#125;;\n复制代码\n\n可以看到，这里使用-?将属性设置为必选，可以理解为减去问号。适用形式和上面的Partial差不多：\ninterface IPerson &#123;\n  name?: string;\n  age?: number;\n  height?: number;\n&#125;\n\nconst person: Required&lt;IPerson&gt; &#x3D; &#123;\n  name: &quot;zhangsan&quot;;\n  age: 18;\n  height: 180;\n&#125;\n复制代码\n\n3. Readonly将T类型的所有属性设置为只读（readonly），构造出来类型的属性不能被再次赋值。Readonly的声明形式如下：\n&#x2F;**\n * Make all properties in T readonly\n *&#x2F;\ntype Readonly&lt;T&gt; &#x3D; &#123;\n    readonly [P in keyof T]: T[P];\n&#125;;\n复制代码\n\n使用示例如下：\ninterface IPerson &#123;\n  name: string;\n  age: number;\n&#125;\n\nconst person: Readonly&lt;IPerson&gt; &#x3D; &#123;\n  name: &quot;zhangsan&quot;,\n  age: 18\n&#125;\n\nperson.age &#x3D; 20;  &#x2F;&#x2F;  Error: cannot reassign a readonly property\n复制代码\n\n可以看到，通过 Readonly 将IPerson的属性转化成了只读，不能再进行赋值操作。\n4. Pick&lt;T, K extends keyof T&gt;从T类型中挑选部分属性K来构造新的类型。它的声明形式如下：\n&#x2F;**\n * From T, pick a set of properties whose keys are in the union K\n *&#x2F;\ntype Pick&lt;T, K extends keyof T&gt; &#x3D; &#123;\n    [P in K]: T[P];\n&#125;;\n复制代码\n\n使用示例如下：\ninterface IPerson &#123;\n  name: string;\n  age: number;\n  height: number;\n&#125;\n\nconst person: Pick&lt;IPerson, &quot;name&quot; | &quot;age&quot;&gt; &#x3D; &#123;\n  name: &quot;zhangsan&quot;,\n  age: 18\n&#125;\n复制代码\n\n5. Record&lt;K extends keyof any, T&gt;Record 用来构造一个类型，其属性名的类型为K，属性值的类型为T。这个工具泛型可用来将某个类型的属性映射到另一个类型上，下面是其声明形式：\n&#x2F;**\n * Construct a type with a set of properties K of type T\n *&#x2F;\ntype Record&lt;K extends keyof any, T&gt; &#x3D; &#123;\n    [P in K]: T;\n&#125;;\n复制代码\n\n使用示例如下：\ninterface IPageinfo &#123;\n    title: string;\n&#125;\n\ntype IPage &#x3D; &#39;home&#39; | &#39;about&#39; | &#39;contact&#39;;\n\nconst page: Record&lt;IPage, IPageinfo&gt; &#x3D; &#123;\n    about: &#123;title: &#39;about&#39;&#125;,\n    contact: &#123;title: &#39;contact&#39;&#125;,\n    home: &#123;title: &#39;home&#39;&#125;,\n&#125;\n复制代码\n\n6. Exclude&lt;T, U&gt;Exclude 就是从一个联合类型中排除掉属于另一个联合类型的子集，下面是其声明的形式：\n&#x2F;**\n * Exclude from T those types that are assignable to U\n *&#x2F;\ntype Exclude&lt;T, U&gt; &#x3D; T extends U ? never : T;\n复制代码\n\n使用示例如下：\ninterface IPerson &#123;\n  name: string;\n  age: number;\n  height: number;\n&#125;\n\nconst person: Exclude&lt;IPerson, &quot;age&quot; | &quot;sex&quot;&gt; &#x3D; &#123;\n  name: &quot;zhangsan&quot;;\n  height: 180;\n&#125;\n复制代码\n\n7. Omit&lt;T, K extends keyof any&gt;上面的Pick 和 Exclude 都是最基础基础的工具泛型，很多时候用 Pick 或者 Exclude 还不如直接写类型更直接。而 Omit 就基于这两个来做的一个更抽象的封装，它允许从一个对象中剔除若干个属性，剩下的就是需要的新类型。下面是它的声明形式：\n&#x2F;**\n * Construct a type with the properties of T except for those in type K.\n *&#x2F;\ntype Omit&lt;T, K extends keyof any&gt; &#x3D; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;\n复制代码\n\n使用示例如下：\ninterface IPerson &#123;\n  name: string;\n  age: number;\n  height: number;\n&#125;\n\nconst person: Omit&lt;IPerson, &quot;age&quot; | &quot;height&quot;&gt; &#x3D; &#123;\n  name: &quot;zhangsan&quot;;\n&#125;\n复制代码\n\n8. ReturnTypeReturnType会返回函数返回值的类型，其声明形式如下：\n&#x2F;**\n * Obtain the return type of a function type\n *&#x2F;\ntype ReturnType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (...args: any) &#x3D;&gt; infer R ? R : any;\n复制代码\n\n使用示例如下：\nfunction foo(type): boolean &#123;\n  return type &#x3D;&#x3D;&#x3D; 0\n&#125;\n\ntype FooType &#x3D; ReturnType&lt;typeof foo&gt;\n复制代码\n\n这里使用 typeof 是为了获取 foo 的函数签名，等价于 (type: any) &#x3D;&gt; boolean。\n七、Axios 封装在React项目中，我们经常使用Axios库进行数据请求，Axios 是基于 Promise 的 HTTP 库，可以在浏览器和 node.js 中使用。Axios 具备以下特性：\n\n从浏览器中创建 XMLHttpRequests；\n从 node.js 创建 HTTP 请求；\n支持 Promise API；\n拦截请求和响应；\n转换请求数据和响应数据；\n取消请求；\n自动转换 JSON 数据；\n客户端支持防御 XSRF。\n\nAxios的基本使用就不再多介绍了。为了更好地调用，做一些全局的拦截，通常会对Axios进行封装，下面就使用TypeScript对Axios进行简单封装，使其同时能够有很好的类型支持。Axios是自带声明文件的，所以我们无需额外的操作。 ​\n下面来看基本的封装：\nimport axios, &#123; AxiosInstance, AxiosRequestConfig, AxiosPromise,AxiosResponse &#125; from &#39;axios&#39;; &#x2F;&#x2F; 引入axios和定义在node_modules&#x2F;axios&#x2F;index.ts文件里的类型声明\n\n &#x2F;&#x2F; 定义接口请求类，用于创建axios请求实例\nclass HttpRequest &#123;\n  &#x2F;&#x2F; 接收接口请求的基本路径\n  constructor(public baseUrl: string) &#123; \n    this.baseUrl &#x3D; baseUrl;\n  &#125;\n  \n  &#x2F;&#x2F; 调用接口时调用实例的这个方法，返回AxiosPromise\n  public request(options: AxiosRequestConfig): AxiosPromise &#123; \n    &#x2F;&#x2F; 创建axios实例，它是函数，同时这个函数包含多个属性\n    const instance: AxiosInstance &#x3D; axios.create() \n    &#x2F;&#x2F; 合并基础路径和每个接口单独传入的配置，比如url、参数等\n    options &#x3D; this.mergeConfig(options) \n    &#x2F;&#x2F; 调用interceptors方法使拦截器生效\n    this.interceptors(instance, options.url) \n    &#x2F;&#x2F; 返回AxiosPromise\n    return instance(options) \n  &#125;\n  \n  &#x2F;&#x2F; 用于添加全局请求和响应拦截\n  private interceptors(instance: AxiosInstance, url?: string) &#123; \n    &#x2F;&#x2F; 请求和响应拦截\n  &#125;\n  \n  &#x2F;&#x2F; 用于合并基础路径配置和接口单独配置\n  private mergeConfig(options: AxiosRequestConfig): AxiosRequestConfig &#123; \n    return Object.assign(&#123; baseURL: this.baseUrl &#125;, options);\n  &#125;\n&#125;\nexport default HttpRequest;\n复制代码\n\n通常baseUrl在开发环境的和生产环境的路径是不一样的，所以可以根据当前是开发环境还是生产环境做判断，应用不同的基础路径。这里要写在一个配置文件里：\nexport default &#123;\n    api: &#123;\n        devApiBaseUrl: &#39;&#x2F;test&#x2F;api&#x2F;xxx&#39;,\n        proApiBaseUrl: &#39;&#x2F;api&#x2F;xxx&#39;,\n    &#125;,\n&#125;;\n复制代码\n\n在上面的文件中引入这个配置：\nimport &#123; api: &#123; devApiBaseUrl, proApiBaseUrl &#125; &#125; from &#39;@&#x2F;config&#39;;\nconst apiBaseUrl &#x3D; env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; ? proApiBaseUrl : devApiBaseUrl;\n复制代码\n\n之后就可以将apiBaseUrl作为默认值传入HttpRequest的参数：\nclass HttpRequest &#123; \n  constructor(public baseUrl: string &#x3D; apiBaseUrl) &#123; \n    this.baseUrl &#x3D; baseUrl;\n  &#125;\n复制代码\n\n接下来可以完善一下拦截器类，在类中interceptors方法内添加请求拦截器和响应拦截器，实现对所有接口请求的统一处理：\nprivate interceptors(instance: AxiosInstance, url?: string) &#123;\n  \t&#x2F;&#x2F; 请求拦截\n    instance.interceptors.request.use((config: AxiosRequestConfig) &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 接口请求的所有配置，可以在axios.defaults修改配置\n      return config\n    &#125;,\n    (error) &#x3D;&gt; &#123;\n      return Promise.reject(error)\n    &#125;)\n \t\n  \t&#x2F;&#x2F; 响应拦截\n    instance.interceptors.response.use((res: AxiosResponse) &#x3D;&gt; &#123;\n      const &#123; data &#125; &#x3D; res \n      const &#123; code, msg &#125; &#x3D; data\n      if (code !&#x3D;&#x3D; 0) &#123;\n        console.error(msg) \n      &#125;\n      return res\n    &#125;,\n    (error) &#x3D;&gt; &#123; \n      return Promise.reject(error)\n    &#125;)\n  &#125;\n复制代码\n\n到这里封装的就差不多了，一般服务端会将状态码、提示信息和数据封装在一起，然后作为数据返回，所以所有请求返回的数据格式都是一样的，所以就可以定义一个接口来指定返回的数据结构，可以定义一个接口：\nexport interface ResponseData &#123;\n  code: number\n  data?: any\n  msg: string\n&#125;\n复制代码\n\n接下来看看使用TypeScript封装的Axios该如何使用。可以先定义一个请求实例：\nimport HttpRequest from &#39;@&#x2F;utils&#x2F;axios&#39;\nexport * from &#39;@&#x2F;utils&#x2F;axios&#39;\nexport default new HttpRequest()\n复制代码\n\n这里把请求类导入进来，默认导出这个类的实例。之后创建一个登陆接口请求方法：\nimport axios, &#123; ResponseData &#125; from &#39;.&#x2F;index&#39;\nimport &#123; AxiosPromise &#125; from &#39;axios&#39;\n\ninterface ILogin &#123;\n  user: string;\n  password: number | string\n&#125;\n\nexport const loginReq &#x3D; (data: ILogin): AxiosPromise&lt;ResponseData&gt; &#x3D;&gt; &#123;\n  return axios.request(&#123;\n    url: &#39;&#x2F;api&#x2F;user&#x2F;login&#39;,\n    data,\n    method: &#39;POST&#39;\n  &#125;)\n&#125;\n复制代码\n\n这里封装登录请求方法loginReq，他的参数必须是我们定义的ILogin接口的类型。这个方法返回一个类型为AxiosPromise的Promise，AxiosPromise是axios声明文件内置的类型，可以传入一个泛型变量参数，用于指定返回的结果中data字段的类型。 ​\n接下来可以调用一下这个登录的接口：\nimport &#123; loginReq &#125; from &#39;@&#x2F;api&#x2F;user&#39;\n\nconst Home: FC &#x3D; () &#x3D;&gt; &#123;\n  const login &#x3D; (params) &#x3D;&gt; &#123;\n  \tloginReq(params).then((res) &#x3D;&gt; &#123;\n    \tconsole.log(res.data.code)\n  \t&#125;)\t\n  &#125;  \n&#125;\n复制代码\n\n通过这种方式，当我们调用loginReq接口时，就会提示我们，参数的类型是ILogin，需要传入几个参数。这样编写代码的体验就会好很多。\n八. 其他1. import React在React项目中使用TypeScript时，普通组件文件后缀为.tsx，公共方法文件后缀为.ts。在. tsx 文件中导入 React 的方式如下：\nimport * as React from &#39;react&#39;\nimport * as ReactDOM from &#39;react-dom&#39;\n复制代码\n\n这是一种面向未来的导入方式，如果想在项目中使用以下导入方式：\nimport React from &quot;react&quot;;\nimport ReactDOM from &quot;react-dom&quot;;\n复制代码\n\n就需要在tsconfig.json配置文件中进行如下配置：\n&quot;compilerOptions&quot;: &#123;\n    &#x2F;&#x2F; 允许默认从没有默认导出的模块导入。\n    &quot;allowSyntheticDefaultImports&quot;: true,\n&#125;\n复制代码\n\n2. Types or Interfaces？我们可以使用types或者Interfaces来定义类型吗，那么该如何选择他俩呢？建议如下：\n\n在定义公共 API 时(比如编辑一个库）使用 interface，这样可以方便使用者继承接口，这样允许使用最通过声明合并来扩展它们；\n在定义组件属性（Props）和状态（State）时，建议使用 type，因为 type 的约束性更强。\n\ninterface 和 type 在 ts 中是两个不同的概念，但在 React 大部分使用的 case 中，interface 和 type 可以达到相同的功能效果，type 和 interface 最大的区别是：type 类型不能二次编辑，而 interface 可以随时扩展：\ninterface Animal &#123;\n  name: string\n&#125;\n\n&#x2F;&#x2F; 可以继续在原属性基础上，添加新属性：color\ninterface Animal &#123;\n  color: string\n&#125;\n\ntype Animal &#x3D; &#123;\n  name: string\n&#125;\n&#x2F;&#x2F; type类型不支持属性扩展\n&#x2F;&#x2F; Error: Duplicate identifier &#39;Animal&#39;\ntype Animal &#x3D; &#123;\n  color: string\n&#125;\n复制代码\n\ntype对于联合类型是很有用的，比如：type Type &#x3D; TypeA | TypeB。而interface更适合声明字典类行，然后定义或者扩展它。\n3. 懒加载类型如果我们想在React router中使用懒加载，React也为我们提供了懒加载方法的类型，来看下面的例子：\nexport interface RouteType &#123;\n    pathname: string;\n    component: LazyExoticComponent&lt;any&gt;;\n    exact: boolean;\n    title?: string;\n    icon?: string;\n    children?: RouteType[];\n&#125;\nexport const AppRoutes: RouteType[] &#x3D; [\n    &#123;\n        pathname: &#39;&#x2F;login&#39;,\n        component: lazy(() &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Login&#x2F;Login&#39;)),\n        exact: true\n    &#125;,\n    &#123;\n        pathname: &#39;&#x2F;404&#39;,\n        component: lazy(() &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;404&#x2F;404&#39;)),\n        exact: true,\n    &#125;,\n    &#123;\n        pathname: &#39;&#x2F;&#39;,\n        exact: false,\n        component: lazy(() &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Admin&#x2F;Admin&#39;))\n    &#125;\n]\n\n复制代码\n\n下面是懒加载类型和lazy方法在声明文件中的定义：\ntype LazyExoticComponent&lt;T extends ComponentType&lt;any&gt;&gt; &#x3D; ExoticComponent&lt;ComponentPropsWithRef&lt;T&gt;&gt; &amp; &#123;\n  readonly _result: T;\n&#125;;\n\nfunction lazy&lt;T extends ComponentType&lt;any&gt;&gt;(\nfactory: () &#x3D;&gt; Promise&lt;&#123; default: T &#125;&gt;\n): LazyExoticComponent&lt;T&gt;;\n复制代码\n\n4. 类型断言类型断言（Type Assertion）可以用来手动指定一个值的类型。在React项目中，断言还是很有用的，。有时候推断出来的类型并不是真正的类型，很多时候我们可能会比TS更懂我们的代码，所以可以使用断言（使用as关键字）来定义一个值得类型。 ​\n来看下面的例子：\nconst getLength &#x3D; (target: string | number): number &#x3D;&gt; &#123;\n  if (target.length) &#123; &#x2F;&#x2F; error 类型&quot;string | number&quot;上不存在属性&quot;length&quot;\n    return target.length; &#x2F;&#x2F; error  类型&quot;number&quot;上不存在属性&quot;length&quot;\n  &#125; else &#123;\n    return target.toString().length;\n  &#125;\n&#125;;\n复制代码\n\n当TypeScript不确定一个联合类型的变量到底是哪个类型时，就只能访问此联合类型的所有类型里共有的属性或方法，所以现在加了对参数target和返回值的类型定义之后就会报错。这时就可以使用断言，将target的类型断言成string类型：\nconst getStrLength &#x3D; (target: string | number): number &#x3D;&gt; &#123;\n  if ((target as string).length) &#123;      \n    return (target as string).length; \n  &#125; else &#123;\n    return target.toString().length;\n  &#125;\n&#125;;\n复制代码\n\n需要注意，类型断言并不是类型转换，断言成一个联合类型中不存在的类型是不允许的。 ​\n再来看一个例子，在调用一个方法时传入参数：  这里就提示我们这个参数可能是undefined，而通过业务知道这个值是一定存在的，所以就可以将它断言成数字：data?.subjectId as number ​\n除此之外，上面所说的标签类型、组件类型、时间类型都可以使用断言来指定给一些数据，还是要根据实际的业务场景来使用。 ​\n感悟：使用类型断言真的能解决项目中的很多报错~\n5. 枚举类型枚举类型在项目中的作用也是不可忽视的，使用枚举类型可以让代码的扩展性更好，当我想更改某属性值时，无需去全局更改这个属性，只要更改枚举中的值即可。通常情况下，最好新建一个文件专门来定义枚举值，便于引用。\n","slug":"如何优雅地在 React 中使用TypeScript","date":"2021-12-18T13:48:34.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"882b2e906d6e98c8bb89a8ff1e500dbe","title":"代码被revert,你pull了master,代码没了,咋找回来?","content":"问题场景实际工作中，在上线时，你的新功能代码都是在gitlab上提交merge to master的请求，拥有merge权限的领导通过后，你的代码才合到master。好，QA开始上线了你的代码，这时 啪，啪，报警了，代码有问题。领导revert了你的代码以保证master分支的正确。这时，你的分支pull了master后，你发现你分支上的新功能代码都没有了！！咋找回来\n本文从实战角度来解决这个问题\n条件\n假设你已经有了一个git项目: test-git，并且有两个分支: master，test\n\n实战在test分支，你创建了一个文件welcome，文本:hi git。并git commit -m &#39;测试git revert&#39;提交\n当前，master，test分支的内容分别如下\n~&#x2F;tt&#x2F;test-git&gt;&gt;master $ ll\ndrwxr-xr-x  3 tt  staff    96B  5  8 20:54 test\n-rw-r--r--  1 tt  staff    16B  8  1 19:55 test3.log\n复制代码\n\n~&#x2F;tt&#x2F;test-git&gt;&gt;test $ ll\ndrwxr-xr-x  3 tt  staff    96B  5  8 20:54 test\n-rw-r--r--  1 tt  staff    16B  8  1 19:55 test3.log\n-rw-r--r--  1 tt  staff     7B  8  1 20:19 welcome\n\n~&#x2F;tt&#x2F;test-git&gt;&gt;test $ cat welcome\nhi git\n复制代码\n\n现在，向master提交merge to master请求，如下图 \n领导merge后开始上线，假设线上出现问题，领导revert了这次提交的代码。如下图 \n接着你要查看问题，所以你会本地操作，回到你的代码分支，执行git merge origin/master\n~&#x2F;tt&#x2F;test-git&gt;&gt;test $ git merge origin&#x2F;master\nUpdating 670adc2..d3961f7\nFast-forward\n welcome | 1 -\n 1 file changed, 1 deletion(-)\n delete mode 100644 welcome\n~&#x2F;tt&#x2F;test-git&gt;&gt;test $ ll\ntotal 8\ndrwxr-xr-x  3 tt  staff    96B  5  8 20:54 test\n-rw-r--r--  1 tt  staff    16B  8  1 19:55 test3.log\n复制代码\n\n此时，你发现你提交的代码没有了。welcome文件不见了，咋办\n咋找回来这些代码呢？下面开始找回操作\n\ngit log找到领导revert你代码的那个commit id，这里commit id是50a06845da879ab76e6fdd55dce923826742dcb2。如下图三个commit的说明 \ngit revert --no-commit 50a06845da879ab76e6fdd55dce923826742dcb2\n\n 你的代码已经回来了，然后就没有然后了，简单吧\n总结找到领导revert你代码的commit id，然后git revert --no-commit commit id\n一句话总结：把之前revert的那条commit再revert一下\n","slug":"代码被revert","date":"2021-11-21T13:36:54.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"22a53fdfd136fdbe0a4b16b8cca4b9ec","title":"分片加载超长列表渲染","content":"很早以前就有面试问超长列表如何优化，那时候觉得一般前端不会有这种功能，有也是分页，也就没有去关注。今天分享一个超长列表渲染的优化方法，分片加载，现在几乎也都不会用了，但是还是要知道这个东西。\n先明确eventloop的机制，js是单线程的，当你第一个主线程执行过程中，遇到宏任务就放到宏任务队列，遇到微任务就放到微任务队列，这一次主线程执行完了之后，会把微任务队列清空，接着GUI渲染页面，然后再去宏任务队列里面把到时的宏任务提取出来从主线程执行，一直循环。\n先明确，页面渲染是在清空微任务之后：\n&lt;ul id&#x3D;&quot;wrap&quot;&gt;&lt;&#x2F;ul&gt;\n\n&lt;script&gt;\n\n    let time;\n\nPromise.resolve().then(res &#x3D;&gt; &#123;\n\n    for (let i &#x3D; 0; i &lt; 10000000000; i++) &#123;&#125;\n\n    console.log(&#39;微任务执行完毕&#39;, new Date() - time);&#x2F;&#x2F;微任务执行完毕 11124\n\n&#125;)\n\ndocument.getElementById(&#39;wrap&#39;).innerHTML &#x3D; &#39;页面渲染了&#39;;\n\ntime &#x3D; new Date();\n\nconsole.log(&#39;页面渲染语句执行&#39;);\n\n&lt;&#x2F;script&gt;\n复制代码\n\n接着看看渲染十万条数据页面使用的时间和js执行的时间：\n&lt;ul id&#x3D;&quot;wrap&quot;&gt;&lt;&#x2F;ul&gt;\n\n&lt;script&gt;\n\n    let total &#x3D; 100000;\n\n    let time &#x3D; new Date();\n\n    for (let i &#x3D; 0; i &lt; total; i++) &#123;\n\n        let li &#x3D; document.createElement(&#39;li&#39;);\n\n        li.innerHTML &#x3D; i;\n\n        document.getElementById(&#39;wrap&#39;).appendChild(li);\n\n    &#125;\n\n    console.log(&#39;js执行时间&#39;, new Date() - time);&#x2F;&#x2F;js执行时间 710\n\n    setTimeout(function () &#123;\n\n        console.log(&#39;页面渲染时间&#39;, new Date() - time);&#x2F;&#x2F;页面渲染时间 4771\n\n    &#125;)\n\n&lt;&#x2F;script&gt;\n复制代码\n\nJs执行很快，但是页面渲染要将近5秒，如果是一百万条数据测试了一下将近一分钟。所以我们要分片渲染。\n分片渲染：\n&lt;ul id&#x3D;&quot;wrap&quot;&gt;&lt;&#x2F;ul&gt;\n\n&lt;script&gt;\n\n    let total &#x3D; 100000;\n\n    let time &#x3D; new Date();\n\n    let index &#x3D; 0;\n\n    let id &#x3D; 0;\n\n    function loadList() &#123;\n\n        index +&#x3D; 50;\n\n        if(index &lt; total)&#123;\n\n           setTimeout(function () &#123;\n\n               for (let i &#x3D; 0; i &lt; 50; i++) &#123;\n\n                   let li &#x3D; document.createElement(&#39;li&#39;);\n\n                   li.innerHTML &#x3D; id++;\n\n                   document.getElementById(&#39;wrap&#39;).appendChild(li);\n\n               &#125;\n\n               loadList();\n\n           &#125;)\n\n        &#125;\n\n    &#125;\n\n    loadList()\n\n&lt;&#x2F;script&gt;\n复制代码\n\n分片渲染用的时间会比没分片长，好处就是不需要等所有渲染出来，可以直接看到数据，你拖动滚动条，还能看见页面还在加载。\n这边要注意一点，新版本浏览器对页面渲染做了优化，会等js执行完毕一次性更新页面，不会在for循环的时候执行一条插入一条，如果为了兼容ie，要用文档碎片进行渲染。也可以用requestAnimationFrame这个宏任务替代定时器，性能会稍微好一些。\n虽然分片渲染可以优化，但是这种方法，页面的dom还是过多了，所以这种方法现在也几乎不会用了，一般会使用虚拟列表方法去优化。\n","slug":"分片加载超长列表渲染","date":"2021-11-03T13:50:32.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"41fa294c894ff0de66f9b80c0c4a5c37","title":"Antv X6 绘制拖拽流程图","content":"使用antv x6 绘制拖拽流程图安装# npm\n$ npm install @antv&#x2F;x6 --save\n\n# yarn\n$ yarn add @antv&#x2F;x6\n复制代码\n\n使用创建容器\n&lt;!-- 画布 --&gt;\n&lt;div class&#x3D;&quot;graph&quot; ref&#x3D;&quot;graph&quot;&gt;&lt;&#x2F;div&gt;\n&lt;!-- 工具栏 --&gt;\n&lt;div class&#x3D;&quot;stencil&quot; ref&#x3D;&quot;stencil&quot;&gt;&lt;&#x2F;div&gt;\n复制代码\n\n创建实例画布\n&#x2F;&#x2F; 引入\nimport &#123; Graph, Addon, Shape &#125; from &#39;@antv&#x2F;x6&#39;;\n&#x2F;&#x2F; 创建实例\nconst graph &#x3D; new Graph(&#123;\n    container: this.$refs.graph, &#x2F;&#x2F; 画布的容器\n    &#x2F;&#x2F; grid: true, &#x2F;&#x2F; 网格\n    width: 770, \n    height: 590,\n    mousewheel: &#123;\n       enabled: true,\n       zoomAtMousePosition: true,\n       modifiers: &#39;ctrl&#39;,\n       minScale: 0.5,\n       maxScale: 3,\n    &#125;, &#x2F;&#x2F; 鼠标滚轮缩放\n    resizing: true, &#x2F;&#x2F; 缩放节点\n    selecting: &#123;\n        enabled: true,\n        rubberband: true,\n        showNodeSelectionBox: true,\n    &#125;, &#x2F;&#x2F; 点选&#x2F;框选\n    connecting: &#123;\n        router: &#123;\n            name: &#39;manhattan&#39;,\n            args: &#123;\n                padding: 1,\n            &#125;,\n        &#125;,\n        connector: &#123;\n            name: &#39;rounded&#39;,\n            args: &#123;\n                radius: 8,\n            &#125;,\n        &#125;,\n        anchor: &#39;center&#39;,\n        connectionPoint: &#39;anchor&#39;,\n        allowBlank: false,\n        snap: &#123;\n            radius: 20,\n        &#125;,\n        createEdge() &#123;\n            return new Shape.Edge(&#123;\n                attrs: &#123;\n                    line: &#123;\n                        stroke: &#39;#9ED4FF&#39;,\n                        strokeWidth: 2,\n                        targetMarker: &#123;\n                            name: &#39;block&#39;,\n                            width: 12,\n                            height: 8,\n                        &#125;,\n                    &#125;,\n                &#125;,\n                zIndex: 0,\n            &#125;);\n        &#125;,\n        validateConnection(&#123; targetMagnet &#125;) &#123;\n            return !!targetMagnet;\n        &#125;,\n    &#125;, &#x2F;&#x2F; 连线选项\n    highlighting: &#123;\n        magnetAdsorbed: &#123;\n            name: &#39;stroke&#39;,\n            args: &#123;\n                attrs: &#123;\n                    fill: &#39;#5F95FF&#39;,\n                    stroke: &#39;#5F95FF&#39;,\n                &#125;,\n            &#125;,\n        &#125;,\n    &#125;, &#x2F;&#x2F; 高亮选项。\n    snapline: true, &#x2F;&#x2F; 对齐线\n    keyboard: true, &#x2F;&#x2F; 键盘快捷键\n    clipboard: true, &#x2F;&#x2F; 剪切板\n&#125;);\n复制代码\n\n创建工具栏实例\n&#x2F;&#x2F; 工具栏\nconst stencil &#x3D; new Addon.Stencil(&#123;\n    title: &#39;流程图&#39;, &#x2F;&#x2F; 标题\n    target: graph, &#x2F;&#x2F; 目标画布\n    stencilGraphWidth: 600,\n    stencilGraphHeight: 500,\n    collapsable: false, &#x2F;&#x2F; 分组是否可折叠\n    groups: [\n        &#123;\n        title: &#39;基础流程图&#39;,\n        name: &#39;group1&#39;,\n        &#125;,\n    ], &#x2F;&#x2F; 提供的分组\n    layoutOptions: &#123; \n        columns: 1,\n        columnWidth: 80,\n        rowHeight: 50,\n    &#125;, &#x2F;&#x2F; 来对节点进行自动布局\n&#125;);\n&#x2F;&#x2F; 将     this.$refs.stencil.appendChild(stencil.container);\n复制代码\n\n连接点配置\n\n&#x2F;&#x2F; 连接点 上下左右四个连接点\nconst ports &#x3D; &#123;\n    groups: &#123;\n        top: &#123;\n            position: &#39;top&#39;,\n            attrs: &#123;\n                circle: &#123;\n                    r: 4,\n                    magnet: true,\n                    stroke: &#39;#5F95FF&#39;,\n                    strokeWidth: 1,\n                    fill: &#39;#fff&#39;,\n                    style: &#123;\n                        visibility: &#39;hidden&#39;,\n                    &#125;,\n                &#125;,\n            &#125;,\n        &#125;,\n        right: &#123;\n            position: &#39;right&#39;,\n            attrs: &#123;\n                circle: &#123;\n                    r: 4,\n                    magnet: true,\n                    stroke: &#39;#5F95FF&#39;,\n                    strokeWidth: 1,\n                    fill: &#39;#fff&#39;,\n                    style: &#123;\n                        visibility: &#39;hidden&#39;,\n                    &#125;,\n                &#125;,\n            &#125;,\n        &#125;,\n        bottom: &#123;\n            position: &#39;bottom&#39;,\n            attrs: &#123;\n                circle: &#123;\n                    r: 4,\n                    magnet: true,\n                    stroke: &#39;#5F95FF&#39;,\n                    strokeWidth: 1,\n                    fill: &#39;#fff&#39;,\n                    style: &#123;\n                        visibility: &#39;hidden&#39;,\n                    &#125;,\n                &#125;,\n            &#125;,\n        &#125;,\n        left: &#123;\n            position: &#39;left&#39;,\n            attrs: &#123;\n                circle: &#123;\n                    r: 4,\n                    magnet: true,\n                    stroke: &#39;#5F95FF&#39;,\n                    strokeWidth: 1,\n                    fill: &#39;#fff&#39;,\n                    style: &#123;\n                        visibility: &#39;hidden&#39;,\n                    &#125;,\n                &#125;,\n            &#125;,\n        &#125;,\n    &#125;,\n    items: [\n        &#123;\n            group: &#39;top&#39;,\n        &#125;,\n        &#123;\n            group: &#39;right&#39;,\n        &#125;,\n        &#123;\n            group: &#39;bottom&#39;,\n        &#125;,\n        &#123;\n            group: &#39;left&#39;,\n        &#125;,\n    ],\n&#125;;\n复制代码\n\n自定义节点\n&#x2F;&#x2F; 自定义节点\nGraph.registerNode(\n    &#39;custom-rect&#39;,\n    &#123;\n        inherit: &#39;rect&#39;,\n        width: 66,\n        height: 36,\n        attrs: &#123;\n            body: &#123;\n                strokeWidth: 1,\n                stroke: &#39;#5F95FF&#39;,\n                fill: &#39;#EFF4FF&#39;,\n            &#125;,\n            text: &#123;\n                fontSize: 12,\n                fill: &#39;#262626&#39;,\n            &#125;,\n        &#125;,\n        ports: &#123; ...ports &#125;,\n    &#125;,\n    true\n);\n\nGraph.registerNode(\n    &#39;custom-polygon&#39;,\n    &#123;\n        inherit: &#39;polygon&#39;,\n        width: 66,\n        height: 36,\n        attrs: &#123;\n            body: &#123;\n                strokeWidth: 1,\n                stroke: &#39;#5F95FF&#39;,\n                fill: &#39;#EFF4FF&#39;,\n            &#125;,\n            text: &#123;\n                fontSize: 12,\n                fill: &#39;#262626&#39;,\n            &#125;,\n        &#125;,\n        ports: &#123;\n            ...ports,\n            items: [\n                &#123;\n                    group: &#39;top&#39;,\n                &#125;,\n                &#123;\n                    group: &#39;bottom&#39;,\n                &#125;,\n            ],\n        &#125;,\n    &#125;,\n    true\n);\n\nGraph.registerNode(\n    &#39;custom-circle&#39;,\n    &#123;\n        inherit: &#39;circle&#39;,\n        width: 45,\n        height: 45,\n        attrs: &#123;\n            body: &#123;\n                strokeWidth: 1,\n                stroke: &#39;#5F95FF&#39;,\n                fill: &#39;#EFF4FF&#39;,\n            &#125;,\n            text: &#123;\n                fontSize: 12,\n                fill: &#39;#262626&#39;,\n            &#125;,\n        &#125;,\n        ports: &#123; ...ports &#125;,\n    &#125;,\n    true\n);\n\nconst r1 &#x3D; graph.createNode(&#123;\n    shape: &#39;custom-rect&#39;,\n    attrs: &#123;\n        text: &#123;\n            fontSize: 18,\n        &#125;,\n        body: &#123;\n            rx: 40,\n            ry: 26,\n        &#125;,\n    &#125;,\n&#125;);\nconst r2 &#x3D; graph.createNode(&#123;\n    shape: &#39;custom-rect&#39;,\n    attrs: &#123;\n        text: &#123;\n            fontSize: 18,\n        &#125;,\n    &#125;,\n&#125;);\nconst r3 &#x3D; graph.createNode(&#123;\n    shape: &#39;custom-rect&#39;,\n    attrs: &#123;\n        text: &#123;\n            fontSize: 18,\n        &#125;,\n        body: &#123;\n            rx: 6,\n            ry: 6,\n        &#125;,\n    &#125;,\n&#125;);\nconst r4 &#x3D; graph.createNode(&#123;\n    shape: &#39;custom-polygon&#39;,\n    attrs: &#123;\n        body: &#123;\n            refPoints: &#39;0,10 10,0 20,10 10,20&#39;,\n        &#125;,\n        text: &#123;\n            fontSize: 18,\n        &#125;,\n    &#125;,\n&#125;);\nstencil.load([r1, r2, r3, r4], &#39;group1&#39;);\n复制代码\n\n快捷键和事件触发\n&#x2F;&#x2F; 快捷键与事件\n&#x2F;&#x2F; 复制粘贴\ngraph.bindKey([&#39;meta+c&#39;, &#39;ctrl+c&#39;], () &#x3D;&gt; &#123;\n    const cells &#x3D; graph.getSelectedCells();\n    if (cells.length) &#123;\n    \tgraph.copy(cells);\n    &#125;\n\treturn false;\n&#125;);\ngraph.bindKey([&#39;meta+x&#39;, &#39;ctrl+x&#39;], () &#x3D;&gt; &#123;\n    const cells &#x3D; graph.getSelectedCells();\n    if (cells.length) &#123;\n    \tgraph.cut(cells);\n\t&#125;\n\treturn false;\n&#125;);\ngraph.bindKey([&#39;meta+v&#39;, &#39;ctrl+v&#39;], () &#x3D;&gt; &#123;\n    if (!graph.isClipboardEmpty()) &#123;\n        const cells &#x3D; graph.paste(&#123; offset: 32 &#125;);\n        graph.cleanSelection();\n        graph.select(cells);\n    &#125;\n    return false;\n&#125;);\n&#x2F;&#x2F; 控制连接桩显示&#x2F;隐藏\nvar showPorts &#x3D; function (ports, show) &#123;\n    for (var i &#x3D; 0, len &#x3D; ports.length; i &lt; len; i &#x3D; i + 1) &#123;\n    \tports[i].style.visibility &#x3D; show ? &#39;visible&#39; : &#39;hidden&#39;;\n    &#125;\n&#125;;\n&#x2F;&#x2F; 触摸\ngraph.on(&#39;node:mouseenter&#39;, (&#123; node &#125;) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 显示节点删除按钮\n    node.addTools(&#123;\n        name: &#39;button-remove&#39;,\n        args: &#123;\n            x: &#39;100%&#39;,\n            y: 0,\n            offset: &#123; x: -10, y: 10 &#125;,\n        &#125;,\n\t&#125;);\n    var container &#x3D; this.$refs.graph;\n    var ports &#x3D; container.querySelectorAll(&#39;.x6-port-body&#39;);\n    showPorts(ports, true);\n&#125;);\ngraph.on(&#39;node:mouseleave&#39;, (&#123; node &#125;) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 移除节点删除按钮\n    node.removeTools();\n    var container &#x3D; this.$refs.graph;\n    var ports &#x3D; container.querySelectorAll(&#39;.x6-port-body&#39;);\n    showPorts(ports, false);\n&#125;);\n&#x2F;&#x2F; 文字输入\ngraph.on(&#39;cell:dblclick&#39;, (&#123; cell, e &#125;) &#x3D;&gt; &#123;\n    const isNode &#x3D; cell.isNode();\n    const name &#x3D; cell.isNode() ? &#39;node-editor&#39; : &#39;edge-editor&#39;;\n    cell.removeTool(name);\n    cell.addTools(&#123;\n        name,\n        args: &#123;\n            event: e,\n            attrs: &#123;\n                backgroundColor: isNode ? &#39;#EFF4FF&#39; : &#39;#FFF&#39;,\n                fontSize: 18,\n            &#125;,\n        &#125;,\n    &#125;);\n&#125;);   \n复制代码\n\n\n","slug":"Antv X6 绘制拖拽流程图","date":"2021-10-20T09:21:06.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"15b860383ab68e267beb31ba2d0c1dea","title":"React Hooks的学习笔记","content":"Hooks的起步使用其实Hooks主要常用的可以有以下几个：\n\nuseState\nuseEffect\nuseContext\nuseMemo\nuseRef\nuseReducer\nuseCallback\n\n列举的以上这几个，其实已经算是比较常用的，尤其是前两个，接下来就会介绍它们部分几个的使用。\nuseStateuseState这个钩子其实对应的是我们之前class Component里的this.setState。\n\nuseState传参代表默认值，可以是原始值，也可以是对象、数组，所以其实表达能力很丰富。\nuseState调用后返回是一对值，对应当前的值和更新这个值的函数，用数组解构的方式获取很简洁。\nuseState在一个函数组件里可以多次使用。\nuseState和this.setState区别之处在于，前者每次更新后state都是新值，换而言之其实是不可变数据的概念。而后者使用后，其实更新state部分的值，引用本身并无改变。\n\n简单使用如下示例。\nimport React, &#123; useState &#125; from &#39;react&#39;;\n\nexport default function StateHook() &#123;\n  const [count, useCount] &#x3D; useState(0);\n  return (\n    &lt;&gt;\n      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; useCount(count + 1)&#125;&gt;Click me&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码\n\nuseEffectuseEffect这个钩子势必是我们常用的。\n\n它基本可以等价于componentDidMount和componentDidUpdate的这两个生命周期钩子组合的效果。那么它的调用时机大概是每次渲染结束后，所以不会阻塞组件渲染。\nuseEffect一般用于实现设置数据请求、监听器等有副作用的功能，传入的第一个参数函数A1用于设置副作用，而是传入的这个函数可以返回一个函数A2用于取消函数A1的副作用。这两个函数的React调用它们时机分别在于，注册副作用的函数A1在当次渲染结束后立即执行，取消副作用的函数A2在下次渲染开始之前立即执行。再次强调，这么设计的理由还是为了不阻塞组件渲染。\nuseEffect第二个参数用于设置副作用的依赖数组。什么意思？思维灵活的同学已经想到了，如果每次渲染都执行副作用，有可能造成性能浪费，那么可以通过告诉React，这个钩子依赖某些props或者states，在这些依赖不发生改变时，这个副作用不会再重复执行。在以下的例子中，可以传空数组，告诉React该副作用什么也不依赖，那么它只会在第一次渲染时执行一次（但是一般不推荐这么做）。如果不传第二个参数，则意味着每次渲染都必然执行一次，此时应当注意内存泄露。\n同学们有没有发现，使用useEffect后，一个副作用的注册监听与对应的取消注册逻辑全部放在了一起，对比与以往的分别在componentDidMount、componentDidUpdate、componentWillUnmount里分散同一副作用的逻辑。useEffect的使用更有吸引力和说服力了。\n\nimport React, &#123; useState, useEffect &#125; from &#39;react&#39;;\n\nexport default function EffectHook(&#123; dep &#125;) &#123;\n  const [width, setWidth] &#x3D; useState(window.innerWidth);\n  \n  function handleWindowResize() &#123;\n    const w &#x3D; window.innerWidth;\n    setWidth(w);\n  &#125;\n  \n  useEffect(() &#x3D;&gt; &#123;\n    window.addEventListener(&#39;resize&#39;, handleWindowResize);\n    return () &#x3D;&gt; &#123;\n      window.removeEventListener(&#39;resize&#39;, handleWindowResize);\n    &#125;;\n  &#125;, \n    &#x2F;&#x2F; deps\n    []\n  );\n\n  return (\n    &lt;&gt;\n      &lt;p&gt;window.innerWidth: &#123;width&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码\n\nuseContext这个钩子还是和原有的Context.Provider、Context.Consumer一样的理解即可。用法示例如下，理解方便，不再赘述。\nimport React, &#123; useContext &#125; from &#39;react&#39;;\n\nexport const souliz &#x3D; &#123;\n  name: &#39;souliz&#39;,\n  description: &#39;A normal human named by his cat.&#39;\n&#125;;\n\nexport const UserContext &#x3D; React.createContext(souliz);\n\nexport default function ContextHook() &#123;\n  const context &#x3D; useContext(UserContext);\n\n  return (\n    &lt;&gt;\n      &lt;p&gt;UserContext name: &#123;context.name&#125;&lt;&#x2F;p&gt;\n      &lt;p&gt;UserContext description: &#123;context.description&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码\n\nuseMemo有时候我们会遇到一个极耗性能的函数方法，但由于依赖了函数组件里一些状态值，又不得不放在其中。那么如果我们每次渲染都去重复调用的发，组件的渲染必然会十分卡顿。\n因此写了以下示例验证，一个计算斐波那契的函数（众所周知的慢），读者可以拷贝这段代码，注释useMemo那一行，使用直接计算来看，点击按钮触发组件重新渲染，会发现很卡顿（当然了），那么此时useMemo作用就发挥出来了，其实理解上还是和原有的React.memo一样，可用于缓存一下计算缓慢的函数，如果依赖没有发生改变，则重复使用旧值。前提必然是这个函数是一个纯函数，否则必然会引发问题。\n（useCallback其实也和useMemo道理类似，不过它解决的问题其实如果依赖不改变，使用旧的函数引用，在useEffect的依赖是函数时，可以使用useCallback的特性来避免重复触发副作用的发生，因此不再赘述useCallback）\nimport React, &#123; useState, useMemo &#125; from &#39;react&#39;;\n\nlet fib &#x3D; n &#x3D;&gt; (n &gt; 1 ? fib(n - 1) + fib(n - 2) : n);\nlet renders &#x3D; 0;\n\nexport default function MemoHook() &#123;\n  const defaultInput &#x3D; 37;\n  const [input, setInput] &#x3D; useState(defaultInput);\n  const [time, setTime] &#x3D; useState(0);\n  const value &#x3D; useMemo(() &#x3D;&gt; fib(input), [input]);\n  &#x2F;&#x2F; 来来来，看看不使用Memo的后果就是卡顿\n  &#x2F;&#x2F; const value &#x3D; fib(input);\n\n  return (\n    &lt;&gt;\n      &lt;p&gt;fib value is &#123;value&#125;&lt;&#x2F;p&gt;\n      &lt;input\n        type&#x3D;&quot;number&quot;\n        value&#x3D;&#123;input&#125;\n        onChange&#x3D;&#123;e &#x3D;&gt; setInput(e.target.value)&#125;\n      &#x2F;&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setTime(time + 1)&#125;&gt;Trigger render &#123;time&#125;&lt;&#x2F;button&gt;\n      &lt;footer&gt;render times: &#123;renders++&#125;&lt;&#x2F;footer&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码\n\nuseRefuseRef这个钩子需要更通用的理解方式，不同于我们之前使用的React.createRef()，这个钩子用于创建的是一个引用对象，那么可以用于突破useState所带来的局限。什么意思呢？useState每次渲染都是新的值，也就是下面示例中，如果我点击3次按钮，分别更新了值触发5次组件重新渲染，那么通过延时5秒后获取current值如示例二，如果需要在某些操作中获取组件最新的某些state是最新的值的时候，useRef可以派上大用场。\nimport React, &#123; useRef, useEffect, useState &#125; from &#39;react&#39;;\n\nexport default function RefHook() &#123;\n  const [count, setCount] &#x3D; useState(0);\n  const latestCount &#x3D; useRef(count);\n\n  latestCount.current &#x3D; count;\n  useEffect(() &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(&#96;Ref: You clicked $&#123;latestCount.current&#125; times&#96;);\n      console.log(&#96;state: You clicked $&#123;count&#125; times&#96;);\n    &#125;, 5000);\n  &#125;);\n\n  return (\n    &lt;&gt;\n      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;Click me&lt;&#x2F;button&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码\n\nRef: You clicked 3 times\nstate: You clicked 1 times\nRef: You clicked 3 times\nstate: You clicked 2 times\nRef: You clicked 3 times\nstate: You clicked 3 times\n复制代码\n\nuseReducer相信同学们都使用过redux，React Team考虑到这种使用方式常见，于是设计出来了这么一个钩子。这样的话其实解决了我们常见写redux的多文件跳跃编写的烦恼，而且十分易于理解。（当然还有比较高级的用法）。以下代码示例。\nimport React, &#123; useState, useReducer &#125; from &#39;react&#39;;\n\nconst defaultTodos &#x3D; [\n  &#123;\n    id: 1,\n    text: &#39;Todo 1&#39;,\n    completed: false\n  &#125;,\n  &#123;\n    id: 2,\n    text: &#39;Todo 2&#39;,\n    completed: false\n  &#125;\n];\n\nfunction todosReducer(state, action) &#123;\n  switch (action.type) &#123;\n    case &#39;add&#39;:\n      return [\n        ...state,\n        &#123;\n          id:  Date.now(),\n          text: action.text,\n          completed: false\n        &#125;\n      ];\n    case &#39;complete&#39;:\n      return state.map(todo &#x3D;&gt; &#123;\n        if (todo.id &#x3D;&#x3D;&#x3D; action.id) &#123;\n          todo.completed &#x3D; true;\n        &#125;\n        return todo;\n      &#125;);\n    default:\n      return state;\n  &#125;\n&#125;\n\nexport default function ReducerHook() &#123;\n  const [todos, dispatch] &#x3D; useReducer(todosReducer, defaultTodos);\n  const [value, setValue] &#x3D; useState(&#39;&#39;);\n\n  function handleTextChange(e) &#123;\n    setValue(e.target.value);\n  &#125;\n\n  function handleAddTodo() &#123;\n    if (value &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;\n      return;\n    &#125;\n    dispatch(&#123;\n      type: &#39;add&#39;,\n      text: value\n    &#125;);\n    setValue(&#39;&#39;);\n  &#125;\n\n  function handleCompleteTodo(id) &#123;\n    dispatch(&#123;\n      type: &#39;complete&#39;,\n      id\n    &#125;);\n  &#125;\n\n  return (\n    &lt;&gt;\n      &lt;section&gt;\n        &lt;input\n          type&#x3D;&quot;text&quot;\n          onChange&#x3D;&#123;handleTextChange&#125;\n          value&#x3D;&#123;value&#125;\n        &#x2F;&gt;\n        &lt;button onClick&#x3D;&#123;handleAddTodo&#125;&gt;Add Todo&lt;&#x2F;button&gt;\n      &lt;&#x2F;section&gt;\n      &lt;ul className&#x3D;&quot;todos&quot;&gt;\n        &#123;todos.map(todo &#x3D;&gt; (\n          &lt;ol id&#x3D;&#123;todo.id&#125; key&#x3D;&#123;todo.id&#125;&gt;\n            &lt;span\n              style&#x3D;&#123;&#123;\n                textDecoration: todo.completed ? &#39;line-through&#39; : &#39;none&#39;\n              &#125;&#125;\n            &gt;\n              &#123;todo.text&#125;\n            &lt;&#x2F;span&gt;\n            &lt;input\n              type&#x3D;&quot;checkbox&quot;\n              disabled&#x3D;&#123;todo.completed&#125;\n              onClick&#x3D;&#123;() &#x3D;&gt; handleCompleteTodo(todo.id)&#125;\n            &#x2F;&gt;\n          &lt;&#x2F;ol&gt;\n        ))&#125;\n      &lt;&#x2F;ul&gt;\n    &lt;&#x2F;&gt;\n  );\n&#125;\n复制代码\n\n其实useReducer的原理大概也可以这么来实现。\nfunction useReducer(reducer, initialState) &#123;\n  const [state, setState] &#x3D; useState(initialState);\n\n  function dispatch(action) &#123;\n    const nextState &#x3D; reducer(state, action);\n    setState(nextState);\n  &#125;\n\n  return [state, dispatch];\n&#125;\n复制代码\n\n相信学完这些Hooks的使用后，许多同学都是内心充满了很多疑惑的同时也想要尝试看看怎么使用到实际项目了。\n当然现在React官方的建议是：\n\n可以小规模的使用了，但是无需重写以前的组件实现。React是不会移除class Component这些原有API的。\n如果决定使用Hooks的话，可以加上React提供的eslint-plugin-react-hooks，用于检测对于Hooks的不正当使用。（听说create-react-app很快将会加上这个配置）\n学习与使用React Hooks其实更需要的是换一种心智模型去理解，Hooks更多的像是一个同步处理数据的过程。\n\nHooks存在的意义以及原因？传统组件的开发有以下几个局限：\n\n难以复用含有state（状态）的组件逻辑。HOC、render props这两种做法虽然可以解决，但是一是需要重新架构组件，可能会使代码更复杂。二是可能会造成wrapper hell。\n复杂组件难以理解消化。因为状态逻辑、消息订阅、请求、以及副作用在不同的生命钩子混乱穿插，彼此耦合，使得一个组件难以再细化拆分。即使使用了Redux这种状态管理的库后，也引进了更高层的抽象，同时需要在不同的文件之间穿插跳跃，复用组件也不是一件容易的事。\nclass让人困惑。（先别急着反对）一个是this让人困惑，常常需要绑定、第二是class转译和压缩出来的代码其实相当冗长。\n\nHooks的注意事项\n只能在函数的顶层使用，不能嵌套于循环体、判断条件等里面。原因是因为需要确保Hooks每次在组件渲染中都是按照同样的顺序，这个十分重要，具体原因将会是一个很大的篇幅\n只能在React函数组件里，或者自定义钩子(custom Hooks)里使用。\n\n","slug":"React Hooks的学习笔记","date":"2021-09-15T12:50:54.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"d7aff688f09321eb25c6942e9ba97bfe","title":"数组转树","content":"前端使用树插件是一个非常常见的使用场景。树插件的数据格式在我使用过的插件都是一样的。 而这个数据格式是由后端组装好返回给前端还是前端自己组装，这个问题在前端和后端也经常拿来撕逼。\n大多数情况下后端会组装好，也有一部分前端自己处理，早之前我合作过的一个后端提出了一个观点， 浏览器是每一个用户都有的，服务器是所有用户共同访问的，后端递归遍历组装树数据比前端处理更耗费性能。\n那时候我居然无言以对，几十条数据组装成树结构的数据居然能牵扯到服务器性能问题，那这个服务器还能做什么？\n也不是想讨论由前端还是后端处理的问题，这种简单的东西，只要商量一下，约定好了，哪一边处理都是可以的。\n现在网上数组转树结构的方法很多，都能够得到想要的结果，今天分享这个方法，我认为应该是性能最优的：\nlet arr &#x3D; [\n  &#123;id: 1, name: &#39;部门1&#39;, pid: 0&#125;,\n  &#123;id: 2, name: &#39;部门2&#39;, pid: 3&#125;,\n  &#123;id: 3, name: &#39;部门3&#39;, pid: 1&#125;,\n  &#123;id: 4, name: &#39;部门3&#39;, pid: 0&#125;,\n  &#123;id: 5, name: &#39;部门4&#39;, pid: 4&#125;,\n  &#123;id: 6, name: &#39;部门5&#39;, pid: 0&#125;,\n  &#123;id: 7, name: &#39;部门5&#39;, pid: 6&#125;,\n  &#123;id: 8, name: &#39;部门5&#39;, pid: 7&#125;,\n]\n\nfunction arrayToTree(data) &#123;\n  let result &#x3D; [];\n  let itemMap &#x3D; &#123;&#125;;\n  for (let i &#x3D; 0; i &lt; data.length; i++) &#123;\n    let item &#x3D; data[i];\n    let id &#x3D; item.id;\n    let pid &#x3D; item.parentResourceId;\n    if(!itemMap[id])&#123;\n      itemMap[id] &#x3D; &#123;\n        children: []\n      &#125;\n    &#125;\n    itemMap[id] &#x3D; &#123;\n      ...item,\n      children: itemMap[id][&#39;children&#39;]\n    &#125;\n    let treeItem &#x3D; itemMap[id];\n    if(pid &#x3D;&#x3D;&#x3D; 0)&#123;\n      result.push(treeItem);\n    &#125;else&#123;\n      if(!itemMap[pid])&#123;\n        itemMap[pid] &#x3D; &#123;\n          children: []\n        &#125;\n      &#125;\n      itemMap[pid][&#39;children&#39;].push(treeItem);\n    &#125;\n  &#125;\n  return result;\n&#125;\nconsole.log(arrayToTree(arr));\n\n得到的结果：\n[    &#123;        &quot;id&quot;: 1,        &quot;name&quot;: &quot;部门1&quot;,        &quot;pid&quot;: 0,        &quot;children&quot;: [            &#123;                &quot;id&quot;: 2,                &quot;name&quot;: &quot;部门2&quot;,                &quot;pid&quot;: 1,                &quot;children&quot;: []\n            &#125;,\n            &#123;\n                &quot;id&quot;: 3,\n                &quot;name&quot;: &quot;部门3&quot;,\n                &quot;pid&quot;: 1,\n                &quot;children&quot;: []\n            &#125;\n        ]\n    &#125;,\n    &#123;\n        &quot;id&quot;: 4,\n        &quot;name&quot;: &quot;部门3&quot;,\n        &quot;pid&quot;: 0,\n        &quot;children&quot;: [\n            &#123;\n                &quot;id&quot;: 5,\n                &quot;name&quot;: &quot;部门4&quot;,\n                &quot;pid&quot;: 4,\n                &quot;children&quot;: []\n            &#125;\n        ]\n    &#125;,\n    &#123;\n        &quot;id&quot;: 6,\n        &quot;name&quot;: &quot;部门5&quot;,\n        &quot;pid&quot;: 0,\n        &quot;children&quot;: [\n            &#123;\n                &quot;id&quot;: 7,\n                &quot;name&quot;: &quot;部门5&quot;,\n                &quot;pid&quot;: 6,\n                &quot;children&quot;: [\n                    &#123;\n                        &quot;id&quot;: 8,\n                        &quot;name&quot;: &quot;部门5&quot;,\n                        &quot;pid&quot;: 7,\n                        &quot;children&quot;: []\n                    &#125;\n                ]\n            &#125;\n        ]\n    &#125;\n]\n\n思路很简单，维护一个json的map，每一个id都有自己的children和本身的数据， 把属于这个id的pid项都存入children数组，因为json的map都是对象，浅拷贝下， 只要是属于这个对象的children数组都会是同一个。可以打印itemMap看看每一个id对应的数据。\n","slug":"数组转树","date":"2021-09-02T13:54:10.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"6bbcc54b583d8f9e999b08536b9ffec3","title":"可能是你需要的 React + TypeScript 50 条规范和经验","content":"1. 注释(1) 文件顶部的注释，包括描述、作者、日期&#x2F;**\n * @description xxxxxx\n * @author chengfeng\n * @since 19&#x2F;05&#x2F;21\n *&#x2F;\n复制代码\n\n(2) 模块的注释&#x2F;**\n * 拷贝数据\n * @param  &#123;*&#125;  data   要拷贝的源数据\n * @param  &#123;boolean&#125; [isDeep&#x3D;false] 是否深拷贝，默认浅拷贝\n * @return &#123;*&#125;         返回拷贝后的数据\n *&#x2F;\n复制代码\n\n(3) 业务代码注释&#x2F;*业务代码注释*&#x2F;\n复制代码\n\n(4) 变量注释interface IState &#123;\n  &#x2F;&#x2F; 名字\n  name: string;\n  &#x2F;&#x2F; 电话\n  phone: number;\n  &#x2F;&#x2F; 地址\n  address: string;\n&#125;\n复制代码\n\n2. 引用组件顺序\n先引用外部组件库,,再引用当前组件块级组件, 然后是 common 里的公共函数库最后是 css 样式\n\nimport * as React from &#39;react&#39;;\nimport &#123; Dropdown, Menu, Icon &#125; from &#39;antd&#39;;\nimport Header from &#39;.&#x2F;Header&#39;;\nimport toast from &#39;common&#x2F;toast&#39;;\nimport &#39;.&#x2F;index.less&#39;;\n复制代码\n\n3. 引号\n使用单引号,或者 es6 的反引号\n\n4. 缩进\n使用两个空格\n\nconst handleCheck &#x3D; () &#x3D;&gt; &#123;\n  onCancel &amp;&amp; onCancel();\n  onClose &amp;&amp; onClose();\n&#125;;\n复制代码\n\n5. 分号\n除了代码块的以外的每个表达式后必须加分号。\n\n6. 括号下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。\n&#x2F;&#x2F; not good\nif (condition) doSomething();\n\n&#x2F;&#x2F; good\nif (condition) &#123;\n  doSomething();\n&#125;\n复制代码\n\n7. 空格\n二元和三元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。\n\n&#x2F;&#x2F; bad\n++ x;\ny ++;\nz &#x3D; x?1:2;\n\n&#x2F;&#x2F; good\n++x;\ny++;\nz &#x3D; x ? 1 : 2;\n复制代码\n\n\n用作代码块起始的左花括号 { 前必须有一个空格。\n\n&#x2F;&#x2F; bad\nif (condition)&#123;\n&#125;\n\nwhile (condition)&#123;\n&#125;\n\nfunction funcName()&#123;\n&#125;\n\n&#x2F;&#x2F; good\nif (condition) &#123;\n&#125;\n\nwhile (condition) &#123;\n&#125;\n\nfunction funcName() &#123;\n&#125;\n\n复制代码\n\n\nif &#x2F; else &#x2F; for &#x2F; while &#x2F; function &#x2F; switch &#x2F; do &#x2F; try &#x2F; catch &#x2F; finally 关键字后，必须有一个空格。\n\n&#x2F;&#x2F; bad\nif(condition) &#123;\n&#125;\n\nwhile(condition) &#123;\n&#125;\n\n(function() &#123;\n&#125;)();\n\n&#x2F;&#x2F; good\nif (condition) &#123;\n&#125;\n\nwhile (condition) &#123;\n&#125;\n\n(function () &#123;\n&#125;)();\n复制代码\n\n\n在对象创建时，属性中的 : 之后必须有空格，: 之前不允许有空格。\n\n&#x2F;&#x2F; bad\nvar obj &#x3D; &#123;\n    a : 1,\n    b:2,\n    c :3\n&#125;;\n\n&#x2F;&#x2F; good\nvar obj &#x3D; &#123;\n    a: 1,\n    b: 2,\n    c: 3\n&#125;;\n复制代码\n\n8. 换行\n每个独立语句结束后必须换行。\n在函数声明、函数表达式、函数调用、对象创建、数组创建、for 语句等场景中，不允许在 , 或 ; 前换行\n\n&#x2F;&#x2F; bad\nvar obj &#x3D; &#123;\n    a: 1\n    , b: 2\n    , c: 3,\n&#125;;\n\nfunction test()\n&#123;\n    ...\n&#125;\nfor (const key in object)\n &#123;\n  if (object.hasOwnProperty(key)) &#123;\n    const element &#x3D; object[key];\n\n  &#125;\n&#125;\n&#x2F;&#x2F; good\nvar obj &#x3D; &#123;\n    a: 1,\n    b: 2,\n    c: 3,\n&#125;;\n\nfunction test() &#123;\n    ...\n&#125;\n\nfor (const key in object) &#123;\n  if (object.hasOwnProperty(key)) &#123;\n    const element &#x3D; object[key];\n\n  &#125;\n&#125;\n复制代码\n\n\n下列关键字后：else, catch, finally 不需要换行\n\n&#x2F;&#x2F; bad\nif (condition) &#123;\n    ...\n&#125;\nelse &#123;\n    ...\n&#125;\n\ntry &#123;\n    ...\n&#125;\ncatch (e) &#123;\n    ...\n&#125;\nfinally &#123;\n    ...\n&#125;\n\n\n&#x2F;&#x2F; good\nif (condition) &#123;\n    ...\n&#125; else &#123;\n    ...\n&#125;\n\ntry &#123;\n    ...\n&#125; catch (e) &#123;\n    ...\n&#125; finally &#123;\n    ...\n&#125;\n复制代码\n\n9. 数组、对象\n对象属性名不需要加引号；\n对象以缩进的形式书写，不要写在一行；\n数组最后不要有逗号。\n对象最后要有逗号。\n\n\n&#x2F;&#x2F; bad\nconst a &#x3D; &#123;\n    &#39;b&#39;: 1\n&#125;;\n\nconst a &#x3D; &#123;b: 1&#125;;\n\nconst a &#x3D; &#123;\n    b: 1,\n    c: 2\n&#125;;\nconst arr &#x3D; [1, 2, 3, 4,];\n\n&#x2F;&#x2F; good\nconst a &#x3D; &#123;\n    b: 1,\n    c: 2,\n&#125;;\n\nconst arr &#x3D; [1, 2, 3, 4];\n复制代码\n\n10. 命名\n类名: 大驼峰式风格，字母和数字，例如：AbcTest。禁止汉字、特殊符号，禁止非大驼峰式风格。\n函数名: 小驼峰式风格，字母和数字，例如：abcTest。禁止汉字、特殊符号，禁止非小驼峰式风格，例如snake_case等。\n变量名: 同函数名。\n常量: 全大写风格，大写字母、数字和下划线，单词之间以下划线分隔，例如：ABC_TEST。禁止汉字、特殊符号、小写字母。\n使用 onXxx 形式作为 props 中用于回调的属性名称。\n\ninterface IProps &#123;\n  onClose?: () &#x3D;&gt; void;\n  onOk?: (item: Record&lt;string, any&gt;) &#x3D;&gt; void;\n&#125;\n复制代码\n\n\n组件内的事件函数使用 handle 开头尾,handleCheckBtn。\n使用 withXxx 形式的词作为高阶组件的名称。\n接口命名前面带上 I 表示 interface\n\ninterface IProps &#123;&#125;\ninterface IState &#123;&#125;\n复制代码\n\n11. 类型断言&#x2F;&#x2F; bad\nfunction getLength(something: string | number): number &#123;\n    return something.length;\n&#125;\n\n&#x2F;&#x2F; index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.\n&#x2F;&#x2F;   Property &#39;length&#39; does not exist on type &#39;number&#39;.\n\n&#x2F;&#x2F; bad \nfunction getLength(something: string | number): number &#123;\n    if ((&lt;string&gt;something).length) &#123;\n        return (&lt;string&gt;something).length;\n    &#125; else &#123;\n        return something.toString().length;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; good\nfunction getLength(something: string | number): number &#123;\n  if (typeof something &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;\n    return something.length;\n  &#125; else &#123;\n    return something.toString().length;\n  &#125;\n&#125;\n\n复制代码\n\n12. interface声明顺序日常用到比较多的是四种，只读参数放第一位，必选参数第二位，可选参数次之，不确定参数放最后\ninterface iProps &#123;\n  readonly x: number;\n  readonly y: number;\n  name: string;\n  age: number;\n  height?: number;\n  [propName: string]: any;\n&#125;\n复制代码\n\n13. ts好用的相关工具泛型\nRecord&lt;string,any&gt; 用这个来声明对象结构的类型\n\n用于定义一个javascript的对象，key是字符串，value是任意类型\nconst people:Record&lt;string,any&gt; &#x3D; &#123;\n    name: &#39;chengfeng&#39;,\n    age: 10\n&#125;\n复制代码\n\n\nPartial 作用是将传入的属性变为可选项.\n\ninterface iPeople &#123;\n    title: string;\n    name: string;\n&#125;\n\nconst people: Partial&lt;iPeople&gt; &#x3D; &#123;\n    title: &#39;Delete inactive users&#39;,\n&#125;;\n定义的结构可以是接口iPeople的任意key\n复制代码\n\n\nReadonly 作用是将传入的属性变为变成只读\n\ninterface iPeople &#123;\n    title: string;\n    name: string;\n&#125;\n\nconst people: Readonly&lt;Todo&gt; &#x3D; &#123;\n    title: &#39;todo list&#39;,\n    name: chenfeng;\n&#125;;\ntitle name属性就是只读的了\n复制代码\n\n\nRequired 的作用是将传入的属性变为必选项\n\ninterface iPeople &#123;\n    title?: string;\n    name?: string;\n&#125;\n\nconst people1: Props &#x3D; &#123; title: &#39;ts&#39; &#125;; &#x2F;&#x2F; OK\n\nconst people22: Required&lt;iPeople&gt; &#x3D; &#123; title: &#39;ts&#39; &#125;; &#x2F;&#x2F; Error: property &#39;name&#39; missing\n复制代码\n\n查看更多\n14. ts一些好用的小tips\nkeyof\n\ninterface iPeople &#123;\n  name: string;\n  age: number\n&#125;\n\ntype T &#x3D; keyof iPeople &#x2F;&#x2F; -&gt; &quot;name&quot; | &quot;age&quot;\n复制代码\n\n\nin\n\ntype Keys &#x3D; &quot;a&quot; | &quot;b&quot;\ntype Obj &#x3D;  &#123;\n  [p in Keys]: any\n&#125; &#x2F;&#x2F; -&gt; &#123; a: any, b: any &#125;\n复制代码\n\n15. 规范其他\n不要使用 var 声明变量\n不会被修改的变量使用 const 声明\n去除声明但未被引用的代码\n禁止在代码里使用 debug\n不允许有空的代码块\n\n16. 仅当初始 state 需要从 props 计算得到的时候，才将 state 的声明放在构造函数中，其它情况下使用静态属性声明 state,并且一般情况下不要将 prop 传给 state&#x2F;&#x2F; bad\nconstructor ()&#123;\n  this.setState(&#123; people: this.props.people &#125;)\n&#125;\n\n&#x2F;&#x2F; good\nstate: IState &#x3D; &#123;\n  people: &#123;&#125;,\n&#125;;\n复制代码\n\n17. 渲染默认值\n添加非空判断可以提高代码的稳健性,例如后端返回的一些值,可能会出现不存在的情况，应该要给默认值.\n\n&#x2F;&#x2F; bad\nrender()&#123;\n  &#123;name&#125;\n&#125;\n\n&#x2F;&#x2F; good\nrender()&#123;\n  &#123;!!name || &#39;--&#39;&#125;\n&#125;\n\n\n复制代码\n\n\n还有一种情况，就是本来后端应该返回一个数组给你，但是数据库取不到数据，可能后端给你返回了null,然后前端null.length。这样就gg了\n\n&#x2F;&#x2F; bad\nconst &#123; list, totalCount &#125; &#x3D; await getPeopleList(keyword, page, pageSize);\nlist 可能是null或者undefined\nlist.length将直接导致前端报错\n\nthis.setState(&#123;\n  status: STATUS.READY,\n  apps: list,\n  total: totalCount,\n  page: page,\n&#125;);\n\n\n&#x2F;&#x2F; good \nconst &#123; list, totalCount &#125; &#x3D; await getPeopleList(keyword, page, pageSize);\nthis.setState(&#123;\n  status: STATUS.READY,\n  apps: list || [],\n  total: totalCount || 0,\n  page: page,\n&#125;);\n\n复制代码\n\n18. 不确定的属性，最后却疯狂的用…访问不存在的属性例如一些地方，不确定这个变量里面到底有什么，但自己觉得有，就疯狂的…,最明显的就是后端返回了一个对象给你，前端拿到之后判断都不判断直接data.dataList.forEach()\n&#x2F;&#x2F; bad\nconst data &#x3D; await getPeopleList(keyword, page, pageSize);\ndata.dataList.forEach() &#x2F;&#x2F; 直接挂了\n\n&#x2F;&#x2F; good\nconst data &#x3D; await getPeopleList(keyword, page, pageSize);\nif (data &amp;&amp; data.dataList &amp;&amp; Array.isArray(data.dataList) &#123;\n    data.dataList.forEach() \n&#125;\n复制代码\n\n19. 数据格式转换\n把字符串转整型可以使用+号\n\nlet maxPrice &#x3D; +form.maxPrice.value;\nlet maxPrice &#x3D; Number(form.maxPrice.value);\n复制代码\n\n\n转成 boolean 值用!!\n\nlet mobile &#x3D; !!ua.match(&#x2F;iPhone|iPad|Android|iPod|Windows Phone&#x2F;);\n复制代码\n\n20. 判断条件真假js 中以下为假,其他情况为真\n\nfalse\nnull\nundefined\n0\n‘’ (空字符串)\nNaN\n\n21. 简单组件可以使用函数代替&#x2F;&#x2F; bad\nclass Listing extends React.Component &#123;\n  render() &#123;\n    return &lt;div&gt;&#123;this.props.hello&#125;&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; good\nfunction Listing(&#123; hello &#125;) &#123;\n  return &lt;div&gt;&#123;hello&#125;&lt;&#x2F;div&gt;;\n&#125;\n复制代码\n\n22. 对于常用的属性进行缓存&#x2F;&#x2F; bad\nthis.props.app.openid;\nthis.state.time\n\n&#x2F;&#x2F; good\nconst &#123; app &#125; &#x3D; this.props;\nconst &#123; time &#125; &#x3D; this.state;\nconsole.log(app.openid)\n复制代码\n\n23. input 输入框使用 trim()&#x2F;&#x2F; bad\nlet searchContent &#x3D; form.search.value;\n\n&#x2F;&#x2F; good\nlet searchContent &#x3D; form.search.value.trim();\n复制代码\n\n24. 使用 location 跳转前需要先转义&#x2F;&#x2F; bad\nwindow.location.href &#x3D; redirectUrl + &#39;?a&#x3D;10&amp;b&#x3D;20&#39;;\n\n&#x2F;&#x2F; good\nwindow.location.href &#x3D; redirectUrl + encodeURIComponent(&#39;?a&#x3D;10&amp;b&#x3D;20&#39;);\n复制代码\n\n25. 使用 react-router\n&#x2F;&#x2F; bad\nimport &#123; withRouter, RouteComponentProps &#125; from &#39;react-router-dom&#39;;\n\nexport interface IProps extends RouteComponentProps&lt;any&gt; &#123;&#125;\nclass App extends React.Component&lt;IProps, AppStates&gt; &#123;&#125;\nexport default withRouter(App);\n\n\n&#x2F;&#x2F; good\nimport &#123; withRouter, RouteComponentProps &#125; from &#39;react-router-dom&#39;;\n\nclass App extends React.Component&lt;IProps &amp; RouteComponentProps&lt;&#123;&#125;&gt;, AppStates&gt; &#123;&#125;\nexport default withRouter(App);\n\n复制代码\n\n26. 同时开发，数据请求 api 目录 git 冲突目录方案\n在 api 目录下新建一个目录，目录对应一级 tab,这个目录内放置一个 index.js ，最后把二级 tab 组件所使用的 api 请求都在这个 index.js 内引入。\n\n&#x2F;&#x2F; 目前\n\n|- api\n  |- pageA.ts\n  |- pageB.ts\n\n&#x2F;&#x2F; 建议\n\n|- api\n  |- pageA\n    |- index.js\n    |- aaa.js\n    |- bbb.js\n  |- pageB\n    |- index.js\n    |- aaa.js\n    |- bbb.js\n    |- ccc.js\n复制代码\n\n27. 组件嵌套过深\n组件一般不要超过三层,最多四层,层级过深可能会导致数据传递过深，在做一些颗粒度比较细的操作的时候，处理起来较为繁琐，可以使用 redux 等状态管理工具替代。\n\n28. 代码过滤掉你没考虑到的情况\n例如一个函数，你只想操作字符串，那你必须在函数开头就只允许参数是字符串\n\nfunction parse (str:string)&#123;\n  if (typeof(str) &#x3D;&#x3D;&#x3D; &#39;string&#39; ) &#123;\n\n  &#125;\n&#125;\n复制代码\n\n29. 业务代码里面的异步请求需要 try catch\najax 请求，使用 try catch，错误提示后端返回,并且做一些失败后的状态操作例如进入列表页，我们需要一个 loading 状态，然后去请求数据,可是失败之后，也需要把 loading 状态去掉,把 loading 隐藏的代码就写在 finally 里面。\n\ngetStudentList &#x3D; async () &#x3D;&gt; &#123;\n  try &#123;\n    this.setState(&#123;\n      loading: true,\n      isEmpty: false\n    &#125;);\n    await getStudentList(&#123;&#125;);\n  &#125; catch (e) &#123;\n    &#x2F;&#x2F; TODO\n    console.log(e)\n  &#125; finally &#123;\n    &#x2F;&#x2F;  失败之后的一些兜底操作\n    this.setState(&#123;\n      loading: false,\n      isEmpty: true\n    &#125;);\n  &#125;\n&#125;;\n复制代码\n\n30. setState有三种用法&#x2F;&#x2F; 对象\nthis.setState(&#123;\n\n&#125;)\n\n&#x2F;&#x2F; 函数，一般是用于在setState之前做一些操作\nthis.setState(\n  () &#x3D;&gt; &#123;\n    &#x2F;&#x2F; TODO\n    console.log(&#39;&#39;)\n    return &#123;\n      a:300\n    &#125;\n  &#125;\n)\n\n&#x2F;&#x2F; 第二个参数，一般是用于在setState之后做一些操作\nthis.setState(&#123;\n  a:300\n&#125;, () &#x3D;&gt; &#123;\n  &#x2F;&#x2F; TODO\n&#125;)\n复制代码\n\n31. setState可能是同步的\nsetState 在react里的合成事件和钩子函数中是“异步”的。\nsetState 在原生事件和 setTimeout 中是同步的。\n\n32. 不要在 setState 前面加 await\nsetState 前面也是可以带 await 的，会变成同步设置状态,但这是一种巧合，不确定未来哪个版本就不支持了，为了遵循 react 框架的设计原则，我们使用回掉函数的形式。\n\n&#x2F;&#x2F; bad\nfunc &#x3D; async (name, value, status) &#x3D;&gt; &#123;\n  await this.setState(&#123;\n    name\n  &#125;);\n  &#x2F;&#x2F; TODO\n&#125;;\n\n&#x2F;&#x2F; good\nfunc &#x3D; (name, value, status) &#x3D;&gt; &#123;\n  this.setState(\n    &#123;\n      name\n    &#125;,\n    () &#x3D;&gt; &#123;\n      &#x2F;&#x2F; TODO\n    &#125;\n  );\n&#125;;\n复制代码\n\n33. 阻止事件默认行为\n在 React 中你不能通过返回 false 来阻止默认行为。必须明确调用 preventDefault 。\n\n34. 在 componentWillUnmount 里面去除副作用的函数\n清除 EventListener\n中止数据请求\n清除定时器\n\n35. key\n对于组件中的 key 优化，起到最大化重用 dom\n\n&#x2F;&#x2F;bad\nthis.state.dataAry.map((item, index) &#x3D;&gt; &#123;\n  return &lt;span key&#x3D;&#123;index&#125; &#x2F;&gt;;\n&#125;);\n\n&#x2F;&#x2F;good\nthis.state.dataAry.map(item &#x3D;&gt; &lt;span key&#x3D;&#123;item.id&#125; &#x2F;&gt;);\n复制代码\n\n36. for-in 中一定要有 hasOwnProperty 的判断（即禁止直接读取原型对象的属性）&#x2F;&#x2F;bad\nconst arr &#x3D; [];\nconst key &#x3D; &#39;&#39;;\n\nfor (key in obj) &#123;\n  arr.push(obj[key]);\n&#125;\n\n&#x2F;&#x2F;good\nconst arr &#x3D; [];\nconst key &#x3D; &#39;&#39;;\n\nfor (key in obj) &#123;\n  if (obj.hasOwnProperty(key)) &#123;\n    arr.push(obj[key]);\n  &#125;\n&#125;\n\n复制代码\n\n37. 第三方库函数的使用\n用 try catch 包裹，防止第三方库的出现错误，导致整个程序崩溃\n\n&#x2F;*\n * Echart 用于代绘制图表，但当其自身发生错误时，可能影响到业务代码的执行\n *&#x2F;\n&#x2F;&#x2F; bad\nconst iniDom &#x3D; document.getElementById(&#39;init-container&#39;);\nconst echartObj &#x3D; echarts.init(iniDom);\nthis.setState(\n  &#123;\n    echartObj\n  &#125;,\n  () &#x3D;&gt; &#123;\n    const &#123; echartObj &#125; &#x3D; this.state;\n    &#x2F;&#x2F; 更新图表\n    echartObj.setOption(CHART_CONFIG, true);\n  &#125;\n);\n\n&#x2F;&#x2F; good\ntry &#123;\n  const iniDom &#x3D; document.getElementById(&#39;init-container&#39;);\n  const echartObj &#x3D; echarts.init(iniDom);\n  this.setState(\n    &#123;\n      echartObj\n    &#125;,\n    () &#x3D;&gt; &#123;\n      const &#123; echartObj &#125; &#x3D; this.state;\n      &#x2F;&#x2F; 更新图表\n      echartObj.setOption(CHART_CONFIG, true);\n    &#125;\n  );\n&#125; catch (error) &#123;\n  &#x2F;&#x2F; TODO\n&#125;\n复制代码\n\n38. 防止 xss 攻击\ninput，textarea 等标签，不要直接把 html 文本直接渲染在页面上,使用 xssb 等过滤之后再输出到标签上;\n\nimport &#123; html2text &#125; from &#39;xss&#39;;\nrender()&#123;\n  &lt;div\n  dangerouslySetInnerHTML&#x3D;&#123;&#123;\n    __html: html2text(htmlContent)\n  &#125;&#125;\n&#x2F;&gt;\n&#125;\n复制代码\n\n39. 在组件中获取真实 dom\n使用 16 版本后的 createRef()函数\n\nclass MyComponent extends React.Component&lt;iProps, iState&gt; &#123;\n  constructor(props) &#123;\n    super(props);\n    this.inputRef &#x3D; React.createRef();\n  &#125;\n\n  render() &#123;\n    return &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;this.inputRef&#125; &#x2F;&gt;;\n  &#125;\n\n  componentDidMount() &#123;\n    this.inputRef.current.focus();\n  &#125;\n&#125;\n复制代码\n\n40. 减少魔法数字\n写代码的时候尽量减少一些未知含义的数字，尽量用英文单词。例如type &#x3D;&#x3D;&#x3D; 0的时候做了一些操作，让人不知所以然。\n\n&#x2F;&#x2F; bad\nif (type !&#x3D;&#x3D; 0) &#123;\n  &#x2F;&#x2F; TODO\n&#125;\n\n&#x2F;&#x2F; good\nconst STATUS: Record&lt;string, any&gt; &#x3D; &#123;\n  READY: 0,\n  FETCHING: 1,\n  FAILED: 2\n&#125;;\n\nif (type &#x3D;&#x3D;&#x3D; STATUS.READY) &#123;\n  &#x2F;&#x2F; TODO\n&#125;\n\n&#x2F;&#x2F; best\nenum STATUS &#123;\n  &#x2F;&#x2F; 就绪\n  READY &#x3D; 0,\n  &#x2F;&#x2F; 请求中\n  FETCHING &#x3D; 1,\n  &#x2F;&#x2F; 请求失败\n  FAILED &#x3D; 2,\n&#125;\n\n复制代码\n\n41. 如果需要优化 react 性能（一般用不到）\n如果组件的 state 和 props 都是简单类型，可以继承 PureComponent 而不是 Component\n\nimport &#123; Component, PureComponent &#125; from &#39;react&#39;;\n&#x2F;&#x2F; bad\nclass Message extends Component &#123;\n  render() &#123;\n    return &lt;span&gt;&#123;this.state.message&#125;&lt;&#x2F;span&gt;;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; good\nclass Message extends PureComponent &#123;\n  render() &#123;\n    return &lt;span&gt;&#123;this.state.message&#125;&lt;&#x2F;span&gt;;\n  &#125;\n&#125;\n复制代码\n\n\n重写 shouldComponentUpdate 方法,在 shouldComponentUpdate 里面根据 state,props 是否有改变来判断是否需要重新渲染.如果组件继承了 PureComponent 就没必要再重写 shouldComponentUpdate 方法\n\nimport &#123; isReactPropsEqual, isReactStateEqual &#125; from &#39;@fe&#x2F;common&#x2F;lib&#x2F;equal&#39;;\nshouldComponentUpdate(nextProps:IProps, nextState:IState) &#123;\n    if (isReactStateEqual(nextState,this.state) &amp;&amp; isReactPropsEqual(nextProps,this.props)) &#123;\n        return false;\n    &#125;\n    return true;\n&#125;\n复制代码\n\n42. Event 事件对象类型很多小伙伴用了很久的ts,都不知道常用 Event 事件对象类型：\nClipboardEvent&lt;T &#x3D; Element&gt; 剪贴板事件对象\nDragEvent&lt;T &#x3D; Element&gt; 拖拽事件对象\nChangeEvent&lt;T &#x3D; Element&gt; Change 事件对象\nKeyboardEvent&lt;T &#x3D; Element&gt; 键盘事件对象\nMouseEvent&lt;T &#x3D; Element&gt; 鼠标事件对象\nTouchEvent&lt;T &#x3D; Element&gt; 触摸事件对象\nWheelEvent&lt;T &#x3D; Element&gt; 滚轮事件对象\nAnimationEvent&lt;T &#x3D; Element&gt; 动画事件对象\nTransitionEvent&lt;T &#x3D; Element&gt; 过渡事件对象\nimport &#123; MouseEvent &#125; from &#39;react&#39;;\n\ninterface IProps &#123;\n  onClick(event: MouseEvent&lt;HTMLDivElement&gt;): void;\n&#125;\n复制代码\n\n43. 使用私有属性取代state状态对于一些不需要控制ui的状态属性，我们可以直接绑到this上， 即私有属性，没有必要弄到this.state上，不然会触发渲染机制，造成性能浪费 例如请求翻页数据的时候,我们都会有个变量。\n&#x2F;&#x2F; bad\nstate: IState &#x3D; &#123;\n  pageNo:1,\n  pageSize:10\n&#125;;\n\n&#x2F;&#x2F; good \nqueryParams:Record&lt;string,any&gt; &#x3D; &#123;\n  pageNo:1,\n  pageSize:10\n&#125;\n复制代码\n\n44. 代码细粒度的思考总结四句话。我们在写组件或者函数的的时候，工具函数和业务逻辑抽离，表单校验和业务抽离、事件函数和业务抽离，ajax和业务抽离。 例如有些页面是通过location.href跳转的，我们有些业务逻辑等都是放到didmountMount,但是后期改需求，可能要用react-router进行跳转，可能要改的逻辑就会很多了，所以函数抽离出来，需求更新就少改一点代码。 如果还不确定如何划分函数的细粒度，我有个建议。使用过两次以上的代码，要抽离组件或者函数，两次的可以不用\n45. if else 等判断太多了，后期难以维护。个人觉得if else 嵌套深看起来也不会太难受，难受的是，项目迭代久之后，自己都忘记曾经写过这些代码，而且类型多或者不确定有什么类型，是否后期还会加的情况下，改起来就非常复杂了，而且很容易踩坑和背锅。 用配置取代if嵌套，大概就是抽离一个config.ts出来，里面放一些配置。\n例如你的业务代码里面，会根据不同url参数，代码会执行不同的逻辑.\n&#x2F;info?type&#x3D;wechat&amp;uid&#x3D;123456&amp;\nconst qsObj &#x3D; qs(window.location.url)\nconst urlType &#x3D; qsObj.type\n&#x2F;&#x2F; bad \nif (urlType &#x3D;&#x3D;&#x3D; &#39;wechat&#39;) &#123;\n    doSomeThing()\n&#125; else if () &#123;\n    doSomeThing()\n&#125; else if () &#123;\n    doSomeThing()\n&#125; else if () &#123;\n    doSomeThing()\n&#125;\n\n&#x2F;&#x2F; good \nconfig.t\nconst urlTypeConfig: Record&lt;string, typeItem&gt; &#x3D; &#123;\n  &#39;wechat&#39;: &#123; &#x2F;&#x2F; key 就是对应的type\n    name: &#39;wechat&#39;, \n    show: [&#39;header&#39;, &#39;footer&#39;, &#39;wechat&#39;] &#x2F;&#x2F; 展示什么，可能是异步的\n    pession: [&#39;admin&#39;], &#x2F;&#x2F; 权限是什么，可能是异步的\n  &#125;,\n  &#39;zhifubao&#39;: &#123; &#x2F;&#x2F; key 就是对应的type\n    name: &#39;zhifubao&#39;, \n    show: [&#39;header&#39;, &#39;footer&#39;, &#39;zhifubao&#39;] &#x2F;&#x2F; 展示什么，可能是异步的\n    pession: [&#39;admin&#39;], &#x2F;&#x2F; 权限是什么，可能是异步的\n  &#125;,\n&#125;\n\n&#x2F;&#x2F; 业务逻辑\nconst qsObj &#x3D; qs(window.location.url)\nconst urlType &#x3D; qsObj.type\nObject.keys(urlTypeConfig).forEach(item &#x3D;&gt; &#123;\n  if(urlType &#x3D;&#x3D;&#x3D; item.type) &#123;\n    doSomeThing(item.show)\n  &#125;\n&#125;)\n\n复制代码\n\n46. 不要使用renderXXX,要使用函数式组件发现团队一些小伙伴为了减少render函数里面的代码量，会把一些元素拆分到函数里面。\n&#x2F;&#x2F; bad\n  renderHeader &#x3D; () &#x3D;&gt; &#123;\n    return (&lt;div &#x2F;&gt;)\n  &#125;\n  renderBody &#x3D; () &#x3D;&gt; &#123;\n    return (&lt;div &#x2F;&gt;)\n  &#125;\n  renderFooter &#x3D; () &#x3D;&gt; &#123;\n    return (&lt;div &#x2F;&gt;)\n  &#125;\n  render()&#123;\n    return(\n      &lt;div&gt;\n        renderHeader()\n        renderBody()\n        renderFooter()\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n复制代码\n\n更好的办法，是用函数式组件取代在当前组件里面写方法\n&#x2F;&#x2F; good\n function RenderHeader(props) &#x3D;  &#123;\n    return (&lt;div &#x2F;&gt;)\n  &#125;\n function RenderBody(props) &#x3D;  &#123;\n    return (&lt;div &#x2F;&gt;)\n  &#125;\n function RenderFooter(props) &#x3D;  &#123;\n    return (&lt;div &#x2F;&gt;)\n  &#125;\nclass Component extends React.Component&lt;iProps, iState&gt;&#123;  \n  render () &#123;\n    return(\n      &lt;div&gt;\n        &lt;RenderHeader &#x2F;&gt;\n        &lt;RenderBody &#x2F;&gt;\n        &lt;RenderFooter &#x2F;&gt;\n      &lt;&#x2F;div&gt;\n    )\n  &#125;\n&#125;\n复制代码\n\n47. a标签安全问题使用a标签打开一个新窗口过程中的安全问题。新页面中可以使用window.opener来控制原始页面。如果新老页面同域，那么在新页面中可以任意操作原始页面。如果是不同域，新页面中依然可以通过window.opener.location，访问到原始页面的location对象\n在带有target&#x3D;”_blank”的a标签中，加上rel&#x3D;”noopener”属性。如果使用window.open的方式打开页面，将opener对象置为空。\nvar newWindow &#x3D; window.open();\nnewWindow.opener &#x3D; null;\n复制代码\n\n48. void 0 替代undefinedclearSessioin &#x3D; () &#x3D;&gt; &#123;\n\t\n  req.session.userName &#x3D; undefined;\n  \n  req.session.userName &#x3D; void 0\n&#125;\n复制代码\n\n49. 前端不要操作cookie在做一些前后端鉴权的时候，后端应该开启domain,secure,httponly严格模式，禁止前端操作cookie，防止csrf攻击。\n50. 代码检查插件我们可以使用构建工具继承 husky eslint tslint lint-stage prettier来规范代码。\n\neslint-config-prettier\neslint-plugin-prettier\neslint-plugin-react\ntslint-react\ntslint-plugin-prettier\ntslint-config-prettier\n团队开发工作流\n\n作者：乘风gg链接：https://juejin.cn/post/6844903849166110728来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","slug":"可能是你需要的 React + TypeScript 50 条规范和经验","date":"2021-08-08T05:24:16.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"1dcd3b31893419d8e8f3a54468e3f5d8","title":"TypeScript，初次见面","content":"为什么用 TS ?说实话，最开始并没有想把 TS 用到实际项目中来，一来是感觉“类型”会限制 JS 的优势（好吧，就是浪写浪惯了）；二来听闻 TS + Redux 的酸爽滋味，有点望而却步；三来 TS 环境使用的库需要加类型的声明，很多库并不支持，有点担心推进的流畅度 …\n这个时候，就需要有一股无形的力量推你一把。推我的是团队正在日益普及 TS, 我希望推动你的可以是这篇文章 ~\n接下来，会有 React + TS 的项目为背景，介绍我在初学 TS 开发项目中遇到的一些问题，希望对你有所帮助。\n初学者的困惑一. 如何优雅的声明类型\n\n基础\n\n不就是比 JS 多了一个类型声明吗？老夫撸起袖子拎起键盘就是一梭子：\ninterface Basic &#123;\n  num: number;\n  str: string | null;\n  bol?: boolean;\n&#125;\n\n轻轻松松，五种 JS 值类型就声明好了。那数组、函数呢？再来：\ninterface Func &#123;\n  func(str: string): void;\n&#125;\n\ninterface Arr &#123;\n  str: string[];\n  mixed: Array&lt;string | number&gt;;\n  fixedStructure: [string, number];\n  basics: Basic[];\n&#125;\n\n除此之外，竟然还可以定义自己的类型呢，比如常用的回调函数，在声明处需要指定回调函数的类型：\nevent.on(&#39;change&#39;, function() &#123;&#125;);\n\n那这个 on 方法需要如何声明呢？试试看 Function当 cb 函数的类型呢\non(type: string, cb: Function): &#123;&#125;\n\n然后就恭喜了，你会得到一个 tslint error :\n\n庆幸的是，在这个 error 里面它告诉了你应该怎么做：声明一个专用的函数类型就可以了：\ntype Cb &#x3D; () &#x3D;&gt; void;\n\non(type: string, cb: Cb);\n\n至此，我们的 TS 人生算是起步了\n另外，枚举类型也是很常用的，比如声明一个状态机的各个状态：\nenum Status &#123;\n  Draft,\n  Published\n&#125;\n\n&#x2F;&#x2F; 也可指定值\nenum Status &#123;\n  Draft &#x3D; &#39;Draft&#39;,\n  Published &#x3D; &#39;Published&#39;\n&#125;\n\n在使用枚举的时候，常会遇到如何将枚举和原始数据类型相互转换的需求，比如接口请求到的 status 是 Draft 字符串，但是代码中声明的 status 是 Enum 类型，如何转换呢？\n&#x2F;&#x2F; string to enum\nconst str &#x3D; &#39;Draft&#39;;\nconst status: Status &#x3D; Status[str];\n\n&#x2F;&#x2F; enum to string\nStatus[Status.Published] &#x3D;&#x3D;&#x3D; &#39;Published&#39;\n\n2. 糅合\n独立的类型或接口声明看起来似乎并没有那么难，到项目中糅合一下呢？\n\n可能会有几十个类型声明；\n类型声明可能出现在接口入参出参中、React 组件的 Props 和 State 中、函数方法中；\n当项目到达一定规模，可以抽象出独立的库的时候，类型也需要抽象；\n…\n\n你可能遇到各种情况，会打破你对 TS 的掌控。如何是好？\n先说我们实践下来的结论：独立声明、就近声明、按职责分组、杜绝“硬凑”关联、有限抽象。\n- 独立声明\n一个 ts 文件只声明一个类型或者接口，文件名为需要暴露的类型名称，方便检索和管理。\n- 就近声明\n当一个声明没有被外部引用或者依赖时，可以考虑就近放在使用的地方，典型的场景是 React 组件的 Props 和 State 的类型声明。\n- 按职责分组\n在项目中，需要声明类型的可大致分为两类：一类是 model，也就是接口请求相关的，包括入参和出参；另一类是 view，界面渲染相关的。因此，我在 独立声明 的基础上，可以类型按照model 和 view 的维度进行分组，相互独立。\n那么问题来了，如果是独立的类型声明的话，怎么把 model 的数据应用到 view 呢？ 可能你需要一个 adapter 来做类型的的转换：DTOTypes -&gt; adapter -&gt; ViewTypes, 完成类似于将接口中的字符串映射成枚举类型这之类的转换。\n- 杜绝“硬凑”关联\n不要硬凑两个接口或者类型的关系，比如一个接口的创建和更新，可能字段都是一样，区别是一个有 id 另一个没有，于是我们可能就想着写一个类型然后 id 可选就好了。这样是少写了一个类型，但是可能会带来另外一些麻烦，比如带 id 的数据传给了新建的接口，但是 ts 检查不出来。所以，建议不要怕麻烦，直接拆分成 CreateInputDTO 和 UpdateInputDTO.\n- 有限抽象\n在杜绝“硬凑”关联的基础上，我们可以抽象出通用的声明。\n基于上述原则，解决了我作为一个初学者在类型声明上的困扰，如有不对的或者更好的建议，欢迎指正~\n3. 万能药膏 any\n不是所有的类型声明都能一马平川的，当遇到确实解决不了的类型报错的时候，as any 能带给你不一样的快感，但是不建议使用啊…\n二. 如何引用外部库\n接下来聊聊第三方库在 TS 环境下的使用。\n在 JS 中，npm 上有丰富的海量的库帮我们完成日常的编码，可能并不是所有的库都能完全被应用到 TS 中，因为有些缺少类型声明。\n比如，在 TS 中使用 react , 你会得到这样的一个类型检查错误：\n\n因为 react 的库中并没有类型声明。\n现在比较通用的做法是，能力实现和类型实现独立成两个库，也就是你需要再安装类型声明的库: @types/react.\n当遇到上述问题的时候，尝试安装一下 @types/[package].\n然而，并不是所有的库都有类型声明的实现，也会有很多不支持 TS 的存在，然而又必须得使用这个库的时候该怎么办？\n自己写声明！\n以 progressbar.js为例，基本使用方法是：\nimport * as ProgressBar from &#39;progressbar.js&#39;;\n\nnew ProgressBar.Circle(this.$progress, &#123;\n  strokeWidth: 8,\n  trailColor: &#39;#e5e4e5&#39;,\n  trailWidth: 8,\n  easing: &#39;easeInOut&#39;\n&#125;);\n\n我们需要对库中暴露出的 api 去做声明，对上述例子做个分解：暴露了 Circle 类，Circle 构造函数包含两个参数，一个 HTMLElement，一个 options. OK, come on~\n&#x2F;&#x2F; 首先声明一下模块：\ndeclare module &#39;progressbar.js&#39; &#123;\n  &#x2F;&#x2F; 模块中暴露了 Circle 类\n  export class Circle &#123;\n    constructor(container: HTMLElement, options: Options);\n  &#125;\n\n  &#x2F;&#x2F; 构造函数的 Options 需要单独声明 \n  interface Options &#123;\n    easing?: string;\n    strokeWidth?: number;\n    trailColor?: string;\n    trailWidth?: number;\n  &#125;\n&#125;\n\n如此我们便完成了一个简单的声明，当然实际使用中的 API 肯定比上述情况复杂，根据使用情况，用了哪些 API 或者参数，就补充那些的声明即可。\n三. 如何组织一个 TS 项目\nTS 项目的目录组织上，跟 JS 项目一样，补充好 types 的声明就可以了。\n需要注意的是，将你希望对外暴露的能力相关的类型声明都暴露出去，不友好的声明会让接入你项目的人非常的痛苦，同时，在 package.json 中需要指定 type 的 path, 比如：&quot;types&quot;: &quot;dist/types/index.d.ts&quot;\n另外，务必加上 tslint, 更规范的去用 TS 实现功能，对于入门而言尤为重要。\nTS 带来的改变接触 TS 一个月的感受上来说，过了磨合期的痛苦，就能慢慢感受到 TS 带来的便利。\n比如，有一个类型你记得名字是 ABC，你在 VSCode 中输入 A，然后发现，竟然能找到我的声明，按一下回车，卧槽，自动给你 import 进来了，不用在一个个字的输入 ..&#x2F;..&#x2F;..&#x2F;..&#x2F;，不用算目录层级是否正确了，是不是很爽。\n另外，强类型并不是没有好处啊，浪写惯了可能还是会留隐患的，有点约束也好 …\n虽然你每天要多敲很多 import * as xx from &#39;xx&#39;, 但是你的代码也更为可靠了不是。\n与君共勉，提前感受下一代 ES 标准，TS 用起来吧~\n","slug":"TypeScript，初次见面","date":"2021-08-03T11:45:38.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"679a9e76b771c60b95232fe737f13603","title":"Antd Form.List实现自定义可编辑表格","content":"\n一、前言定制化较深的需求，往往需要可编辑表格来支持表格内的编辑，但是针对必填项校验以及自定义action动作，常规的EditableTable难以满足需要，而EditableProTable则因为定制化太深而不够灵活，所以我们需要更加灵活的方案来实现我们需要的效果，经试验，Form.List是个不错的实现思路。\n二、针对需求\n表格内编辑\n动态新增行（自定义action按钮动作）\n最小维度为行的必填项校验\n灵活可扩展\n\n三、实现方法\n尝试 在项目中，我碰到这样的需求，需要表格可编辑，且初始默认一行可编辑状态数据，点击行最后一列的add进行必填项校验，校验完成新增一行且把已编辑完的数据置为不可编辑状态，起初考虑的实现方式很简单，在外层包一个Form，columns里面的项再包裹Form.Item，至于是否可编辑状态，给表格的数据源加入一个editable字段用于判断是否编辑就行了，本以为这个方案可行，但实际上问题很多，如果要针对行进行校验，那显然每一个行都要和Form利用Form.Item的name属性进行绑定，这时候name是啥呢，没有层级划分，如果你给name的值单单为数据的字段名，那添加一行后下一行岂不是和第一行的name重复了？这会导致新增一行有初始数据，且初始数据是上一行已保存的数据，至于校验，每次新增行调用form.submit可以实现行的校验，但显然这种方案是不可行的。\n\n意识到要让行数据对应Form的标志唯一，那么就考虑使用Form.List实现。\n\n\nForm.List\n\n\nForm.List的基本用法参考antd官方文档，可见这个元素就是为了解决标志重复的问题而生的，它对初始的数组数据又做多了一层映射，这层映射对应一个数组，而数组内的元素则是存有原数据数组下标的对象。多说无益，看图。\n\n有了这层映射，我们Form.Item的name便有了每行唯一的上级，于是我们就可以将表头配置的columns写成如下的形式。\nrender: (text, record) &#x3D;&gt; &#123;\n        paidDetails[record.name])\n        return paidDetails[record.name]?.editable ?\n          &lt;Form.Item\n            rules&#x3D;&#123;[&#123; required: true, message: undefined &#125;]&#125;\n            name&#x3D;&#123;[record.name, &#39;paymentTerm&#39;]&#125;\n            fieldKey&#x3D;&#123;[record.fieldKey, &#39;paymentTerm&#39;]&#125;\n            style&#x3D;&#123;&#123; marginBottom: &#39;0px&#39; &#125;&#125;\n          &gt;\n            &lt;Select placeholder&#x3D;&#123;&#39;Please enter&#39;&#125; style&#x3D;&#123;&#123; width: 200 &#125;&#125; &gt;\n              &#123;\n                paymentTremOptions &amp;&amp; paymentTremOptions.map((item) &#x3D;&gt; &#123;\n                  return &lt;Option value&#x3D;&#123;item.value&#125; key&#x3D;&#123;item.value&#125;&gt;&#123;item.label&#125;&lt;&#x2F;Option&gt;\n                &#125;)\n              &#125;\n            &lt;&#x2F;Select&gt;\n          &lt;&#x2F;Form.Item&gt;\n          :                     (paymentTremOptions[paidDetails[record.name]?.paymentTerm - 1]?.label || &#39;-&#39;)\n          &#125;\n复制代码\n\n到了这一步，本以为基本上顺利完成了，但是还是有些意想不到的问题，要实现校验后添加一行，利用Form.List本身的add根本不现实，因为我们还需要新添加的行可编辑而已校验的行不可编辑，也就是说要更改每行数据的editable字段，所以自然而然想到这里我们必须自定义新增行了。\n然而一波未平一波又起，问题还是不断出现，以下是我整理的会遇到的细节问题：\n\ncolumns内add动作调用form.submit进行校验，外层在Form的onFinish对状态数据进行处理（不可行，更新状态数据成功了，而fields还是不变，导致新增行失败）\n既然fields不变，那每次进行判断fields长度与状态数据是否不匹配，然后再增加或减少一个数据（仍旧不可行，新增确实成功了，但是删除的时候会碰到特殊情况，比如删除最后一个直接报错，应该是手动处理fields不完善导致的，没有继续深究原因，但显然这条路走不通，fields既然是Form.Item内部维护的数据，那就不该由开发者手动去操作，否则会出现各种各样的问题）\n\n\n最终实现\n\n最终问题在自定义add上，fields不能手动更改，但肯定有更改的方法，唯一能想到的途经就是通过form了，想想也是，我们给form添加初始值也不能直接更新状态数据就实现啊，都是利用setFieldsValue的，所以改用setFieldsValue后果然实现了。 还有一点，每次表格内行编辑完的数据如何保存，通过setFieldsValue只能新增行，但是行内的数据会丢失，丢失的原因很简单，我们在编辑的时候虽然Form临时保存了数据，但是添加行后，因为所有行的编辑状态会重新判断，所以表格会重新render，我们在编辑时又没有实时将变化更新到状态数据，而Form又拿状态数据作为初始值，自然导致重新render后行数和编辑状态都对了但是每行的字段数据却丢失了，知道问题，解决起来就很简单了，在setFieldsValue的同时也将数据更新到状态就可以了。\n这些处理完后，接下来的问题就是何时进行校验何时进行新增，如果要在校验之后进行新增，那如何做到呢？方法不止一个，我们点击add的时候触发form.submit，就能在触发Form的onFinish之前进行校验，然后在onFinish内更新状态数据同时调用setFieldsValue更新表单数据就行了。 另一种方法也类似，无非是 把动作再做拆分，先利用 form.validateFields做校验，然后在其链式调用then中进行更新状态数据同时调用setFieldsValue更新表单数据就可以了。\n添加实现了接下来就是删除，删除也很简单，不用进行校验，根据唯一标识过滤即可。\n四、实现代码\n页面\n\n &lt;Form form&#x3D;&#123;form&#125; initialValues&#x3D;&#123;&#123; table: paidDetails &#125;&#125; onFinish&#x3D;&#123;(data) &#x3D;&gt; &#123;\n            setPaidDetails(data.table)\n          &#125;&#125;&gt;\n            &lt;Form.List name&#x3D;&quot;table&quot;&gt;\n              &#123;(fields) &#x3D;&gt; &#123;\n                console.log(fields,&#39;fields&#39;)\n                return (\n                  &lt;div&gt;\n                    &lt;Table\n                      className&#x3D;&#123;&#96;xp-table x-table-large $&#123;styles.paidDetailTable&#125;&#96;&#125;\n                      scroll&#x3D;&#123;&#123; scrollToFirstRowOnChange: true, x: &#39;max-content&#39; &#125;&#125;\n                      dataSource&#x3D;&#123;fields&#125;\n                      rowKey&#x3D;&#123;&#39;id&#39;&#125;\n                      pagination&#x3D;&#123;false&#125;\n                      columns&#x3D;&#123;PaidDetailColumns(paidDetails, setPaidDetails, form, formatMessage)&#125;\n                    &#x2F;&gt;\n                  &lt;&#x2F;div&gt;\n                );\n              &#125;\n              &#125;\n            &lt;&#x2F;Form.List&gt;\n          &lt;&#x2F;Form&gt;\n复制代码\n\n\ncolumns\n\nexport const PaidDetailColumns &#x3D; (\n  paidDetails,\n  setPaidDetails,\n  form,\n  formatMessage\n) &#x3D;&gt; &#123;\n  const columnsList &#x3D; [    &#123;      title: formatMessage(&#123; id: &#39;app.No&#39; &#125;),      render: (_, record, index) &#x3D;&gt; &#123;        return index + 1      &#125;    &#125;,    &#123;      title: formatMessage(&#123; id: &#39;repairSettlement.paymentTerm&#39; &#125;),      dataIndex: &#39;paymentTerm&#39;,      render: (text, record) &#x3D;&gt; &#123;        console.log(record, paymentTremOptions, paidDetails[record.name])\n        return paidDetails[record.name]?.editable ?\n          &lt;Form.Item\n            rules&#x3D;&#123;[&#123; required: true, message: undefined &#125;]&#125;\n            name&#x3D;&#123;[record.name, &#39;paymentTerm&#39;]&#125;\n            fieldKey&#x3D;&#123;[record.fieldKey, &#39;paymentTerm&#39;]&#125;\n            style&#x3D;&#123;&#123; marginBottom: &#39;0px&#39; &#125;&#125;\n          &gt;\n            &lt;Select placeholder&#x3D;&#123;&#39;Please enter&#39;&#125; style&#x3D;&#123;&#123; width: 200 &#125;&#125; &gt;\n              &#123;\n                paymentTremOptions &amp;&amp; paymentTremOptions.map((item) &#x3D;&gt; &#123;\n                  return &lt;Option value&#x3D;&#123;item.value&#125; key&#x3D;&#123;item.value&#125;&gt;&#123;item.label&#125;&lt;&#x2F;Option&gt;\n                &#125;)\n              &#125;\n            &lt;&#x2F;Select&gt;\n          &lt;&#x2F;Form.Item&gt;\n          : (paymentTremOptions[paidDetails[record.name]?.paymentTerm - 1]?.label || &#39;-&#39;)\n      &#125;\n    &#125;,\n    &#123;\n      title: formatMessage(&#123; id: &#39;repairSettlement.paymentReceivedAmount&#39; &#125;),\n      dataIndex: &#39;receivableAmount&#39;,\n      render: (text, record) &#x3D;&gt; &#123;\n        return paidDetails[record.name]?.editable ?\n          &lt;Form.Item\n            rules&#x3D;&#123;[&#123; required: true, message: undefined &#125;]&#125;\n            name&#x3D;&#123;[record.name, &#39;receivableAmount&#39;]&#125;\n            fieldKey&#x3D;&#123;[record.fieldKey, &#39;receivableAmount&#39;]&#125;\n            style&#x3D;&#123;&#123; marginBottom: &#39;0px&#39; &#125;&#125;\n          &gt;\n            &lt;InputNumber placeholder&#x3D;&#123;&#39;Please enter&#39;&#125; style&#x3D;&#123;&#123; width: 200 &#125;&#125; &#x2F;&gt;\n          &lt;&#x2F;Form.Item&gt;\n          : (paidDetails[record.name]?.receivableAmount || &#39;-&#39;)\n      &#125;\n    &#125;,\n    &#123;\n      title: formatMessage(&#123; id: &#39;repairSettlement.remark&#39; &#125;),\n      dataIndex: &#39;remark&#39;,\n      render: (text, record) &#x3D;&gt; &#123;\n        return paidDetails[record.name]?.editable ?\n          &lt;Form.Item\n            name&#x3D;&#123;[record.name, &#39;remark&#39;]&#125;\n            fieldKey&#x3D;&#123;[record.fieldKey, &#39;remark&#39;]&#125;\n            style&#x3D;&#123;&#123; marginBottom: &#39;0px&#39; &#125;&#125;\n          &gt;\n            &lt;Input placeholder&#x3D;&#123;&#39;Please enter&#39;&#125; style&#x3D;&#123;&#123; width: 200 &#125;&#125; &#x2F;&gt;\n          &lt;&#x2F;Form.Item&gt;\n          : (paidDetails[record.name]?.remark || &#39;-&#39;)\n      &#125;\n    &#125;,\n    &#123;\n      title: formatMessage(&#123; id: &#39;app.action&#39; &#125;),\n      fixed: &#39;right&#39;,\n      render: (text, record, _) &#x3D;&gt; &#123;\n        return paidDetails[record.name]?.editable ?\n          &lt;a\n            key&#x3D;&quot;editable&quot;\n            onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n              form.validateFields().then(() &#x3D;&gt; &#123;\n                const list &#x3D; form.getFieldValue(&#39;table&#39;);\n                list.forEach((element: any, index: number) &#x3D;&gt; &#123;\n                  list[index].editable &#x3D; false\n                &#125;);\n                const nextList &#x3D; list.concat([&#123;                  editable: true,                  id: (Math.random() * 1000000).toFixed(0)                &#125;]);\n                console.log(nextList)\n                form.submit()\n                form.setFieldsValue(&#123;\n                  table: nextList,\n                &#125;);\n              &#125;)\n            &#125;&#125;\n          &gt;\n            &#123;formatMessage(&#123; id: &#39;app.add&#39; &#125;)&#125;\n          &lt;&#x2F;a&gt;\n          :\n          &lt;a\n            key&#x3D;&quot;editable&quot;\n            onClick&#x3D;&#123;() &#x3D;&gt; &#123;\n              const list &#x3D; form.getFieldValue(&#39;table&#39;).filter((element: any, index: number) &#x3D;&gt; &#123;\n                return index !&#x3D;&#x3D; record.name\n              &#125;);\n              const nextList &#x3D; list.concat([]);\n              setPaidDetails(nextList)\n              form.setFieldsValue(&#123;\n                table: nextList,\n              &#125;);\n            &#125;&#125;\n          &gt;\n            &#123;formatMessage(&#123; id: &#39;app.remove&#39; &#125;)&#125;\n          &lt;&#x2F;a&gt;\n      &#125;\n\n    &#125;\n  ]\n  return columnsList\n&#125;\n复制代码\n\n五、注意事项1、 注意回显form.setFieldsValue({table: 状态数据}) 这里table对应Form.List的标识, 需要回显的时候Form的initialValue就不需要了\n","slug":"Antd Form.List实现自定义可编辑表格","date":"2021-07-25T13:39:19.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"eb0bae97b5766c0795d8d777051a13ca","title":"面试题笔记——VUE篇(下)","content":"四、路由\n\nVue-Router 的懒加载如何实现非懒加载：import List from ‘@&#x2F;components&#x2F;list.vue’const router &#x3D; new VueRouter({  routes: [ { path: ‘&#x2F;list’, component: List }  ]})复制代码（1）方案一(常用)：使用箭头函数+import动态加载const List &#x3D; () &#x3D;&gt; import(‘@&#x2F;components&#x2F;list.vue’)const router &#x3D; new VueRouter({  routes: [ { path: ‘&#x2F;list’, component: List }  ]})复制代码（2）方案二：使用箭头函数+require动态加载const router &#x3D; new Router({  routes: [{  path: ‘&#x2F;list’,  component: resolve &#x3D;&gt; require([‘@&#x2F;components&#x2F;list’], resolve)}  ]})复制代码（3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。&#x2F;&#x2F; r就是resolveconst List &#x3D; r &#x3D;&gt; require.ensure([], () &#x3D;&gt; r(require(‘@&#x2F;components&#x2F;list’)), ‘list’);&#x2F;&#x2F; 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载const router &#x3D; new Router({  routes: [  { path: ‘&#x2F;list’, component: List, name: ‘list’  } ]}))复制代码\n路由的hash和history模式的区别Vue-Router有两种模式：hash模式和history模式。默认的路由模式是hash模式。\nhash模式简介： hash模式是开发中默认的模式，它的URL带着一个#，例如：www.abc.com/#/vue，它的hash值就是#/vue。特点：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。原理： hash模式的主要原理就是onhashchange()事件：window.onhashchange &#x3D; function(event){ console.log(event.oldURL, event.newURL); let hash &#x3D; location.hash.slice(1);}复制代码使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。\nhistory模式简介： history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。特点： 当使用history模式时，URL就像这样：abc.com&#x2F;user&#x2F;id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。API： history api可以分为两大部分，切换历史状态和修改历史状态：\n\n修改历史状态：包括了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。切换历史状态： 包括forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。\n虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：const router &#x3D; new VueRouter({  mode: ‘history’,  routes: […]})复制代码3. 两种模式对比调用 history.pushState() 相比于直接修改 hash，存在以下优势:\npushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；pushState() 可额外设置 title 属性供后续使用。hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。\nhash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。3. 如何获取页面的hash变化（1）监听$route的变化&#x2F;&#x2F; 监听,当路由发生变化的时候执行watch: {  $route: {    handler: function(val, oldVal){      console.log(val);    },    &#x2F;&#x2F; 深度观察监听    deep: true  }},复制代码（2）window.location.hash读取#值window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。4. $route 和$router 的区别\n$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。\n\n如何定义动态路由？如何获取传过来的动态参数？（1）param方式\n\n配置路由格式：&#x2F;router&#x2F;:id传递的方式：在path后面跟上对应的值传递后形成的路径：&#x2F;router&#x2F;123\n1）路由定义&#x2F;&#x2F;在APP.vue中用户    \n&#x2F;&#x2F;在index.js{   path: ‘&#x2F;user&#x2F;:userid’,   component: User,},复制代码2）路由跳转&#x2F;&#x2F; 方法1：按钮&lt;&#x2F;router-link\n&#x2F;&#x2F; 方法2：this.$router.push({name:’users’,params:{uname:wade}})\n&#x2F;&#x2F; 方法3：this.$router.push(‘&#x2F;user&#x2F;‘ + wade)复制代码3）参数获取通过 $route.params.userid 获取传递的值（2）query方式\n配置路由格式：&#x2F;router，也就是普通配置传递的方式：对象中使用query的key作为传递方式传递后形成的路径：&#x2F;route?id&#x3D;123\n1）路由定义&#x2F;&#x2F;方式1：直接在router-link 标签上以对象的形式档案\n&#x2F;&#x2F; 方式2：写成按钮以点击事件形式&lt;button @click&#x3D;’profileClick’&gt;我的    \nprofileClick(){  this.$router.push({    path: “&#x2F;profile”,    query: {        name: “kobi”,        age: “28”,        height: 198    }  });}复制代码2）跳转方法&#x2F;&#x2F; 方法1：按钮\n&#x2F;&#x2F; 方法2：this.$router.push({ name: ‘users’, query:{ uname:james }})\n&#x2F;&#x2F; 方法3：按钮\n&#x2F;&#x2F; 方法4：this.$router.push({ path: ‘&#x2F;user’, query:{ uname:james }})\n&#x2F;&#x2F; 方法5：this.$router.push(‘&#x2F;user?uname&#x3D;’ + jsmes)复制代码3）获取参数通过$route.query 获取传递的值复制代码6. Vue-router 路由钩子在生命周期的体现一、Vue-Router导航守卫有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的\n全局路由钩子\nvue-router全局有三个路由钩子;\nrouter.beforeEach 全局前置守卫 进入路由之前router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用router.afterEach 全局后置钩子 进入路由之后\n具体使用∶\nbeforeEach（判断是否登录了，没登录就跳转到登录页）\nrouter.beforeEach((to, from, next) &#x3D;&gt; {    let ifInfo &#x3D; Vue.prototype.$common.getSession(‘userData’);  &#x2F;&#x2F; 判断是否登录的存储信息    if (!ifInfo) {        &#x2F;&#x2F; sessionStorage里没有储存user信息        if (to.path &#x3D;&#x3D; ‘&#x2F;‘) {            &#x2F;&#x2F;如果是登录页面路径，就直接next()            next();        } else {            &#x2F;&#x2F;不然就跳转到登录            Message.warning(“请重新登录！”);            window.location.href &#x3D; Vue.prototype.$loginUrl;        }    } else {        return next();    }})复制代码\nafterEach （跳转之后滚动条回到顶部）\nrouter.afterEach((to, from) &#x3D;&gt; {    &#x2F;&#x2F; 跳转之后滚动条回到顶部    window.scrollTo(0,0);});复制代码\n单个路由独享钩子\nbeforeEnter如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、nextexport default [    {        path: ‘&#x2F;‘,        name: ‘login’,        component: login,        beforeEnter: (to, from, next) &#x3D;&gt; {            console.log(‘即将进入登录页面’)            next()        }    }]复制代码\n组件内钩子\nbeforeRouteUpdate、beforeRouteEnter、beforeRouteLeave这三个钩子都有三个参数∶to、from、next\nbeforeRouteEnter∶ 进入组件前触发beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo&#x2F;∶id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用beforeRouteLeave∶ 离开组件被调用\n注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：beforeRouteEnter(to, from, next) {    next(target &#x3D;&gt; {        if (from.path &#x3D;&#x3D; ‘&#x2F;classProcess’) {            target.isFromProcess &#x3D; true        }    })}复制代码二、Vue路由钩子在生命周期函数的体现\n完整的路由导航解析流程（不包括其他生命周期）\n触发进入其他路由。调用要离开路由的组件守卫beforeRouteLeave调用局前置守卫∶ beforeEach在重用的组件里调用 beforeRouteUpdate调用路由独享守卫 beforeEnter。解析异步路由组件。在将要进入的路由组件中调用 beforeRouteEnter调用全局解析守卫 beforeResolve导航被确认。调用全局后置钩子的 afterEach 钩子。触发DOM更新（mounted）。执行beforeRouteEnter 守卫中传给 next 的回调函数\n触发钩子的完整顺序\n路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶\nbeforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。beforeEnter：路由独享守卫beforeRouteEnter：路由组件的组件进入路由前钩子。beforeResolve：路由全局解析守卫afterEach：路由全局后置钩子beforeCreate：组件生命周期，不能访问tAis。created;组件生命周期，可以访问tAis，不能访问dom。beforeMount：组件生命周期deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。mounted：访问&#x2F;操作dom。activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。执行beforeRouteEnter回调函数next。\n导航行为被触发到导航完成的整个过程\n导航行为被触发，此时导航未被确认。在失活的组件里调用离开守卫 beforeRouteLeave。调用全局的 beforeEach守卫。在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。在路由配置里调用 beforeEnteY。解析异步路由组件（如果有）。在被激活的组件里调用 beforeRouteEnter。调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。导航被确认。调用全局的 afterEach 钩子。非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted触发 DOM 更新。用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。导航完成\n\nVue-router跳转和location.href有什么区别\n\n使用 location.href&#x3D; &#x2F;url 来跳转，简单方便，但是刷新了页面；使用 history.pushState( &#x2F;url ) ，无刷新页面，静态跳转；引进 router ，然后使用 router.push( &#x2F;url ) 来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 history.pushState() 没什么差别的，因为vue-router就是用了 history.pushState() ，尤其是在history模式下。\n\nparams和query的区别用法：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 this.$route.query.name 和 this.$route.params.name 。url地址显示：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示注意：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。\nVue-router 导航守卫有哪些\n\n全局前置&#x2F;钩子：beforeEach、beforeResolve、afterEach路由独享的守卫：beforeEnter组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave\n\n对前端路由的理解在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 SPA（单页面应用）。SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：\n\nSPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息\n为了解决这个问题，前端路由出现了。前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。那么如何实现这个目的呢？首先要解决两个问题：\n当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？\n从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：\n拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。\n五、Vuex\n\nVuex 的原理Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\n\nVuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。\nVuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。（1）核心流程中的主要功能：\nVue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;然后 Mutations 就去改变（Mutate）State 中的数据;当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。\n（2）各模块在核心流程中的主要功能：\nVue Components∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。dispatch∶操作行为触发方法，是唯一能执行action的方法。actions∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步&#x2F;异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。commit∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。mutations∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。state∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。getters∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。\n\nVuex中action和mutation的区别mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：const store &#x3D; new Vuex.Store({  state: { count: 1  },  mutations: { increment (state) {   state.count++      &#x2F;&#x2F; 变更状态 }  }})复制代码当触发一个类型为 increment 的 mutation 时，需要调用此函数：store.commit(‘increment’)复制代码而Action类似于mutation，不同点在于：\n\nAction 可以包含任意异步操作。Action 提交的是 mutation，而不是直接变更状态。\nconst store &#x3D; new Vuex.Store({  state: {    count: 0  },  mutations: {    increment (state) {      state.count++    }  },  actions: {    increment (context) {      context.commit(‘increment’)    }  }})复制代码Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。所以，两者的不同点如下：\nMutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。Mutation：必须同步执行；Action：可以异步，但不能直接操作State。在视图更新时，先触发actions，actions再触发mutationmutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters\n\nVuex 和 localStorage 的区别（1）最重要的区别\n\nvuex存储在内存中localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快\n（2）应用场景\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。Vuex能做到数据的响应式，localstorage不能\n（3）永久性刷新页面时vuex存储的值会丢失，localstorage不会。注意： 对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。4. Redux 和 Vuex 有什么区别，它们的共同思想（1）Redux 和 Vuex区别\nVuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）\n通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;（2）共同思想\n单—的数据源变化可以预测\n本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案;形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;5. 为什么要用 Vuex 或者 Redux由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的”视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。6. Vuex有哪几种属性？有五种，分别是 State、 Getter、Mutation 、Action、 Module\nstate &#x3D;&gt; 基本数据(数据源存放地)getters &#x3D;&gt; 从基本数据派生出来的数据mutations &#x3D;&gt; 提交更改数据的方法，同步actions &#x3D;&gt; 像一个装饰器，包裹mutations，使之可以异步。modules &#x3D;&gt; 模块化Vuex\n\nVuex和单纯的全局对象有什么区别？\n\nVuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。\n\n为什么 Vuex 的 mutation 中不能做异步操作？\n\nVuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。\n\nVuex的严格模式是什么,有什么作用，如何开启？在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。在Vuex.Store 构造器选项中开启,如下const store &#x3D; new Vuex.Store({ strict:true,})复制代码\n如何在组件中批量使用Vuex的getter属性使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中import {mapGetters} from ‘vuex’export default{computed:{…mapGetters([‘total’,’discountTotal’])}}复制代码\n如何在组件中重复使用Vuex的mutation使用mapMutations辅助函数,在组件中这么使用import { mapMutations } from ‘vuex’methods:{…mapMutations({setNumber:’SET_NUMBER’,})}复制代码然后调用this.setNumber(10)相当调用this.$store.commit(‘SET_NUMBER’,10)六、Vue 3.0\nVue3.0有什么更新（1）监测机制的改变\n\n3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：\n（2）只能监测属性，不能监测对象\n检测属性的添加和删除；检测数组索引和长度的变更；支持 Map、Set、WeakMap 和 WeakSet。\n（3）模板\n作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。\n（4）对象式的组件声明方式\nvue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易\n（5）其它方面的更改\n支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。基于 tree shaking 优化，提供了更多的内置功能。\n\ndefineProperty和proxy的区别Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter&#x2F;setter。这样当追踪数据发生变化时，setter 会被自动调用。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。但是这样做有以下问题：\n\n添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过$set 来调用Object.defineProperty()处理。无法监控到数组下标和长度的变化。\nVue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于Object.defineProperty()，其有以下特点：\nProxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。Proxy 可以监听数组的变化。\n\nVue3.0 为什么要用 proxy？在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶\n\n不需用使用 Vue.$set 或 Vue.$delete 触发响应式。全方位的数组变化检测，消除了Vue2 无效的边界情况。支持 Map，Set，WeakMap 和 WeakSet。\nProxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶\nget 收集依赖Set、delete 等触发依赖对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。\n\nVue 3.0 中的 Vue Composition API？在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：\n\n由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。Vue 组件过于依赖this上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在methods 中的this竟然指向组件实例来不指向methods所在的对象。这也使得 TypeScript 在Vue2 中很不好用。\n于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。如下，是一个使用了 Vue Composition API 的 Vue3 组件：  &lt;button @click&#x3D;”increment”&gt;    Count:   \n\n// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数\nimport { ref, computed, onMounted } from 'vue'\n \nexport default {\n  setup() {\n// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数\n    const count = ref(0)\n \n// Vue2中需要在methods option中声明的函数，现在直接声明\n    function increment() {\n      count.value++\n    }\n // 对应于Vue2中的mounted声明周期\n    onMounted(() => console.log('component mounted!'))\n \n    return {\n      count,\n      increment\n    }\n  }\n}\n\n复制代码显而易见，Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性5. Composition API与React Hook很像，区别是什么从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制\n不能在循环、条件、嵌套函数中调用Hook必须确保总是在你的React函数的顶层调用HookuseEffect、useMemo等函数必须手动确定依赖关系\n而Composition API是基于Vue的响应式系统实现的，与React Hook的相比\n声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。\n虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。七、虚拟DOM\n\n对虚拟DOM的理解？从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。\n虚拟DOM的解析过程虚拟DOM的解析过程：\n\n首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。\n\n为什么要用虚拟DOM（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能看一下页面渲染的流程：解析HTML -&gt; 生成DOM -&gt; 生成 CSSOM -&gt; Layout -&gt; Paint -&gt; Compiler下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶\n\n真实DOM∶ 生成HTML字符串＋重建所有的DOM元素虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新\nVirtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。（2）跨平台Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。4. 虚拟DOM真的比真实DOM性能好吗\n首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。\n\nDIFF算法的原理在新老虚拟DOM对比时：\n\n首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。匹配时，找到相同的子节点，递归比较子节点\n在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。6. Vue中key的作用vue 中 key 值的作用可以分为两种情况来考虑：\n第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。\nkey 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速\n更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key &#x3D;&#x3D;&#x3D; b.key对比中可以避免就地复用的情况。所以会更加准确。更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快\n\n为什么不建议用index作为key?使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2…这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。\n\n","slug":"面试题笔记——VUE篇(下)","date":"2021-06-24T12:41:13.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"be5afecc963f0a7007cee0b82bb652a1","title":"面试题笔记——VUE篇(上)","content":"一、Vue 基础1. Vue的基本原理当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter&#x2F;setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。 \n2. 双向数据绑定的原理Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：\n\n需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\ncompile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\nWatcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。\nMVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。\n\n\n3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。\n在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。\n4. MVVM、MVC、MVP的区别MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。\n在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。\n（1）MVC\nMVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。 \n（2）MVVM\nMVVM 分为 Model、View、ViewModel：\n\nModel代表数据模型，数据和业务逻辑都在Model层中定义；\nView代表UI视图，负责数据的展示；\nViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；\n\nModel和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。\n这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。 \n（3）MVP\nMVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。\n5. Computed 和 Watch 的区别对于Computed：\n\n它支持缓存，只有依赖的数据发生了变化，才会重新计算\n不支持异步，当Computed中有异步操作时，无法监听数据的变化\ncomputed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。\n如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed\n如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。\n\n对于Watch：\n\n它不支持缓存，数据变化时，它就会触发相应的操作\n\n支持异步监听\n\n监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值\n\n当一个属性发生变化时，就需要执行相应的操作\n\n监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：\n\nimmediate：组件加载立即触发回调函数\ndeep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。\n\n\n\n当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。\n总结：\n\ncomputed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。\nwatch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。\n\n运用场景：\n\n当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。\n当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n\n6. Computed 和 Methods 的区别可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的\n不同点：\n\ncomputed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；\nmethod 调用总会执行该函数。\n\n7. slot是什么？有什么作用？原理是什么？slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。\n\n默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。\n具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。\n作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。\n\n实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。\n8. 过滤器的作用，如何实现一个过滤器根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用filters来过滤数据，filters不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示）。\n使用场景：\n\n需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 &#x2F; 显示。\n比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters过滤器来处理数据。\n\n过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在插值表达式 &#123;&#123; &#125;&#125; 和 v-bind 表达式 中，然后放在操作符“ | ”后面进行指示。\n例如，在显示金额，给商品价格添加单位：\n&lt;li&gt;商品价格：&#123;&#123;item.price | filterPrice&#125;&#125;&lt;&#x2F;li&gt;\n\n filters: &#123;\n    filterPrice (price) &#123;\n      return price ? (&#39;￥&#39; + price) : &#39;--&#39;\n    &#125;\n  &#125;\n复制代码\n\n9. 如何保存页面的当前的状态既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：\n\n前组件会被卸载\n前组件不会被卸载\n\n那么可以按照这两种情况分别得到以下方法：\n组件会被卸载：\n（1）将状态存储在LocalStorage &#x2F; SessionStorage\n只需要在组件即将被销毁的生命周期 componentWillUnmount （react）中在 LocalStorage &#x2F; SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。\n比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。\n优点：\n\n兼容性好，不需要额外库或工具。\n简单快捷，基本可以满足大部分需求。\n\n缺点：\n\n状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）\n如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象\n\n（2）路由传值\n通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。\n在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。\n优点：\n\n简单快捷，不会污染 LocalStorage &#x2F; SessionStorage。\n可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify &#x2F; parse 的不足）\n\n缺点：\n\n如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。\n\n组件不会被卸载：\n（1）单页面渲染\n要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。\n优点：\n\n代码量少\n不需要考虑状态传递过程中的错误\n\n缺点：\n\n增加 A 组件维护成本\n需要传入额外的 prop 到 B 组件\n无法利用路由定位页面\n\n除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行 被包裹在keep-alive中的组件的状态将会被保留：\n&lt;keep-alive&gt;\n\t&lt;router-view v-if&#x3D;&quot;$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;\n&lt;&#x2F;kepp-alive&gt;\n复制代码\n\nrouter.js\n&#123;\n  path: &#39;&#x2F;&#39;,\n  name: &#39;xxx&#39;,\n  component: ()&#x3D;&gt;import(&#39;..&#x2F;src&#x2F;views&#x2F;xxx.vue&#39;),\n  meta:&#123;\n    keepAlive: true &#x2F;&#x2F; 需要被缓存\n  &#125;\n&#125;,\n复制代码\n\n10. 常见的事件修饰符及其作用\n.stop：等同于 JavaScript 中的 event.stopPropagation() ，防止事件冒泡；\n.prevent ：等同于 JavaScript 中的 event.preventDefault() ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；\n.capture ：与事件冒泡的方向相反，事件捕获由外到内；\n.self ：只会触发自己范围内的事件，不包含子元素；\n.once ：只会触发一次。\n\n11. v-if、v-show、v-html 的原理\nv-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；\nv-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；\nv-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。\n\n13. v-if和v-show的区别\n手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；\n编译过程：v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；\n编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；\n性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。\n\n14. v-model 是如何实现的，语法糖实际是什么？（1）作用在表单元素上 动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：\n&lt;input v-model&#x3D;&quot;sth&quot; &#x2F;&gt;\n&#x2F;&#x2F;  等同于\n&lt;input \n    v-bind:value&#x3D;&quot;message&quot; \n    v-on:input&#x3D;&quot;message&#x3D;$event.target.value&quot;\n&gt;\n&#x2F;&#x2F;$event 指代当前触发的事件对象;\n&#x2F;&#x2F;$event.target 指代当前触发的事件对象的dom;\n&#x2F;&#x2F;$event.target.value 就是当前dom的value值;\n&#x2F;&#x2F;在@input方法中，value &#x3D;&gt; sth;\n&#x2F;&#x2F;在:value中,sth &#x3D;&gt; value;\n复制代码\n\n（2）作用在组件上 在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件\n本质是一个父子组件通信的语法糖，通过prop和$.emit实现。 因此父组件 v-model 语法糖本质上可以修改为：\n&lt;child :value&#x3D;&quot;message&quot;  @input&#x3D;&quot;function(e)&#123;message &#x3D; e&#125;&quot;&gt;&lt;&#x2F;child&gt;\n复制代码\n\n在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。 例子：\n&#x2F;&#x2F; 父组件\n&lt;aa-input v-model&#x3D;&quot;aa&quot;&gt;&lt;&#x2F;aa-input&gt;\n&#x2F;&#x2F; 等价于\n&lt;aa-input v-bind:value&#x3D;&quot;aa&quot; v-on:input&#x3D;&quot;aa&#x3D;$event.target.value&quot;&gt;&lt;&#x2F;aa-input&gt;\n\n&#x2F;&#x2F; 子组件：\n&lt;input v-bind:value&#x3D;&quot;aa&quot; v-on:input&#x3D;&quot;onmessage&quot;&gt;&lt;&#x2F;aa-input&gt;\n\nprops:&#123;value:aa,&#125;\nmethods:&#123;\n    onmessage(e)&#123;\n        $emit(&#39;input&#39;,e.target.value)\n    &#125;\n&#125;\n复制代码\n\n默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input $emit过来的值。\n15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？可以。v-model 实际上是一个语法糖，如：\n&lt;input v-model&#x3D;&quot;searchText&quot;&gt;\n复制代码\n\n实际上相当于：\n&lt;input\n  v-bind:value&#x3D;&quot;searchText&quot;\n  v-on:input&#x3D;&quot;searchText &#x3D; $event.target.value&quot;\n&gt;\n复制代码\n\n用在自定义组件上也是同理：\n&lt;custom-input v-model&#x3D;&quot;searchText&quot;&gt;\n复制代码\n\n相当于：\n&lt;custom-input\n  v-bind:value&#x3D;&quot;searchText&quot;\n  v-on:input&#x3D;&quot;searchText &#x3D; $event&quot;\n&gt;&lt;&#x2F;custom-input&gt;\n复制代码\n\n显然，custom-input 与父组件的交互如下：\n\n父组件将searchText变量传入custom-input 组件，使用的 prop 名为value；\ncustom-input 组件向父组件传出名为input的事件，父组件将接收到的值赋值给searchText；\n\n所以，custom-input 组件的实现应该类似于这样：\nVue.component(&#39;custom-input&#39;, &#123;\n  props: [&#39;value&#39;],\n  template: &#96;\n    &lt;input\n      v-bind:value&#x3D;&quot;value&quot;\n      v-on:input&#x3D;&quot;$emit(&#39;input&#39;, $event.target.value)&quot;\n    &gt;\n  &#96;\n&#125;)\n复制代码\n\n16. data为什么是一个函数而不是对象JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。\n而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。\n所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。\n17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。\n（1）keep-alive\nkeep-alive有以下三个属性：\n\ninclude 字符串或正则表达式，只有名称匹配的组件会被匹配；\nexclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；\nmax 数字，最多可以缓存多少组件实例。\n\n注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。\n主要流程\n\n判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。\n获取组件实例 key ，如果有获取实例的 key，否则重新生成。\nkey生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。\n如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。\n\n（2）keep-alive 的实现\nconst patternTypes: Array&lt;Function&gt; &#x3D; [String, RegExp, Array] &#x2F;&#x2F; 接收：字符串，正则，数组\n\nexport default &#123;\n  name: &#39;keep-alive&#39;,\n  abstract: true, &#x2F;&#x2F; 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。\n\n  props: &#123;\n    include: patternTypes, &#x2F;&#x2F; 匹配的组件，缓存\n    exclude: patternTypes, &#x2F;&#x2F; 不去匹配的组件，不缓存\n    max: [String, Number], &#x2F;&#x2F; 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限\n  &#125;,\n\n  created() &#123;\n    &#x2F;&#x2F; 用于初始化缓存虚拟DOM数组和vnode的key\n    this.cache &#x3D; Object.create(null)\n    this.keys &#x3D; []\n  &#125;,\n\n  destroyed() &#123;\n    &#x2F;&#x2F; 销毁缓存cache的组件实例\n    for (const key in this.cache) &#123;\n      pruneCacheEntry(this.cache, key, this.keys)\n    &#125;\n  &#125;,\n\n  mounted() &#123;\n    &#x2F;&#x2F; prune 削减精简[v.]\n    &#x2F;&#x2F; 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容\n    this.$watch(&#39;include&#39;, (val) &#x3D;&gt; &#123;\n      pruneCache(this, (name) &#x3D;&gt; matches(val, name))\n    &#125;)\n    this.$watch(&#39;exclude&#39;, (val) &#x3D;&gt; &#123;\n      pruneCache(this, (name) &#x3D;&gt; !matches(val, name))\n    &#125;)\n  &#125;,\n&#125;\n复制代码\n\nrender函数：\n\n会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件\nkeep-alive 只对第一个组件有效，所以获取第一个子组件。\n和 keep-alive 搭配使用的一般有：动态组件 和router-view\n\nrender () &#123;\n  &#x2F;&#x2F;\n  function getFirstComponentChild (children: ?Array&lt;VNode&gt;): ?VNode &#123;\n    if (Array.isArray(children)) &#123;\n  for (let i &#x3D; 0; i &lt; children.length; i++) &#123;\n    const c &#x3D; children[i]\n    if (isDef(c) &amp;&amp; (isDef(c.componentOptions) || isAsyncPlaceholder(c))) &#123;\n      return c\n    &#125;\n  &#125;\n  &#125;\n  &#125;\n  const slot &#x3D; this.$slots.default &#x2F;&#x2F; 获取默认插槽\n  const vnode: VNode &#x3D; getFirstComponentChild(slot)&#x2F;&#x2F; 获取第一个子组件\n  const componentOptions: ?VNodeComponentOptions &#x3D; vnode &amp;&amp; vnode.componentOptions &#x2F;&#x2F; 组件参数\n  if (componentOptions) &#123; &#x2F;&#x2F; 是否有组件参数\n    &#x2F;&#x2F; check pattern\n    const name: ?string &#x3D; getComponentName(componentOptions) &#x2F;&#x2F; 获取组件名\n    const &#123; include, exclude &#125; &#x3D; this\n    if (\n      &#x2F;&#x2F; not included\n      (include &amp;&amp; (!name || !matches(include, name))) ||\n      &#x2F;&#x2F; excluded\n      (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))\n    ) &#123;\n      &#x2F;&#x2F; 如果不匹配当前组件的名字和include以及exclude\n      &#x2F;&#x2F; 那么直接返回组件的实例\n      return vnode\n    &#125;\n\n    const &#123; cache, keys &#125; &#x3D; this\n\n    &#x2F;&#x2F; 获取这个组件的key\n    const key: ?string &#x3D; vnode.key &#x3D;&#x3D; null\n      &#x2F;&#x2F; same constructor may get registered as different local components\n      &#x2F;&#x2F; so cid alone is not enough (#3269)\n      ? componentOptions.Ctor.cid + (componentOptions.tag ? &#96;::$&#123;componentOptions.tag&#125;&#96; : &#39;&#39;)\n      : vnode.key\n\n    if (cache[key]) &#123;\n      &#x2F;&#x2F; LRU缓存策略执行\n      vnode.componentInstance &#x3D; cache[key].componentInstance &#x2F;&#x2F; 组件初次渲染的时候componentInstance为undefined\n\n      &#x2F;&#x2F; make current key freshest\n      remove(keys, key)\n      keys.push(key)\n      &#x2F;&#x2F; 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面\n    &#125; else &#123;\n      &#x2F;&#x2F; 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除\n      &#x2F;&#x2F; 使用时间间隔最长的一个\n      cache[key] &#x3D; vnode\n      keys.push(key)\n      &#x2F;&#x2F; prune oldest entry\n      if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123;\n        pruneCacheEntry(cache, keys[0], keys, this._vnode)\n      &#125;\n    &#125;\n    &#x2F;&#x2F; 将组件的keepAlive属性设置为true\n    vnode.data.keepAlive &#x3D; true &#x2F;&#x2F; 作用：判断是否要执行组件的created、mounted生命周期函数\n  &#125;\n  return vnode || (slot &amp;&amp; slot[0])\n&#125;\n复制代码\n\nkeep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。\n实现步骤：\n\n获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名\n通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode\n需要缓存，判断他当前是否在缓存数组里面：\n\n\n存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）\n不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key\n\n\n最后将这个组件的 keepAlive 设置为 true\n\n（3）keep-alive 本身的创建过程和 patch 过程\n缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。\n首次渲染\n\n组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM\n\n&#x2F;&#x2F; core&#x2F;instance&#x2F;lifecycle\nfunction initLifecycle (vm: Component) &#123;\n  const options &#x3D; vm.$options\n\n  &#x2F;&#x2F; locate first non-abstract parent\n  let parent &#x3D; options.parent\n  if (parent &amp;&amp; !options.abstract) &#123; &#x2F;&#x2F; 判断组件的abstract属性，才往父组件里面挂载DOM\n    while (parent.$options.abstract &amp;&amp; parent.$parent) &#123;\n      parent &#x3D; parent.$parent\n    &#125;\n    parent.$children.push(vm)\n  &#125;\n\n  vm.$parent &#x3D; parent\n  vm.$root &#x3D; parent ? parent.$root : vm\n\n  vm.$children &#x3D; []\n  vm.$refs &#x3D; &#123;&#125;\n\n  vm._watcher &#x3D; null\n  vm._inactive &#x3D; null\n  vm._directInactive &#x3D; false\n  vm._isMounted &#x3D; false\n  vm._isDestroyed &#x3D; false\n  vm._isBeingDestroyed &#x3D; false\n&#125;\n复制代码\n\n\n判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance\n\n&#x2F;&#x2F; core&#x2F;vdom&#x2F;create-component\ninit (vnode: VNodeWithData, hydrating: boolean): ?boolean &#123;\n    if (\n      vnode.componentInstance &amp;&amp;\n      !vnode.componentInstance._isDestroyed &amp;&amp;\n      vnode.data.keepAlive\n    ) &#123; &#x2F;&#x2F; componentInstance在初次是undefined!!!\n      &#x2F;&#x2F; kept-alive components, treat as a patch\n      const mountedNode: any &#x3D; vnode &#x2F;&#x2F; work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode) &#x2F;&#x2F; prepatch函数执行的是组件更新的过程\n    &#125; else &#123;\n      const child &#x3D; vnode.componentInstance &#x3D; createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      )\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating)\n    &#125;\n  &#125;,\n复制代码\n\nprepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入\n（4）LRU （least recently used）缓存策略\nLRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。 LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 “如果数据最近被访问过，那么将来被访问的几率也更高” 。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶\n\n新数据插入到链表头部\n每当缓存命中（即缓存数据被访问），则将数据移到链表头部\n链表满的时候，将链表尾部的数据丢弃。\n\n18. $nextTick 原理及作用Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。\nnextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微&#x2F;宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。\nnextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理\nnextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶\n\n如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI&#x2F;DOM 的渲染，可以减少一些无用渲染\n同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要\n\nVue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。\n由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中。\nthis.$nextTick(() &#x3D;&gt; &#123;    &#x2F;&#x2F; 获取数据的操作...&#125;)\n复制代码\n\n所以，在以下情况下，会用到nextTick：\n\n在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。\n在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。\n\n因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。\n19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？&lt;template&gt; \n   &lt;div&gt;\n      &lt;ul&gt;\n         &lt;li v-for&#x3D;&quot;value in obj&quot; :key&#x3D;&quot;value&quot;&gt; &#123;&#123;value&#125;&#125; &lt;&#x2F;li&gt; \n      &lt;&#x2F;ul&gt; \n      &lt;button @click&#x3D;&quot;addObjB&quot;&gt;添加 obj.b&lt;&#x2F;button&gt; \n   &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n    export default &#123; \n       data () &#123; \n          return &#123; \n              obj: &#123; \n                  a: &#39;obj.a&#39; \n              &#125; \n          &#125; \n       &#125;,\n       methods: &#123; \n          addObjB () &#123; \n              this.obj.b &#x3D; &#39;obj.b&#39; \n              console.log(this.obj) \n          &#125; \n      &#125;\n   &#125;\n&lt;&#x2F;script&gt;\n复制代码\n\n点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api $set()：\naddObjB () (\n   this.$set(this.obj, &#39;b&#39;, &#39;obj.b&#39;)\n   console.log(this.obj)\n&#125;\n复制代码\n\n$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。\n20. Vue中封装的数组方法有哪些，其如何实现页面更新在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。  那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：\n&#x2F;&#x2F; 缓存数组原型\nconst arrayProto &#x3D; Array.prototype;\n&#x2F;&#x2F; 实现 arrayMethods.__proto__ &#x3D;&#x3D;&#x3D; Array.prototype\nexport const arrayMethods &#x3D; Object.create(arrayProto);\n&#x2F;&#x2F; 需要进行功能拓展的方法\nconst methodsToPatch &#x3D; [\n  &quot;push&quot;,\n  &quot;pop&quot;,\n  &quot;shift&quot;,\n  &quot;unshift&quot;,\n  &quot;splice&quot;,\n  &quot;sort&quot;,\n  &quot;reverse&quot;\n];\n\n&#x2F;**\n * Intercept mutating methods and emit events\n *&#x2F;\nmethodsToPatch.forEach(function(method) &#123;\n  &#x2F;&#x2F; 缓存原生数组方法\n  const original &#x3D; arrayProto[method];\n  def(arrayMethods, method, function mutator(...args) &#123;\n    &#x2F;&#x2F; 执行并缓存原生数组功能\n    const result &#x3D; original.apply(this, args);\n    &#x2F;&#x2F; 响应式处理\n    const ob &#x3D; this.__ob__;\n    let inserted;\n    switch (method) &#123;\n    &#x2F;&#x2F; push、unshift会新增索引，所以要手动observer\n      case &quot;push&quot;:\n      case &quot;unshift&quot;:\n        inserted &#x3D; args;\n        break;\n      &#x2F;&#x2F; splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。\n      case &quot;splice&quot;:\n        inserted &#x3D; args.slice(2);\n        break;\n    &#125;\n    &#x2F;&#x2F; \n    if (inserted) ob.observeArray(inserted);&#x2F;&#x2F; 获取插入的值，并设置响应式监听\n    &#x2F;&#x2F; notify change\n    ob.dep.notify();&#x2F;&#x2F; 通知依赖更新\n    &#x2F;&#x2F; 返回原生数组方法的执行结果\n    return result;\n  &#125;);\n&#125;);\n复制代码\n\n简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过target__proto__ == arrayMethods来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。\n21. Vue 单页应用与多页应用的区别概念：\n\nSPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。\nMPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。\n\n区别： \n22. Vue template 到 render 的过程vue的模版编译过程主要如下：template -&gt; ast -&gt; render函数\nvue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：\n&#x2F;&#x2F; 将模板编译为render函数const &#123; render, staticRenderFns &#125; &#x3D; compileToFunctions(template,options&#x2F;&#x2F;省略&#125;, this)\n复制代码\n\nCompileToFunctions中的主要逻辑如下∶ （1）调用parse方法将template转化为ast（抽象语法树）\nconstast &#x3D; parse(template.trim(), options)\n复制代码\n\n\nparse的目标：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。\n解析过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。\n\nAST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本\n（2）对静态节点做优化\noptimize(ast,options)\n复制代码\n\n这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化\n深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。\n（3）生成代码\nconst code &#x3D; generate(ast, options)\n复制代码\n\ngenerate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 new Function(`` render``) 生成render函数。\n23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。\n如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。\n24. 简述 mixin、extends 的覆盖逻辑（1）mixin 和 extends mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。\n\nmixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。\nextends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。\n\n （2）mergeOptions 的执行过程\n\n规范化选项（normalizeProps、normalizelnject、normalizeDirectives)\n对未合并的选项，进行判断\n\nif(!child._base) &#123;    if(child.extends) &#123;        parent &#x3D; mergeOptions(parent, child.extends, vm)    &#125;    if(child.mixins) &#123;        for(let i &#x3D; 0, l &#x3D; child.mixins.length; i &lt; l; i++)&#123;            parent &#x3D; mergeOptions(parent, child.mixins[i], vm)        &#125;    &#125;&#125;\n复制代码\n\n\n合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。\n返回合并结果 options。\n\n25. 描述下Vue自定义指令在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。 一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;\n（1）自定义指令基本内容\n\n全局定义：Vue.directive(&quot;focus&quot;,&#123;&#125;)\n\n局部定义：directives:&#123;focus:&#123;&#125;&#125;\n\n钩子函数：指令定义对象提供钩子函数\no bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\no inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。\no update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。\no ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。\no unbind：只调用一次，指令与元素解绑时调用。\n\n钩子函数参数 o el：绑定元素\no bing： 指令核心对象，描述指令全部信息属性\no name\no value\no oldValue\no expression\no arg\no modifers\no vnode 虚拟节点\no oldVnode：上一个虚拟节点（更新钩子函数中才有用）\n\n\n（2）使用场景\n\n普通DOM元素进行底层操作的时候，可以使用自定义指令\n自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。\n\n（3）使用案例\n初级应用：\n\n鼠标聚焦\n下拉菜单\n相对时间转换\n滚动动画\n\n高级应用：\n\n自定义指令实现图片懒加载\n自定义指令集成第三方插件\n\n26. 子组件可以直接改变父组件的数据吗？子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。\nVue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。\n只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。\n27. Vue是如何收集依赖的？在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶\nfunction defieneReactive (obj, key, val)&#123;\n  const dep &#x3D; new Dep();\n  ...\n  Object.defineProperty(obj, key, &#123;\n    ...\n    get: function reactiveGetter () &#123;\n      if(Dep.target)&#123;\n        dep.depend();\n        ...\n      &#125;\n      return val\n    &#125;\n    ...\n  &#125;)\n&#125;\n复制代码\n\n以上只保留了关键代码，主要就是 const dep = new Dep()实例化一个 Dep 的实例，然后在 get 函数中通过 dep.depend() 进行依赖收集。 （1）Dep Dep是整个依赖收集的核心，其关键代码如下：\nclass Dep &#123;\n  static target;\n  subs;\n\n  constructor () &#123;\n    ...\n    this.subs &#x3D; [];\n  &#125;\n  addSub (sub) &#123;\n    this.subs.push(sub)\n  &#125;\n  removeSub (sub) &#123;\n    remove(this.sub, sub)\n  &#125;\n  depend () &#123;\n    if(Dep.target)&#123;\n      Dep.target.addDep(this)\n    &#125;\n  &#125;\n  notify () &#123;\n    const subs &#x3D; this.subds.slice();\n    for(let i &#x3D; 0;i &lt; subs.length; i++)&#123;\n      subs[i].update()\n    &#125;\n  &#125;\n&#125;\n复制代码\n\nDep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶\n（2）Watcher\nclass Watcher &#123;\n  getter;\n  ...\n  constructor (vm, expression)&#123;\n    ...\n    this.getter &#x3D; expression;\n    this.get();\n  &#125;\n  get () &#123;\n    pushTarget(this);\n    value &#x3D; this.getter.call(vm, vm)\n    ...\n    return value\n  &#125;\n  addDep (dep)&#123;\n        ...\n    dep.addSub(this)\n  &#125;\n  ...\n&#125;\nfunction pushTarget (_target) &#123;\n  Dep.target &#x3D; _target\n&#125;\n复制代码\n\nWatcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。\n（3）过程\n在实例化 Vue 时，依赖收集的相关过程如下∶ 初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。 初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，\nupdateComponent &#x3D; () &#x3D;&gt; &#123;\n  vm._update(vm._render())\n&#125;\nnew Watcher(vm, updateComponent)\n复制代码\n\nget 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。\nthis.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。\n28. 对 React 和 Vue 的理解，它们的异同相似之处：\n\n都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；\n都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；\n都使用了Virtual DOM（虚拟DOM）提高重绘性能；\n都有props的概念，允许组件间的数据传递；\n都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。\n\n不同之处 ：\n1）数据流\nVue默认支持数据双向绑定，而React一直提倡单向数据流\n2）虚拟DOM\nVue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。\n\nVue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。\n对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent&#x2F;shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。\n\n3）组件化\nReact与Vue最大的不同是模板的编写。\n\nVue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。\nReact推荐你所有的模板通用JavaScript的语法扩展——JSX书写。\n\n具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。 4）监听数据变化的实现原理不同\n\nVue 通过 getter&#x2F;setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能\nReact 默认是通过比较引用的方式进行的，如果不优化（PureComponent&#x2F;shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。\n\n5）高阶组件\nreact可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。\n高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。\n6）构建工具\n两者都有自己的构建工具：\n\nReact &#x3D;&#x3D;&gt; Create React APP\nVue &#x3D;&#x3D;&gt; vue-cli\n\n7）跨平台\n\nReact &#x3D;&#x3D;&gt; React Native\nVue &#x3D;&#x3D;&gt; Weex\n\n29. Vue的优点\n轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；\n简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；\n双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；\n组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；\n视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；\n虚拟DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；\n运行速度更快：相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue 存在很大的优势。\n\n30. assets和static的区别相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点\n不相同点： assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。\n建议： 将项目中 template需要的样式文件js文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。\n31. delete和Vue.delete删除数组的区别\ndelete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。\nVue.delete 直接删除了数组 改变了数组的键值。\n\n32. vue如何监听对象或者数组某个属性的变化当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。\n解决方式：\n\nthis.$set(你要改变的数组&#x2F;对象，你要改变的位置&#x2F;key，你要改成什么value)\n\nthis.$set(this.arr, 0, &quot;OBKoro1&quot;); &#x2F;&#x2F; 改变数组this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); &#x2F;&#x2F; 改变对象\n复制代码\n\n\n调用以下几个数组的方法\n\nsplice()、 push()、pop()、shift()、unshift()、sort()、reverse()\n复制代码\n\nvue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除&#x2F;添加操作\nvm.$set 的实现原理是：\n\n如果目标是数组，直接使用数组的 splice 方法触发相应式；\n如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）\n\n33. 什么是 mixin ？\nMixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。\n如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。\n然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。\n\n34. Vue模版编译原理vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。\n\n解析阶段：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。\n优化阶段：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。\n生成阶段：将最终的AST转化为render函数字符串。\n\n35. 对SSR的理解SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端\nSSR的优势：\n\n更好的SEO\n首屏加载速度更快\n\nSSR的缺点：\n\n开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；\n当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；\n更多的服务端负载。\n\n36. Vue的性能优化有哪些（1）编码阶段\n\n尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher\nv-if和v-for不能连用\n如果需要使用v-for给每项元素绑定事件时使用事件代理\nSPA 页面采用keep-alive缓存组件\n在更多的情况下，使用v-if替代v-show\nkey保证唯一\n使用路由懒加载、异步组件\n防抖、节流\n第三方模块按需导入\n长列表滚动到可视区域动态加载\n图片懒加载\n\n（2）SEO优化\n\n预渲染\n服务端渲染SSR\n\n（3）打包优化\n\n压缩代码\nTree Shaking&#x2F;Scope Hoisting\n使用cdn加载第三方模块\n多线程打包happypack\nsplitChunks抽离公共文件\nsourceMap优化\n\n（4）用户体验\n\n骨架屏\nPWA\n还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。\n\n37. 对 SPA 单页面的理解，它的优缺点分别是什么？SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。\n优点：\n\n用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\n基于上面一点，SPA 相对对服务器压力小；\n前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；\n\n缺点：\n\n初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；\n前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\nSEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。\n\n38. template和jsx的有什么分别？对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用vue-loader编译.vue文件，内部依赖的vue-template-compiler模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器babel-plugin-transform-vue-jsx之后，就可以直接手写render函数。\n所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。\n39. vue初始化页面闪动问题使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。\n首先：在css里加上以下代码：\n[v-cloak] &#123;    display: none;&#125;\n复制代码\n\n如果没有彻底解决问题，则在根元素加上style=&quot;display: none;&quot; :style=&quot;&#123;display: &#39;block&#39;&#125;&quot;\n40. extend 有什么作用这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 $mount 一起使用。\n&#x2F;&#x2F; 创建组件构造器let Component &#x3D; Vue.extend(&#123;  template: &#39;&lt;div&gt;test&lt;&#x2F;div&gt;&#39;&#125;)&#x2F;&#x2F; 挂载到 #app 上new Component().$mount(&#39;#app&#39;)&#x2F;&#x2F; 除了上面的方式，还可以用来扩展已有的组件let SuperComponent &#x3D; Vue.extend(Component)new SuperComponent(&#123;    created() &#123;        console.log(1)    &#125;&#125;)new SuperComponent().$mount(&#39;#app&#39;)\n复制代码\n\n42. MVVM的优缺点?优点:\n\n分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑\n提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码\n⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放\n\n缺点:\n\nBug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的\n⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存\n对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。\n\n二、生命周期1. 说一下Vue的生命周期Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。\n\nbeforeCreate（创建前） ：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event&#x2F;watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。\ncreated（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性。\nbeforeMount（挂载前） ：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。\nmounted（挂载后） ：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。\nbeforeUpdate（更新前） ：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。\nupdated（更新后） ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。\nbeforeDestroy（销毁前） ：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。\ndestroyed（销毁后） ：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。\n\n另外还有 keep-alive 独有的生命周期，分别为 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数。\n2. Vue 子组件和父组件执行顺序加载渲染过程：\n\n父组件 beforeCreate\n父组件 created\n父组件 beforeMount\n子组件 beforeCreate\n子组件 created\n子组件 beforeMount\n子组件 mounted\n父组件 mounted\n\n更新过程：\n\n父组件 beforeUpdate\n子组件 beforeUpdate\n子组件 updated\n父组件 updated\n\n销毁过程：\n\n父组件 beforeDestroy\n子组件 beforeDestroy\n子组件 destroyed\n父组件 destoryed\n\n3. created和mounted的区别\ncreated:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。\nmounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。\n\n4. 一般在哪个生命周期请求异步数据我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。 ​\n推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：\n\n能更快获取到服务端数据，减少页面加载时间，用户体验更好；\nSSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。\n\n5. keep-alive 中的生命周期哪些keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。\n如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。\n当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。\n三、组件通信组件通信的方式如下：\n（1） props  &#x2F;   $emit父组件通过props向子组件传递数据，子组件通过$emit和父组件通信\n1. 父组件向子组件传值\nprops只能是父组件向子组件进行传值，props使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。\nprops 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。\nprops属性名规则：若在props中使用驼峰形式，模板中需要使用短横线的形式\n\n&#x2F;&#x2F; 父组件\n&lt;template&gt;\n    &lt;div id&#x3D;&quot;father&quot;&gt;\n        &lt;son :msg&#x3D;&quot;msgData&quot; :fn&#x3D;&quot;myFunction&quot;&gt;&lt;&#x2F;son&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport son from &quot;.&#x2F;son.vue&quot;;\nexport default &#123;\n    name: father,\n    data() &#123;\n        msgData: &quot;父组件数据&quot;;\n    &#125;,\n    methods: &#123;\n        myFunction() &#123;\n            console.log(&quot;vue&quot;);\n        &#125;\n    &#125;,\n    components: &#123;\n        son\n    &#125;\n&#125;;\n&lt;&#x2F;script&gt;\n复制代码\n\n&#x2F;&#x2F; 子组件\n&lt;template&gt;\n    &lt;div id&#x3D;&quot;son&quot;&gt;\n        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;\n        &lt;button @click&#x3D;&quot;fn&quot;&gt;按钮&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n    name: &quot;son&quot;,\n    props: [&quot;msg&quot;, &quot;fn&quot;]\n&#125;;\n&lt;&#x2F;script&gt;\n复制代码\n\n2. 子组件向父组件传值\n$emit绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过v-on监听并接收参数。\n\n&#x2F;&#x2F; 父组件\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;section&quot;&gt;\n    &lt;com-article :articles&#x3D;&quot;articleList&quot; @onEmitIndex&#x3D;&quot;onEmitIndex&quot;&gt;&lt;&#x2F;com-article&gt;\n    &lt;p&gt;&#123;&#123;currentIndex&#125;&#125;&lt;&#x2F;p&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport comArticle from &#39;.&#x2F;test&#x2F;article.vue&#39;\nexport default &#123;\n  name: &#39;comArticle&#39;,\n  components: &#123; comArticle &#125;,\n  data() &#123;\n    return &#123;\n      currentIndex: -1,\n      articleList: [&#39;红楼梦&#39;, &#39;西游记&#39;, &#39;三国演义&#39;]\n    &#125;\n  &#125;,\n  methods: &#123;\n    onEmitIndex(idx) &#123;\n      this.currentIndex &#x3D; idx\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码\n\n&#x2F;&#x2F;子组件\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;div v-for&#x3D;&quot;(item, index) in articles&quot; :key&#x3D;&quot;index&quot; @click&#x3D;&quot;emitIndex(index)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  props: [&#39;articles&#39;],\n  methods: &#123;\n    emitIndex(index) &#123;\n      this.$emit(&#39;onEmitIndex&#39;, index) &#x2F;&#x2F; 触发父组件的方法，并传递参数index\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码\n\n（2）eventBus事件总线（$emit / $on）eventBus事件总线适用于父子组件、非父子组件等之间的通信，使用步骤如下： （1）创建事件中心管理组件之间的通信\n&#x2F;&#x2F; event-bus.js\n\nimport Vue from &#39;vue&#39;\nexport const EventBus &#x3D; new Vue()\n复制代码\n\n（2）发送事件 假设有两个兄弟组件firstCom和secondCom：\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;first-com&gt;&lt;&#x2F;first-com&gt;\n    &lt;second-com&gt;&lt;&#x2F;second-com&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport firstCom from &#39;.&#x2F;firstCom.vue&#39;\nimport secondCom from &#39;.&#x2F;secondCom.vue&#39;\nexport default &#123;\n  components: &#123; firstCom, secondCom &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码\n\n在firstCom组件中发送事件：\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;button @click&#x3D;&quot;add&quot;&gt;加法&lt;&#x2F;button&gt;    \n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123;EventBus&#125; from &#39;.&#x2F;event-bus.js&#39; &#x2F;&#x2F; 引入事件中心\n\nexport default &#123;\n  data()&#123;\n    return&#123;\n      num:0\n    &#125;\n  &#125;,\n  methods:&#123;\n    add()&#123;\n      EventBus.$emit(&#39;addition&#39;, &#123;\n        num:this.num++\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码\n\n（3）接收事件 在secondCom组件中发送事件：\n&lt;template&gt;\n  &lt;div&gt;求和: &#123;&#123;count&#125;&#125;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; EventBus &#125; from &#39;.&#x2F;event-bus.js&#39;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      count: 0\n    &#125;\n  &#125;,\n  mounted() &#123;\n    EventBus.$on(&#39;addition&#39;, param &#x3D;&gt; &#123;\n      this.count &#x3D; this.count + param.num;\n    &#125;)\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码\n\n在上述代码中，这就相当于将num值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。\n虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。\n（3）依赖注入（provide &#x2F; inject）这种方式就是Vue中的依赖注入，该方法用于父子组件之间的通信。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。\nprovide / inject是Vue提供的两个钩子，和data、methods是同级的。并且provide的书写形式和data一样。\n\nprovide 钩子用来发送数据或方法\ninject钩子用来接收数据或方法\n\n在父组件中：\nprovide() &#123; \n    return &#123;     \n        num: this.num  \n    &#125;;\n&#125;\n复制代码\n\n在子组件中：\ninject: [&#39;num&#39;]\n复制代码\n\n还可以这样写，这样写就可以访问父组件中的所有属性：\nprovide() &#123;\n return &#123;\n    app: this\n  &#125;;\n&#125;\ndata() &#123;\n return &#123;\n    num: 1\n  &#125;;\n&#125;\n\ninject: [&#39;app&#39;]\nconsole.log(this.app.num)\n复制代码\n\n注意： 依赖注入所提供的属性是非响应式的。\n（3）ref &#x2F; $refs这种方式也是实现父子组件之间的通信。\nref： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。\n在子组件中：\nexport default &#123;\n  data () &#123;\n    return &#123;\n      name: &#39;JavaScript&#39;\n    &#125;\n  &#125;,\n  methods: &#123;\n    sayHello () &#123;\n      console.log(&#39;hello&#39;)\n    &#125;\n  &#125;\n&#125;\n复制代码\n\n在父组件中：\n&lt;template&gt;\n  &lt;child ref&#x3D;&quot;child&quot;&gt;&lt;&#x2F;component-a&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\n  import child from &#39;.&#x2F;child.vue&#39;\n  export default &#123;\n    components: &#123; child &#125;,\n    mounted () &#123;\n      console.log(this.$refs.child.name);  &#x2F;&#x2F; JavaScript\n      this.$refs.child.sayHello();  &#x2F;&#x2F; hello\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n复制代码\n\n（4）$parent / $children\n使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）\n使用$children可以让组件访问子组件的实例，但是，$children并不能保证顺序，并且访问的数据也不是响应式的。\n\n在子组件中：\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;span&gt;\n    &lt;p&gt;获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;&lt;&#x2F;p&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  data() &#123;\n    return &#123;\n      message: &#39;Vue&#39;\n    &#125;\n  &#125;,\n  computed:&#123;\n    parentVal()&#123;\n      return this.$parent.msg;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码\n\n在父组件中：\n&#x2F;&#x2F; 父组件中\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;hello_world&quot;&gt;\n    &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;\n    &lt;child&gt;&lt;&#x2F;child&gt;\n    &lt;button @click&#x3D;&quot;change&quot;&gt;点击改变子组件值&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport child from &#39;.&#x2F;child.vue&#39;\nexport default &#123;\n  components: &#123; child &#125;,\n  data() &#123;\n    return &#123;\n      msg: &#39;Welcome&#39;\n    &#125;\n  &#125;,\n  methods: &#123;\n    change() &#123;\n      &#x2F;&#x2F; 获取到子组件\n      this.$children[0].message &#x3D; &#39;JavaScript&#39;\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n复制代码\n\n在上面的代码中，子组件获取到了父组件的parentVal值，父组件改变了子组件中message的值。 需要注意：\n\n通过$parent访问到的是上一级父组件的实例，可以使用$root来访问根组件的实例\n在组件中使用$children拿到的是所有的子组件的实例，它是一个数组，并且是无序的\n在根组件#app上拿$parent得到的是new Vue()的实例，在这实例上再拿$parent得到的是undefined，而在最底层的子组件拿$children是个空数组\n$children 的值是数组，而$parent是个对象\n\n（5）$attrs / $listeners考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？\n如果是用props/$emit来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。\n针对上述情况，Vue引入了$attrs / $listeners，实现组件之间的跨代通信。\n先来看一下inheritAttrs，它的默认值true，继承所有的父组件属性除props之外的所有属性；inheritAttrs：false 只继承class属性 。\n\n$attrs：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上\n$listeners：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 v-on=&quot;$listeners&quot; 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）\n\nA组件（APP.vue）：\n&lt;template&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;\n        &#x2F;&#x2F;此处监听了两个事件，可以在B组件或者C组件中直接触发 \n        &lt;child1 :p-child1&#x3D;&quot;child1&quot; :p-child2&#x3D;&quot;child2&quot; @test1&#x3D;&quot;onTest1&quot; @test2&#x3D;&quot;onTest2&quot;&gt;&lt;&#x2F;child1&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nimport Child1 from &#39;.&#x2F;Child1.vue&#39;;\nexport default &#123;\n    components: &#123; Child1 &#125;,\n    methods: &#123;\n        onTest1() &#123;\n            console.log(&#39;test1 running&#39;);\n        &#125;,\n        onTest2() &#123;\n            console.log(&#39;test2 running&#39;);\n        &#125;\n    &#125;\n&#125;;\n&lt;&#x2F;script&gt;\n复制代码\n\nB组件（Child1.vue）：\n&lt;template&gt;\n    &lt;div class&#x3D;&quot;child-1&quot;&gt;\n        &lt;p&gt;props: &#123;&#123;pChild1&#125;&#125;&lt;&#x2F;p&gt;\n        &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;&#x2F;p&gt;\n        &lt;child2 v-bind&#x3D;&quot;$attrs&quot; v-on&#x3D;&quot;$listeners&quot;&gt;&lt;&#x2F;child2&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nimport Child2 from &#39;.&#x2F;Child2.vue&#39;;\nexport default &#123;\n    props: [&#39;pChild1&#39;],\n    components: &#123; Child2 &#125;,\n    inheritAttrs: false,\n    mounted() &#123;\n        this.$emit(&#39;test1&#39;); &#x2F;&#x2F; 触发APP.vue中的test1方法\n    &#125;\n&#125;;\n&lt;&#x2F;script&gt;\n复制代码\n\nC 组件 (Child2.vue)：\n&lt;template&gt;\n    &lt;div class&#x3D;&quot;child-2&quot;&gt;\n        &lt;p&gt;props: &#123;&#123;pChild2&#125;&#125;&lt;&#x2F;p&gt;\n        &lt;p&gt;$attrs: &#123;&#123;$attrs&#125;&#125;&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n    props: [&#39;pChild2&#39;],\n    inheritAttrs: false,\n    mounted() &#123;\n        this.$emit(&#39;test2&#39;);&#x2F;&#x2F; 触发APP.vue中的test2方法\n    &#125;\n&#125;;\n&lt;&#x2F;script&gt;\n复制代码\n\n在上述代码中：\n\nC组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性\n在B组件中通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）\n\n（6）总结（1）父子组件间通信\n\n子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。\n通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。\n使用 provide&#x2F;inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。\n\n（2）兄弟组件间通信\n\n使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。\n通过 $parent/$refs 来获取到兄弟组件，也可以进行通信。\n\n（3）任意组件之间\n\n使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。\n\n如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。\n","slug":"面试题笔记——VUE篇(上)","date":"2021-06-23T02:33:53.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"2fdea5cb1f84778b4d76cd27c9ba53f7","title":"面试题笔记——JS篇(下)","content":"六、this&#x2F;call&#x2F;apply&#x2F;bind1. 对this对象的理解this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。\n\n第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。\n第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。\n第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。\n第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。\n\n这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。\n2. call() 和 apply() 的区别？它们的作用一模一样，区别仅在于传入参数的形式的不同。\n\napply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。\ncall 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。\n\n3. 实现call、apply 及 bind 函数（1）call 函数的实现步骤：\n\n判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n处理传入的参数，截取第一个参数后的所有参数。\n将函数作为上下文对象的一个属性。\n使用上下文对象来调用这个方法，并保存返回结果。\n删除刚才新增的属性。\n返回结果。\n\nFunction.prototype.myCall &#x3D; function(context) &#123;\n  &#x2F;&#x2F; 判断调用对象\n  if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    console.error(&quot;type error&quot;);\n  &#125;\n  &#x2F;&#x2F; 获取参数\n  let args &#x3D; [...arguments].slice(1),\n    result &#x3D; null;\n  &#x2F;&#x2F; 判断 context 是否传入，如果未传入则设置为 window\n  context &#x3D; context || window;\n  &#x2F;&#x2F; 将调用函数设为对象的方法\n  context.fn &#x3D; this;\n  &#x2F;&#x2F; 调用函数\n  result &#x3D; context.fn(...args);\n  &#x2F;&#x2F; 将属性删除\n  delete context.fn;\n  return result;\n&#125;;\n复制代码\n\n（2）apply 函数的实现步骤：\n\n判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n将函数作为上下文对象的一个属性。\n判断参数值是否传入\n使用上下文对象来调用这个方法，并保存返回结果。\n删除刚才新增的属性\n返回结果\n\nFunction.prototype.myApply &#x3D; function(context) &#123;\n  &#x2F;&#x2F; 判断调用对象是否为函数\n  if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    throw new TypeError(&quot;Error&quot;);\n  &#125;\n  let result &#x3D; null;\n  &#x2F;&#x2F; 判断 context 是否存在，如果未传入则为 window\n  context &#x3D; context || window;\n  &#x2F;&#x2F; 将函数设为对象的方法\n  context.fn &#x3D; this;\n  &#x2F;&#x2F; 调用方法\n  if (arguments[1]) &#123;\n    result &#x3D; context.fn(...arguments[1]);\n  &#125; else &#123;\n    result &#x3D; context.fn();\n  &#125;\n  &#x2F;&#x2F; 将属性删除\n  delete context.fn;\n  return result;\n&#125;;\n复制代码\n\n（3）bind 函数的实现步骤：\n\n判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n保存当前函数的引用，获取其余传入参数值。\n创建一个函数返回\n函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。\n\nFunction.prototype.myBind &#x3D; function(context) &#123;\n  &#x2F;&#x2F; 判断调用对象是否为函数\n  if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    throw new TypeError(&quot;Error&quot;);\n  &#125;\n  &#x2F;&#x2F; 获取参数\n  var args &#x3D; [...arguments].slice(1),\n    fn &#x3D; this;\n  return function Fn() &#123;\n    &#x2F;&#x2F; 根据调用方式，传入不同绑定值\n    return fn.apply(\n      this instanceof Fn ? this : context,\n      args.concat(...arguments)\n    );\n  &#125;;\n&#125;;\n复制代码\n\n七、异步编程1. 异步编程的实现方式？JavaScript中的异步机制可以分为以下几种：\n\n回调函数 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。\nPromise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。\ngenerator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。\nasync 函数 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。\n\n2. setTimeout、Promise、Async&#x2F;Await 的区别（1）setTimeoutconsole.log(&#39;script start&#39;)\t&#x2F;&#x2F;1. 打印 script start\nsetTimeout(function()&#123;\n    console.log(&#39;settimeout&#39;)\t&#x2F;&#x2F; 4. 打印 settimeout\n&#125;)\t&#x2F;&#x2F; 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数\nconsole.log(&#39;script end&#39;)\t&#x2F;&#x2F;3. 打印 script start\n&#x2F;&#x2F; 输出顺序：script start-&gt;script end-&gt;settimeout\n复制代码\n\n（2）PromisePromise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then&#x2F;catch等，当主栈完成后，才会去调用resolve&#x2F;reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。\nconsole.log(&#39;script start&#39;)\nlet promise1 &#x3D; new Promise(function (resolve) &#123;\n    console.log(&#39;promise1&#39;)\n    resolve()\n    console.log(&#39;promise1 end&#39;)\n&#125;).then(function () &#123;\n    console.log(&#39;promise2&#39;)\n&#125;)\nsetTimeout(function()&#123;\n    console.log(&#39;settimeout&#39;)\n&#125;)\nconsole.log(&#39;script end&#39;)\n&#x2F;&#x2F; 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout\n复制代码\n\n当JS主线程执行到Promise对象时：\n\npromise1.then() 的回调就是一个 task\npromise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue\npromise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中\nsetTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况\n\n（3）async&#x2F;awaitasync function async1()&#123;\n   console.log(&#39;async1 start&#39;);\n    await async2();\n    console.log(&#39;async1 end&#39;)\n&#125;\nasync function async2()&#123;\n    console.log(&#39;async2&#39;)\n&#125;\nconsole.log(&#39;script start&#39;);\nasync1();\nconsole.log(&#39;script end&#39;)\n&#x2F;&#x2F; 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end\n复制代码\n\nasync 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。\n例如：\nasync function func1() &#123;\n    return 1\n&#125;\nconsole.log(func1())\n复制代码\n\n func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。\nfunc1().then(res &#x3D;&gt; &#123;\n    console.log(res);  &#x2F;&#x2F; 30\n&#125;)\n复制代码\n\nawait的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。\n3. 对Promise的理解Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n（1）Promise的实例有三个状态:\n\nPending（进行中）\nResolved（已完成）\nRejected（已拒绝）\n\n当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。\n（2）Promise的实例有两个过程：\n\npending -&gt; fulfilled : Resolved（已完成）\npending -&gt; rejected：Rejected（已拒绝）\n\n注意：一旦从进行状态变成为其他状态就永远不能更改状态了。\nPromise的特点：\n\n对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“承诺”；\n一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。\n\nPromise的缺点：\n\n无法取消Promise，一旦新建它就会立即执行，无法中途取消。\n如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。\n当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n总结： Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。\n状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。\n注意： 在构造 Promise 的时候，构造函数内部的代码是立即执行的\n4. Promise的基本用法（1）创建Promise对象Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。\nconst promise &#x3D; new Promise(function(resolve, reject) &#123;\n  &#x2F;&#x2F; ... some code\n  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;\n    resolve(value);\n  &#125; else &#123;\n    reject(error);\n  &#125;\n&#125;);\n复制代码\n\n一般情况下都会使用new Promise()来创建promise对象，但是也可以使用promise.resolve和promise.reject这两个方法：\n\nPromise.resolve\n\nPromise.resolve(value)的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：\nPromise.resolve(11).then(function(value)&#123;\n  console.log(value); &#x2F;&#x2F; 打印出11\n&#125;);\n复制代码\n\nresolve(11)代码中，会让promise对象进入确定(resolve状态)，并将参数11传递给后面的then所指定的onFulfilled 函数；\n创建promise对象可以使用new Promise的形式创建对象，也可以使用Promise.resolve(value)的形式创建promise对象；\n\nPromise.reject\n\nPromise.reject 也是new Promise的快捷形式，也创建一个promise对象。代码如下：\nPromise.reject(new Error(“我错了，请原谅俺！！”));\n复制代码\n\n就是下面的代码new Promise的简单形式：\nnew Promise(function(resolve,reject)&#123;\n   reject(new Error(&quot;我错了！&quot;));\n&#125;);\n复制代码\n\n下面是使用resolve方法和reject方法：\nfunction testPromise(ready) &#123;\n  return new Promise(function(resolve,reject)&#123;\n    if(ready) &#123;\n      resolve(&quot;hello world&quot;);\n    &#125;else &#123;\n      reject(&quot;No thanks&quot;);\n    &#125;\n  &#125;);\n&#125;;\n&#x2F;&#x2F; 方法调用\ntestPromise(true).then(function(msg)&#123;\n  console.log(msg);\n&#125;,function(error)&#123;\n  console.log(error);\n&#125;);\n复制代码\n\n上面的代码的含义是给testPromise方法传递一个参数，返回一个promise对象，如果为true的话，那么调用promise对象中的resolve()方法，并且把其中的参数传递给后面的then第一个函数内，因此打印出 “hello world”, 如果为false的话，会调用promise对象中的reject()方法，则会进入then的第二个函数内，会打印No thanks；\n（2）Promise方法Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。\n\nthen()\n\n当Promise执行的内容符合成功条件时，调用resolve函数，失败就调用reject函数。Promise创建完了，那该如何调用呢？\npromise.then(function(value) &#123;\n  &#x2F;&#x2F; success\n&#125;, function(error) &#123;\n  &#x2F;&#x2F; failure\n&#125;);\n复制代码\n\nthen方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略。 then方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\n当要写有顺序的异步事件时，需要串行时，可以这样写：\nlet promise &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;\n    ajax(&#39;first&#39;).success(function(res)&#123;\n        resolve(res);\n    &#125;)\n&#125;)\npromise.then(res&#x3D;&gt;&#123;\n    return new Promise((resovle,reject)&#x3D;&gt;&#123;\n        ajax(&#39;second&#39;).success(function(res)&#123;\n            resolve(res)\n        &#125;)\n    &#125;)\n&#125;).then(res&#x3D;&gt;&#123;\n    return new Promise((resovle,reject)&#x3D;&gt;&#123;\n        ajax(&#39;second&#39;).success(function(res)&#123;\n            resolve(res)\n        &#125;)\n    &#125;)\n&#125;).then(res&#x3D;&gt;&#123;\n    \n&#125;)\n复制代码\n\n那当要写的事件没有顺序或者关系时，还如何写呢？可以使用all 方法来解决。\n2. catch()\nPromise对象除了有then方法，还有一个catch方法，该方法相当于then方法的第二个参数，指向reject的回调函数。不过catch方法还有一个作用，就是在执行resolve回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入catch方法中。\np.then((data) &#x3D;&gt; &#123;\n     console.log(&#39;resolved&#39;,data);\n&#125;,(err) &#x3D;&gt; &#123;\n     console.log(&#39;rejected&#39;,err);\n     &#125;\n); \np.then((data) &#x3D;&gt; &#123;\n    console.log(&#39;resolved&#39;,data);\n&#125;).catch((err) &#x3D;&gt; &#123;\n    console.log(&#39;rejected&#39;,err);\n&#125;);\n复制代码\n\n3. all()\nall方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个promise对象。当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected。\njavascript\nlet promise1 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;\n\tsetTimeout(()&#x3D;&gt;&#123;\n       resolve(1);\n\t&#125;,2000)\n&#125;);\nlet promise2 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;\n\tsetTimeout(()&#x3D;&gt;&#123;\n       resolve(2);\n\t&#125;,1000)\n&#125;);\nlet promise3 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;\n\tsetTimeout(()&#x3D;&gt;&#123;\n       resolve(3);\n\t&#125;,3000)\n&#125;);\nPromise.all([promise1,promise2,promise3]).then(res&#x3D;&gt;&#123;\n    console.log(res);\n    &#x2F;&#x2F;结果为：[1,2,3] \n&#125;)\n复制代码\n\n调用all方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象resolve执行时的值。\n（4）race()\nrace方法和all一样，接受的参数是一个每项都是promise的数组，但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected。\nlet promise1 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;\n\tsetTimeout(()&#x3D;&gt;&#123;\n       reject(1);\n\t&#125;,2000)\n&#125;);\nlet promise2 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;\n\tsetTimeout(()&#x3D;&gt;&#123;\n       resolve(2);\n\t&#125;,1000)\n&#125;);\nlet promise3 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;\n\tsetTimeout(()&#x3D;&gt;&#123;\n       resolve(3);\n\t&#125;,3000)\n&#125;);\nPromise.race([promise1,promise2,promise3]).then(res&#x3D;&gt;&#123;\n\tconsole.log(res);\n\t&#x2F;&#x2F;结果：2\n&#125;,rej&#x3D;&gt;&#123;\n    console.log(rej)&#125;;\n)\n复制代码\n\n那么race方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：\nPromise.race([promise1,timeOutPromise(5000)]).then(res&#x3D;&gt;&#123;&#125;)\n复制代码\n\n5. finally()\nfinally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\npromise\n.then(result &#x3D;&gt; &#123;···&#125;)\n.catch(error &#x3D;&gt; &#123;···&#125;)\n.finally(() &#x3D;&gt; &#123;···&#125;);\n复制代码\n\n上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。\n下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。\nserver.listen(port)\n  .then(function () &#123;\n    &#x2F;&#x2F; ...\n  &#125;)\n  .finally(server.stop);\n复制代码\n\nfinally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。finally本质上是then方法的特例：\npromise\n.finally(() &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 语句\n&#125;);\n&#x2F;&#x2F; 等同于\npromise\n.then(\n  result &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 语句\n    return result;\n  &#125;,\n  error &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 语句\n    throw error;\n  &#125;\n);\n复制代码\n\n上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。\n5. Promise解决了什么问题在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：\nlet fs &#x3D; require(&#39;fs&#39;)\nfs.readFile(&#39;.&#x2F;a.txt&#39;,&#39;utf8&#39;,function(err,data)&#123;\n  fs.readFile(data,&#39;utf8&#39;,function(err,data)&#123;\n    fs.readFile(data,&#39;utf8&#39;,function(err,data)&#123;\n      console.log(data)\n    &#125;)\n  &#125;)\n&#125;)\n复制代码\n\n上面的代码有如下缺点：\n\n后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。\n如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。\n\nPromise出现之后，代码变成这样：\nlet fs &#x3D; require(&#39;fs&#39;)\nfunction read(url)&#123;\n  return new Promise((resolve,reject)&#x3D;&gt;&#123;\n    fs.readFile(url,&#39;utf8&#39;,function(error,data)&#123;\n      error &amp;&amp; reject(error)\n      resolve(data)\n    &#125;)\n  &#125;)\n&#125;\nread(&#39;.&#x2F;a.txt&#39;).then(data&#x3D;&gt;&#123;\n  return read(data) \n&#125;).then(data&#x3D;&gt;&#123;\n  return read(data)  \n&#125;).then(data&#x3D;&gt;&#123;\n  console.log(data)\n&#125;)\n复制代码\n\n这样代码看起了就简洁了很多，解决了地狱回调的问题。\n6. Promise.all和Promise.race的区别的使用场景（1）Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。\nPromise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。\n需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。\n（2）Promise.race\n顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：\nPromise.race([promise1,timeOutPromise(5000)]).then(res&#x3D;&gt;&#123;&#125;)\n复制代码\n\n7. 对async&#x2F;await 的理解async&#x2F;await其实是Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：\nasync function testAsy()&#123;\n   return &#39;hello world&#39;;\n&#125;\nlet result &#x3D; testAsy(); \nconsole.log(result)\n复制代码\n\n\n所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。\nasync 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样：\nasync function testAsy()&#123;\n   return &#39;hello world&#39;\n&#125;\nlet result &#x3D; testAsy() \nconsole.log(result)\nresult.then(v&#x3D;&gt;&#123;\n    console.log(v)   &#x2F;&#x2F; hello world\n&#125;)\n复制代码\n\n那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 Promise.resolve(undefined)。\n联想一下 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。\n注意： Promise.resolve(x) 可以看作是 new Promise(resolve =&gt; resolve(x)) 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。\n8. await 到底在等啥？await 在等待什么呢？ 一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。\n因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：\nfunction getSomething() &#123;\n    return &quot;something&quot;;\n&#125;\nasync function testAsync() &#123;\n    return Promise.resolve(&quot;hello async&quot;);\n&#125;\nasync function test() &#123;\n    const v1 &#x3D; await getSomething();\n    const v2 &#x3D; await testAsync();\n    console.log(v1, v2);\n&#125;\ntest();\n复制代码\n\nawait 表达式的运算结果取决于它等的是什么。\n\n如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。\n如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。\n\n来看一个例子：\nfunction testAsy(x)&#123;\n   return new Promise(resolve&#x3D;&gt;&#123;setTimeout(() &#x3D;&gt; &#123;\n       resolve(x);\n     &#125;, 3000)\n    &#125;\n   )\n&#125;\nasync function testAwt()&#123;    \n  let result &#x3D;  await testAsy(&#39;hello world&#39;);\n  console.log(result);    &#x2F;&#x2F; 3秒钟之后出现hello world\n  console.log(&#39;cuger&#39;)   &#x2F;&#x2F; 3秒钟之后出现cug\n&#125;\ntestAwt();\nconsole.log(&#39;cug&#39;)  &#x2F;&#x2F;立即输出cug\n复制代码\n\n这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以’cug’’最先输出，hello world’和‘cuger’是3秒钟后同时出现的。\n9. async&#x2F;await的优势单一的 Promise 链并不能发现 async&#x2F;await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async&#x2F;await 来进一步优化它）。\n假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 setTimeout 来模拟异步操作：\n&#x2F;**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n + 200，这个值将用于下一步骤\n *&#x2F;\nfunction takeLongTime(n) &#123;\n    return new Promise(resolve &#x3D;&gt; &#123;\n        setTimeout(() &#x3D;&gt; resolve(n + 200), n);\n    &#125;);\n&#125;\nfunction step1(n) &#123;\n    console.log(&#96;step1 with $&#123;n&#125;&#96;);\n    return takeLongTime(n);\n&#125;\nfunction step2(n) &#123;\n    console.log(&#96;step2 with $&#123;n&#125;&#96;);\n    return takeLongTime(n);\n&#125;\nfunction step3(n) &#123;\n    console.log(&#96;step3 with $&#123;n&#125;&#96;);\n    return takeLongTime(n);\n&#125;\n复制代码\n\n现在用 Promise 方式来实现这三个步骤的处理：\nfunction doIt() &#123;\n    console.time(&quot;doIt&quot;);\n    const time1 &#x3D; 300;\n    step1(time1)\n        .then(time2 &#x3D;&gt; step2(time2))\n        .then(time3 &#x3D;&gt; step3(time3))\n        .then(result &#x3D;&gt; &#123;\n            console.log(&#96;result is $&#123;result&#125;&#96;);\n            console.timeEnd(&quot;doIt&quot;);\n        &#125;);\n&#125;\ndoIt();\n&#x2F;&#x2F; c:\\var\\test&gt;node --harmony_async_await .\n&#x2F;&#x2F; step1 with 300\n&#x2F;&#x2F; step2 with 500\n&#x2F;&#x2F; step3 with 700\n&#x2F;&#x2F; result is 900\n&#x2F;&#x2F; doIt: 1507.251ms\n复制代码\n\n输出结果 result 是 step3() 的参数 700 + 200 &#x3D; 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd() 计算的结果一致。\n如果用 async&#x2F;await 来实现呢，会是这样：\nasync function doIt() &#123;\n    console.time(&quot;doIt&quot;);\n    const time1 &#x3D; 300;\n    const time2 &#x3D; await step1(time1);\n    const time3 &#x3D; await step2(time2);\n    const result &#x3D; await step3(time3);\n    console.log(&#96;result is $&#123;result&#125;&#96;);\n    console.timeEnd(&quot;doIt&quot;);\n&#125;\ndoIt();\n复制代码\n\n结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样\n10. async&#x2F;await对比Promise的优势\n代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担\nPromise传递中间值⾮常麻烦，⽽async&#x2F;await⼏乎是同步的写法，⾮常优雅\n错误处理友好，async&#x2F;await可以⽤成熟的try&#x2F;catch，Promise的错误捕获⾮常冗余\n调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。\n\n11. async&#x2F;await 如何捕获异常async function fn()&#123;\n    try&#123;\n        let a &#x3D; await Promise.reject(&#39;error&#39;)\n    &#125;catch(error)&#123;\n        console.log(error)\n    &#125;\n&#125;\n复制代码\n\n八、面向对象1. 对象创建的方式有哪些？一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：\n（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。\n（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。\n（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。\n（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。\n（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。\n（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。\n2. 对象继承的方式有哪些？（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。\n（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。\n（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。\n（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。\n（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。\n（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。\n九、垃圾回收与内存泄漏1. 浏览器的垃圾回收机制（1）垃圾回收的概念垃圾回收：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。\n回收机制：\n\nJavascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。\nJavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。\n不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。\n\n（2）垃圾回收的方式浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。 1）标记清除\n\n标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。\n垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。\n\n2）引用计数\n\n另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。\n这种方法会引起循环引用的问题：例如： obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。\n\nfunction fun() &#123;\n    let obj1 &#x3D; &#123;&#125;;\n    let obj2 &#x3D; &#123;&#125;;\n    obj1.a &#x3D; obj2; &#x2F;&#x2F; obj1 引用 obj2\n    obj2.a &#x3D; obj1; &#x2F;&#x2F; obj2 引用 obj1\n&#125;\n复制代码\n\n这种情况下，就要手动释放变量占用的内存：\nobj1.a &#x3D;  null\n obj2.a &#x3D;  null\n复制代码\n\n（3）减少垃圾回收虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。\n\n对数组进行优化： 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。\n对object进行优化： 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。\n对函数进行优化： 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。\n\n2. 哪些情况会导致内存泄漏以下四种情况会造成内存的泄漏：\n\n意外的全局变量： 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\n被遗忘的计时器或回调函数： 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。\n脱离 DOM 的引用： 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。\n闭包： 不合理的使用闭包，从而导致某些变量一直被留在内存当中。\n\n","slug":"面试题笔记——JS篇(下)","date":"2021-06-21T13:57:16.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"7fd56521850f8ad3304286dc32e903a9","title":"面试题笔记——JS篇(上)","content":"\n一、数据类型1. JavaScript有哪些数据类型，它们的区别？JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。\n其中 Symbol 和 BigInt 是ES6 中新增的数据类型：\n\nSymbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。\nBigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。\n\n这些数据可以分为原始数据类型和引用数据类型：\n\n栈：原始数据类型（Undefined、Null、Boolean、Number、String）\n堆：引用数据类型（对象、数组和函数）\n\n两种类型的区别在于存储位置的不同：\n\n原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\n堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：\n\n在数据结构中，栈中数据的存取方式为先进后出。\n堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。\n\n在操作系统中，内存被分为栈区和堆区：\n\n栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\n堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。\n\n2. 数据类型检测的方式有哪些（1）typeof\nconsole.log(typeof 2);               &#x2F;&#x2F; number\nconsole.log(typeof true);            &#x2F;&#x2F; boolean\nconsole.log(typeof &#39;str&#39;);           &#x2F;&#x2F; string\nconsole.log(typeof []);              &#x2F;&#x2F; object    \nconsole.log(typeof function()&#123;&#125;);    &#x2F;&#x2F; function\nconsole.log(typeof &#123;&#125;);              &#x2F;&#x2F; object\nconsole.log(typeof undefined);       &#x2F;&#x2F; undefined\nconsole.log(typeof null);            &#x2F;&#x2F; object\n复制代码\n\n其中数组、对象、null都会被判断为object，其他判断都正确。\n（2）instanceof\ninstanceof可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。\nconsole.log(2 instanceof Number);                    &#x2F;&#x2F; false\nconsole.log(true instanceof Boolean);                &#x2F;&#x2F; false \nconsole.log(&#39;str&#39; instanceof String);                &#x2F;&#x2F; false \n \nconsole.log([] instanceof Array);                    &#x2F;&#x2F; true\nconsole.log(function()&#123;&#125; instanceof Function);       &#x2F;&#x2F; true\nconsole.log(&#123;&#125; instanceof Object);                   &#x2F;&#x2F; true\n复制代码\n\n可以看到，instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。\n（3） constructor\nconsole.log((2).constructor &#x3D;&#x3D;&#x3D; Number); &#x2F;&#x2F; true\nconsole.log((true).constructor &#x3D;&#x3D;&#x3D; Boolean); &#x2F;&#x2F; true\nconsole.log((&#39;str&#39;).constructor &#x3D;&#x3D;&#x3D; String); &#x2F;&#x2F; true\nconsole.log(([]).constructor &#x3D;&#x3D;&#x3D; Array); &#x2F;&#x2F; true\nconsole.log((function() &#123;&#125;).constructor &#x3D;&#x3D;&#x3D; Function); &#x2F;&#x2F; true\nconsole.log((&#123;&#125;).constructor &#x3D;&#x3D;&#x3D; Object); &#x2F;&#x2F; true\n复制代码\n\nconstructor有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了：\nfunction Fn()&#123;&#125;;\n \nFn.prototype &#x3D; new Array();\n \nvar f &#x3D; new Fn();\n \nconsole.log(f.constructor&#x3D;&#x3D;&#x3D;Fn);    &#x2F;&#x2F; false\nconsole.log(f.constructor&#x3D;&#x3D;&#x3D;Array); &#x2F;&#x2F; true\n复制代码\n\n（4）Object.prototype.toString.call()\nObject.prototype.toString.call() 使用 Object 对象的原型方法 toString 来判断数据类型：\nvar a &#x3D; Object.prototype.toString;\n \nconsole.log(a.call(2));\nconsole.log(a.call(true));\nconsole.log(a.call(&#39;str&#39;));\nconsole.log(a.call([]));\nconsole.log(a.call(function()&#123;&#125;));\nconsole.log(a.call(&#123;&#125;));\nconsole.log(a.call(undefined));\nconsole.log(a.call(null));\n复制代码\n\n同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？\n这是因为toString是Object的原型方法，而Array、function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。\n3. 判断数组的方式有哪些\n通过Object.prototype.toString.call()做判断\n\nObject.prototype.toString.call(obj).slice(8,-1) &#x3D;&#x3D;&#x3D; &#39;Array&#39;;\n复制代码\n\n\n通过原型链做判断\n\nobj.__proto__ &#x3D;&#x3D;&#x3D; Array.prototype;\n复制代码\n\n\n通过ES6的Array.isArray()做判断\n\nArray.isArrray(obj);\n复制代码\n\n\n通过instanceof做判断\n\nobj instanceof Array\n复制代码\n\n\n通过Array.prototype.isPrototypeOf\n\nArray.prototype.isPrototypeOf(obj)\n复制代码\n\n4. null和undefined区别首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\nundefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。\nundefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\n当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。\n5. typeof null 的结果是什么，为什么？typeof null 的结果是Object。\n在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：\n000: object   - 当前存储的数据指向一个对象。\n  1: int      - 当前存储的数据是一个 31 位的有符号整数。\n010: double   - 当前存储的数据指向一个双精度的浮点数。\n100: string   - 当前存储的数据指向一个字符串。\n110: boolean  - 当前存储的数据是布尔值。\n复制代码\n\n如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。\n有两种特殊数据类型：\n\nundefined的值是 (-2)30(一个超出整数范围的数字)；\nnull 的值是机器码 NULL 指针(null 指针的值全是 0)\n\n那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。\n6. intanceof 操作符的实现原理及实现instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\nfunction myInstanceof(left, right) &#123;\n  &#x2F;&#x2F; 获取对象的原型\n  let proto &#x3D; Object.getPrototypeOf(left)\n  &#x2F;&#x2F; 获取构造函数的 prototype 对象\n  let prototype &#x3D; right.prototype; \n \n  &#x2F;&#x2F; 判断构造函数的 prototype 对象是否在对象的原型链上\n  while (true) &#123;\n    if (!proto) return false;\n    if (proto &#x3D;&#x3D;&#x3D; prototype) return true;\n    &#x2F;&#x2F; 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型\n    proto &#x3D; Object.getPrototypeOf(proto);\n  &#125;\n&#125;\n复制代码\n\n7. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等在开发过程中遇到类似这样的问题：\nlet n1 &#x3D; 0.1, n2 &#x3D; 0.2\nconsole.log(n1 + n2)  &#x2F;&#x2F; 0.30000000000000004\n复制代码\n\n这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：\n(n1 + n2).toFixed(2) &#x2F;&#x2F; 注意，toFixed为四舍五入\n复制代码\n\ntoFixed(num) 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？\n计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是0.0001100110011001100...（1100循环），0.2的二进制是：0.00110011001100...（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？\n一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。\n根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：0.30000000000000004。\n下面看一下双精度数是如何保存的： \n\n第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位\n第二部分（绿色）：用来存储指数（exponent），占用11位\n第三部分（红色）：用来存储小数（fraction），占用52位\n\n对于0.1，它的二进制为：\n0.00011001100110011001100110011001100110011001100110011001 10011...\n复制代码\n\n转为科学计数法（科学计数法的结果就是浮点数）：\n1.1001100110011001100110011001100110011001100110011001*2^-4\n复制代码\n\n可以看出0.1的符号位为0，指数位为-4，小数位为：\n1001100110011001100110011001100110011001100110011001\n复制代码\n\n那么问题又来了，指数位是负数，该如何保存呢？\nIEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定双精度数的偏移量为1023。\n\n当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023&#x3D; -1022，e最大值是2046，则2046-1023&#x3D;1023，可以看到，这种情况下取值范围是-1022~1013。\n当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023&#x3D; -1022。\n当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s&#x3D;0时表示正无穷，s&#x3D;1时候表示负无穷。\n\n对于上面的0.1的指数位为-4，-4+1023 &#x3D; 1019 转化为二进制就是：1111111011.\n所以，0.1表示为：\n0 1111111011 1001100110011001100110011001100110011001100110011001\n复制代码\n\n说了这么多，是时候该最开始的问题了，如何实现0.1+0.2&#x3D;0.3呢？\n对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了Number.EPSILON属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 &#x3D;&#x3D;&#x3D;0.3\nfunction numberepsilon(arg1,arg2)&#123;                   \n  return Math.abs(arg1 - arg2) &lt; Number.EPSILON;        \n&#125;        \n\nconsole.log(numberepsilon(0.1 + 0.2, 0.3)); &#x2F;&#x2F; true\n复制代码\n\n8. 如何获取安全的 undefined 值？因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。\n9. typeof NaN 的结果是什么？NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。\ntypeof NaN; &#x2F;&#x2F; &quot;number&quot;\n复制代码\n\nNaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x &#x3D;&#x3D;&#x3D; x 不成立）的值。而 NaN !&#x3D;&#x3D; NaN 为 true。\n10. isNaN 和 Number.isNaN 函数的区别？\n函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。\n函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。\n\n12. 其他值到字符串的转换规则？\nNull 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，\nBoolean 类型，true 转换为 “true”，false 转换为 “false”。\nNumber 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。\nSymbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。\n对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。\n\n13. 其他值到数字值的转换规则？\nUndefined 类型的值转换为 NaN。\nNull 类型的值转换为 0。\nBoolean 类型的值，true 转换为 1，false 转换为 0。\nString 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。\nSymbol 类型的值不能转换为数字，会报错。\n对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。\n\n为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。\n如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。\n14. 其他值到布尔类型的值的转换规则？以下这些是假值： • undefined • null • false • +0、-0 和 NaN • “”\n假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。\n15. || 和 &amp;&amp; 操作符的返回值？|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。\n\n对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。\n&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。\n\n|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果\n16. Object.is() 与比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？\n使用双等号（&#x3D;&#x3D;）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。\n使用三等号（&#x3D;&#x3D;&#x3D;）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。\n使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。\n\n17. 什么是 JavaScript 中的包装类型？在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：\nconst a &#x3D; &quot;abc&quot;;\na.length; &#x2F;&#x2F; 3\na.toUpperCase(); &#x2F;&#x2F; &quot;ABC&quot;\n复制代码\n\n在访问&#39;abc&#39;.length时，JavaScript 将&#39;abc&#39;在后台转换成String(&#39;abc&#39;)，然后再访问其length属性。\nJavaScript也可以使用Object函数显式地将基本类型转换为包装类型：\nvar a &#x3D; &#39;abc&#39;\nObject(a) &#x2F;&#x2F; String &#123;&quot;abc&quot;&#125;\n复制代码\n\n也可以使用valueOf方法将包装类型倒转成基本类型：\nvar a &#x3D; &#39;abc&#39;\nvar b &#x3D; Object(a)\nvar c &#x3D; b.valueOf() &#x2F;&#x2F; &#39;abc&#39;\n复制代码\n\n看看如下代码会打印出什么：\nvar a &#x3D; new Boolean( false );\nif (!a) &#123;\n\tconsole.log( &quot;Oops&quot; ); &#x2F;&#x2F; never runs\n&#125;\n复制代码\n\n答案是什么都不会打印，因为虽然包裹的基本类型是false，但是false被包裹成包装类型后就成了对象，所以其非值为false，所以循环体中的内容不会运行。\n18. JavaScript 中如何进行隐式类型转换？首先要介绍ToPrimitive方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：\n&#x2F;**\n* @obj 需要转换的对象\n* @type 期望的结果类型\n*&#x2F;\nToPrimitive(obj,type)\n复制代码\n\ntype的值为number或者string。\n（1）当type为number时规则如下：\n\n调用obj的valueOf方法，如果为原始值，则返回，否则下一步；\n调用obj的toString方法，后续同上；\n抛出TypeError 异常。\n\n（2）当type为string时规则如下：\n\n调用obj的toString方法，如果为原始值，则返回，否则下一步；\n调用obj的valueOf方法，后续同上；\n抛出TypeError 异常。\n\n可以看出两者的主要区别在于调用toString和valueOf的先后顺序。默认情况下：\n\n如果对象为 Date 对象，则type默认为string；\n其他情况下，type默认为number。\n\n总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：\nvar objToNumber &#x3D; value &#x3D;&gt; Number(value.valueOf().toString())\nobjToNumber([]) &#x3D;&#x3D;&#x3D; 0\nobjToNumber(&#123;&#125;) &#x3D;&#x3D;&#x3D; NaN\n复制代码\n\n而 JavaScript 中的隐式类型转换主要发生在+、-、*、/以及==、&gt;、&lt;这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用ToPrimitive转换成基本类型，再进行操作。\n以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被ToPrimitive转换成基本类型，所以最终还是要应用基本类型转换规则）：\n\n+操作符 +操作符的两边有至少一个string类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。\n\n1 + &#39;23&#39; &#x2F;&#x2F; &#39;123&#39;\n 1 + false &#x2F;&#x2F; 1 \n 1 + Symbol() &#x2F;&#x2F; Uncaught TypeError: Cannot convert a Symbol value to a number\n &#39;1&#39; + false &#x2F;&#x2F; &#39;1false&#39;\n false + true &#x2F;&#x2F; 1\n复制代码\n\n\n-、*、&#96;&#96;操作符\n\nNaN也是一个数字\n1 * &#39;23&#39; &#x2F;&#x2F; 23\n 1 * false &#x2F;&#x2F; 0\n 1 &#x2F; &#39;aa&#39; &#x2F;&#x2F; NaN\n复制代码\n\n\n对于==操作符\n\n操作符两边的值都尽量转成number：\n3 &#x3D;&#x3D; true &#x2F;&#x2F; false, 3 转为number为3，true转为number为1\n&#39;0&#39; &#x3D;&#x3D; false &#x2F;&#x2F;true, &#39;0&#39;转为number为0，false转为number为0\n&#39;0&#39; &#x3D;&#x3D; 0 &#x2F;&#x2F; &#39;0&#39;转为number为0\n复制代码\n\n\n对于&lt;和&gt;比较符\n\n如果两边都是字符串，则比较字母表顺序：\n&#39;ca&#39; &lt; &#39;bd&#39; &#x2F;&#x2F; false\n&#39;a&#39; &lt; &#39;b&#39; &#x2F;&#x2F; true\n复制代码\n\n其他情况下，转换为数字再比较：\n&#39;12&#39; &lt; 13 &#x2F;&#x2F; true\nfalse &gt; -1 &#x2F;&#x2F; true\n复制代码\n\n以上说的是基本类型的隐式转换，而对象会被ToPrimitive转换为基本类型再进行转换：\nvar a &#x3D; &#123;&#125;\na &gt; 2 &#x2F;&#x2F; false\n复制代码\n\n其对比过程如下：\na.valueOf() &#x2F;&#x2F; &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步\na.toString() &#x2F;&#x2F; &quot;[object Object]&quot;，现在是一个字符串了\nNumber(a.toString()) &#x2F;&#x2F; NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字\nNaN &gt; 2 &#x2F;&#x2F;false，得出比较结果\n复制代码\n\n又比如：\nvar a &#x3D; &#123;name:&#39;Jack&#39;&#125;\nvar b &#x3D; &#123;age: 18&#125;\na + b &#x2F;&#x2F; &quot;[object Object][object Object]&quot;\n复制代码\n\n运算过程如下：\na.valueOf() &#x2F;&#x2F; &#123;&#125;，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步\na.toString() &#x2F;&#x2F; &quot;[object Object]&quot;\nb.valueOf() &#x2F;&#x2F; 同理\nb.toString() &#x2F;&#x2F; &quot;[object Object]&quot;\na + b &#x2F;&#x2F; &quot;[object Object][object Object]&quot;\n复制代码\n\n19. + 操作符什么时候用于字符串的拼接？根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。\n简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。\n那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。\n20. 为什么会有BigInt的提案？JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。\n21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别扩展运算符：\nlet outObj &#x3D; &#123;\n  inObj: &#123;a: 1, b: 2&#125;\n&#125;\nlet newObj &#x3D; &#123;...outObj&#125;\nnewObj.inObj.a &#x3D; 2\nconsole.log(outObj) &#x2F;&#x2F; &#123;inObj: &#123;a: 2, b: 2&#125;&#125;\n复制代码\n\nObject.assign():\nlet outObj &#x3D; &#123;\n  inObj: &#123;a: 1, b: 2&#125;\n&#125;\nlet newObj &#x3D; Object.assign(&#123;&#125;, outObj)\nnewObj.inObj.a &#x3D; 2\nconsole.log(outObj) &#x2F;&#x2F; &#123;inObj: &#123;a: 2, b: 2&#125;&#125;\n复制代码\n\n可以看到，两者都是浅拷贝。\n\nObject.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。\n扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。\n\n二、ES61. let、const、var的区别（1）块级作用域： 块作用域由 &#123; &#125;包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：\n\n内层变量可能覆盖外层变量\n用来计数的循环变量泄露为全局变量\n\n（2）变量提升： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。\n（3）给全局添加属性： 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。\n（4）重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。\n（5）暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。\n（6）初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。\n（7）指针指向： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。\n\n\n\n区别\nvar\nlet\nconst\n\n\n\n是否有块级作用域\n×\n✔️\n✔️\n\n\n是否存在变量提升\n✔️\n×\n×\n\n\n是否添加全局属性\n✔️\n×\n×\n\n\n能否重复声明变量\n✔️\n×\n×\n\n\n是否存在暂时性死区\n×\n✔️\n✔️\n\n\n是否必须设置初始值\n×\n×\n✔️\n\n\n能否改变指针指向\n✔️\n✔️\n×\n\n\n2. const对象的属性可以修改吗const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。\n但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。\n3. 如果new一个箭头函数的会怎么样箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。\nnew操作符的实现步骤如下：\n\n创建一个对象\n将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）\n指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）\n返回新的对象\n\n所以，上面的第二、三步，箭头函数都是没有办法执行的。\n4. 箭头函数与普通函数的区别（1）箭头函数比普通函数更加简洁\n\n如果没有参数，就直接写一个空括号即可\n如果只有一个参数，可以省去参数的括号\n如果有多个参数，用逗号分割\n如果函数体的返回值只有一句，可以省略大括号\n如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：\n\nlet fn &#x3D; () &#x3D;&gt; void doesNotReturn();\n复制代码\n\n（2）箭头函数没有自己的this\n箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。\n（3）箭头函数继承来的this指向永远不会改变\nvar id &#x3D; &#39;GLOBAL&#39;;\nvar obj &#x3D; &#123;\n  id: &#39;OBJ&#39;,\n  a: function()&#123;\n    console.log(this.id);\n  &#125;,\n  b: () &#x3D;&gt; &#123;\n    console.log(this.id);\n  &#125;\n&#125;;\nobj.a();    &#x2F;&#x2F; &#39;OBJ&#39;\nobj.b();    &#x2F;&#x2F; &#39;GLOBAL&#39;\nnew obj.a()  &#x2F;&#x2F; undefined\nnew obj.b()  &#x2F;&#x2F; Uncaught TypeError: obj.b is not a constructor\n复制代码\n\n对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号&#123;&#125;是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。\n（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向\nvar id &#x3D; &#39;Global&#39;;\nlet fun1 &#x3D; () &#x3D;&gt; &#123;\n    console.log(this.id)\n&#125;;\nfun1();                     &#x2F;&#x2F; &#39;Global&#39;\nfun1.call(&#123;id: &#39;Obj&#39;&#125;);     &#x2F;&#x2F; &#39;Global&#39;\nfun1.apply(&#123;id: &#39;Obj&#39;&#125;);    &#x2F;&#x2F; &#39;Global&#39;\nfun1.bind(&#123;id: &#39;Obj&#39;&#125;)();   &#x2F;&#x2F; &#39;Global&#39;\n复制代码\n\n（5）箭头函数不能作为构造函数使用\n构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。\n（6）箭头函数没有自己的arguments\n箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。\n（7）箭头函数没有prototype\n（8）箭头函数不能用作Generator函数，不能使用yeild关键字\n5. 箭头函数的this指向哪⾥？箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。\n可以⽤Babel理解⼀下箭头函数:\n&#x2F;&#x2F; ES6 \nconst obj &#x3D; &#123; \n  getArrow() &#123; \n    return () &#x3D;&gt; &#123; \n      console.log(this &#x3D;&#x3D;&#x3D; obj); \n    &#125;; \n  &#125; \n&#125;\n复制代码\n\n转化后：\n&#x2F;&#x2F; ES5，由 Babel 转译\nvar obj &#x3D; &#123; \n   getArrow: function getArrow() &#123; \n     var _this &#x3D; this; \n     return function () &#123; \n        console.log(_this &#x3D;&#x3D;&#x3D; obj); \n     &#125;; \n   &#125; \n&#125;;\n复制代码\n\n6. 扩展运算符的作用及使用场景（1）对象扩展运算符\n对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。\nlet bar &#x3D; &#123; a: 1, b: 2 &#125;;\nlet baz &#x3D; &#123; ...bar &#125;; &#x2F;&#x2F; &#123; a: 1, b: 2 &#125;\n复制代码\n\n上述方法实际上等价于:\nlet bar &#x3D; &#123; a: 1, b: 2 &#125;;\nlet baz &#x3D; Object.assign(&#123;&#125;, bar); &#x2F;&#x2F; &#123; a: 1, b: 2 &#125;\n复制代码\n\nObject.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。\n同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。\nlet bar &#x3D; &#123;a: 1, b: 2&#125;;\nlet baz &#x3D; &#123;...bar, ...&#123;a:2, b: 4&#125;&#125;;  &#x2F;&#x2F; &#123;a: 2, b: 4&#125;\n复制代码\n\n利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数，reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。\n需要注意：扩展运算符对对象实例的拷贝属于浅拷贝。\n（2）数组扩展运算符\n数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。\nconsole.log(...[1, 2, 3])\n&#x2F;&#x2F; 1 2 3\nconsole.log(...[1, [2, 3, 4], 5])\n&#x2F;&#x2F; 1 [2, 3, 4] 5\n复制代码\n\n下面是数组的扩展运算符的应用：\n\n将数组转换为参数序列\n\nfunction add(x, y) &#123;\n  return x + y;\n&#125;\nconst numbers &#x3D; [1, 2];\nadd(...numbers) &#x2F;&#x2F; 3\n复制代码\n\n\n复制数组\n\nconst arr1 &#x3D; [1, 2];\nconst arr2 &#x3D; [...arr1];\n复制代码\n\n要记住：扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。\n\n合并数组\n\n如果想在数组内合并数组，可以这样：\nconst arr1 &#x3D; [&#39;two&#39;, &#39;three&#39;];const arr2 &#x3D; [&#39;one&#39;, ...arr1, &#39;four&#39;, &#39;five&#39;];&#x2F;&#x2F; [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]\n复制代码\n\n\n扩展运算符与解构赋值结合起来，用于生成数组\n\nconst [first, ...rest] &#x3D; [1, 2, 3, 4, 5];first &#x2F;&#x2F; 1rest  &#x2F;&#x2F; [2, 3, 4, 5]\n复制代码\n\n需要注意：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。\nconst [...rest, last] &#x3D; [1, 2, 3, 4, 5];         &#x2F;&#x2F; 报错const [first, ...rest, last] &#x3D; [1, 2, 3, 4, 5];  &#x2F;&#x2F; 报错\n复制代码\n\n\n将字符串转为真正的数组\n\n[...&#39;hello&#39;]    &#x2F;&#x2F; [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]\n复制代码\n\n\n任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组\n\n比较常见的应用是可以将某些数据结构转为数组：\n&#x2F;&#x2F; arguments对象\nfunction foo() &#123;\n  const args &#x3D; [...arguments];\n&#125;\n复制代码\n\n用于替换es5中的Array.prototype.slice.call(arguments)写法。\n\n使用Math函数获取数组中特定的值\n\nconst numbers &#x3D; [9, 4, 7, 1];\nMath.min(...numbers); &#x2F;&#x2F; 1\nMath.max(...numbers); &#x2F;&#x2F; 9\n复制代码\n\n8. 对对象与数组的解构的理解解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。 1）数组的解构 在解构数组时，以元素的位置为匹配条件来提取想要的数据的：\nconst [a, b, c] &#x3D; [1, 2, 3]\n复制代码\n\n最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：  数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：\nconst [a,,c] &#x3D; [1,2,3]\n复制代码\n\n通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量： \n2）对象的解构 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：\nconst stu &#x3D; &#123;\n  name: &#39;Bob&#39;,\n  age: 24\n&#125;\n复制代码\n\n假如想要解构它的两个自有属性，可以这样：\nconst &#123; name, age &#125; &#x3D; stu\n复制代码\n\n这样就得到了 name 和 age 两个和 stu 平级的变量： \n注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：\nconst &#123; age, name &#125; &#x3D; stu\n复制代码\n\n9. 如何提取高度嵌套的对象里的指定属性？有时会遇到一些嵌套程度非常深的对象：\nconst school &#x3D; &#123;\n   classes: &#123;\n      stu: &#123;\n         name: &#39;Bob&#39;,\n         age: 24,\n      &#125;\n   &#125;\n&#125;\n复制代码\n\n像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：\nconst &#123; name &#125; &#x3D; school\n复制代码\n\n显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：\nconst &#123; classes &#125; &#x3D; school\nconst &#123; stu &#125; &#x3D; classes\nconst &#123; name &#125; &#x3D; stu\nname &#x2F;&#x2F; &#39;Bob&#39;\n复制代码\n\n但是还有一种更标准的做法，可以用一行代码来解决这个问题：\nconst &#123; classes: &#123; stu: &#123; name &#125; &#125;&#125; &#x3D; school\n       \nconsole.log(name)  &#x2F;&#x2F; &#39;Bob&#39;\n复制代码\n\n可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。\n10. 对 rest 参数的理解扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：\nfunction mutiple(...args) &#123;\n  let result &#x3D; 1;\n  for (var val of args) &#123;\n    result *&#x3D; val;\n  &#125;\n  return result;\n&#125;\nmutiple(1, 2, 3, 4) &#x2F;&#x2F; 24\n复制代码\n\n这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：\nfunction mutiple(...args) &#123;\n  console.log(args)\n&#125;\nmutiple(1, 2, 3, 4) &#x2F;&#x2F; [1, 2, 3, 4]\n复制代码\n\n这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。\n11. ES6中模板语法与字符串处理ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：\nvar name &#x3D; &#39;css&#39;   \nvar career &#x3D; &#39;coder&#39; \nvar hobby &#x3D; [&#39;coding&#39;, &#39;writing&#39;]\nvar finalString &#x3D; &#39;my name is &#39; + name + &#39;, I work as a &#39; + career + &#39;, I love &#39; + hobby[0] + &#39; and &#39; + hobby[1]\n复制代码\n\n仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：\nvar name &#x3D; &#39;css&#39;   \nvar career &#x3D; &#39;coder&#39; \nvar hobby &#x3D; [&#39;coding&#39;, &#39;writing&#39;]\nvar finalString &#x3D; &#96;my name is $&#123;name&#125;, I work as a $&#123;career&#125; I love $&#123;hobby[0]&#125; and $&#123;hobby[1]&#125;&#96;\n复制代码\n\n字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：\n\n在模板字符串中，空格、缩进、换行都会被保留\n模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算\n\n基于第一点，可以在模板字符串里无障碍地直接写 html 代码：\nlet list &#x3D; &#96;\n\t&lt;ul&gt;\n\t\t&lt;li&gt;列表项1&lt;&#x2F;li&gt;\n\t\t&lt;li&gt;列表项2&lt;&#x2F;li&gt;\n\t&lt;&#x2F;ul&gt;\n&#96;;\nconsole.log(message); &#x2F;&#x2F; 正确输出，不存在报错\n复制代码\n\n基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：\nfunction add(a, b) &#123;\n  const finalString &#x3D; &#96;$&#123;a&#125; + $&#123;b&#125; &#x3D; $&#123;a+b&#125;&#96;\n  console.log(finalString)\n&#125;\nadd(1, 2) &#x2F;&#x2F; 输出 &#39;1 + 2 &#x3D; 3&#39;\n复制代码\n\n除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：\n（1）存在性判定：在过去，当判断一个字符&#x2F;字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。\n\nincludes：判断字符串与子串的包含关系：\n\nconst son &#x3D; &#39;haha&#39; \nconst father &#x3D; &#39;xixi haha hehe&#39;\nfather.includes(son) &#x2F;&#x2F; true\n复制代码\n\n\nstartsWith：判断字符串是否以某个&#x2F;某串字符开头：\n\nconst father &#x3D; &#39;xixi haha hehe&#39;\nfather.startsWith(&#39;haha&#39;) &#x2F;&#x2F; false\nfather.startsWith(&#39;xixi&#39;) &#x2F;&#x2F; true\n复制代码\n\n\nendsWith：判断字符串是否以某个&#x2F;某串字符结尾：\n\nconst father &#x3D; &#39;xixi haha hehe&#39;\n  father.endsWith(&#39;hehe&#39;) &#x2F;&#x2F; true\n复制代码\n\n（2）自动重复：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：\nconst sourceCode &#x3D; &#39;repeat for 3 times;&#39;\nconst repeated &#x3D; sourceCode.repeat(3) \nconsole.log(repeated) &#x2F;&#x2F; repeat for 3 times;repeat for 3 times;repeat for 3 times;\n复制代码\n\n三、JavaScript基础1. new操作符的实现原理new操作符的执行过程：\n（1）首先创建了一个新的空对象\n（2）设置原型，将对象的原型设置为函数的 prototype 对象。\n（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\n具体实现：\nfunction objectFactory() &#123;\n  let newObject &#x3D; null;\n  let constructor &#x3D; Array.prototype.shift.call(arguments);\n  let result &#x3D; null;\n  &#x2F;&#x2F; 判断参数是否是一个函数\n  if (typeof constructor !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    console.error(&quot;type error&quot;);\n    return;\n  &#125;\n  &#x2F;&#x2F; 新建一个空对象，对象的原型为构造函数的 prototype 对象\n  newObject &#x3D; Object.create(constructor.prototype);\n  &#x2F;&#x2F; 将 this 指向新建对象，并执行函数\n  result &#x3D; constructor.apply(newObject, arguments);\n  &#x2F;&#x2F; 判断返回对象\n  let flag &#x3D; result &amp;&amp; (typeof result &#x3D;&#x3D;&#x3D; &quot;object&quot; || typeof result &#x3D;&#x3D;&#x3D; &quot;function&quot;);\n  &#x2F;&#x2F; 判断返回结果\n  return flag ? result : newObject;\n&#125;\n&#x2F;&#x2F; 使用方法\nobjectFactory(构造函数, 初始化参数);\n复制代码\n\n2. map和Object的区别\n\n\n\nMap\nObject\n\n\n\n意外的键\nMap默认情况不包含任何键，只包含显式插入的键。\nObject 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。\n\n\n键的类型\nMap的键可以是任意值，包括函数、对象或任意基本类型。\nObject 的键必须是 String 或是Symbol。\n\n\n键的顺序\nMap 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。\nObject 的键是无序的\n\n\nSize\nMap 的键值对个数可以轻易地通过size 属性获取\nObject 的键值对个数只能手动计算\n\n\n迭代\nMap 是 iterable 的，所以可以直接被迭代。\n迭代Object需要以某种方式获取它的键然后才能迭代。\n\n\n性能\n在频繁增删键值对的场景下表现更好。\n在频繁添加和删除键值对的场景下未作出优化。\n\n\n3. map和weakMap的区别（1）Map map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。\n实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：\nconst map &#x3D; [\n     [&quot;name&quot;,&quot;张三&quot;],\n     [&quot;age&quot;,18],\n]\n复制代码\n\nMap数据结构有以下操作方法：\n\nsize： map.size 返回Map结构的成员总数。\nset(key,value) ：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）\nget(key) ：该方法读取key对应的键值，如果找不到key，返回undefined。\nhas(key) ：该方法返回一个布尔值，表示某个键是否在当前Map对象中。\ndelete(key) ：该方法删除某个键，返回true，如果删除失败，返回false。\nclear() ：map.clear()清除所有成员，没有返回值。\n\nMap结构原生提供是三个遍历器生成函数和一个遍历方法\n\nkeys()：返回键名的遍历器。\nvalues()：返回键值的遍历器。\nentries()：返回所有成员的遍历器。\nforEach()：遍历Map的所有成员。\n\nconst map &#x3D; new Map([\n     [&quot;foo&quot;,1],\n     [&quot;bar&quot;,2],\n])\nfor(let key of map.keys())&#123;\n    console.log(key);  &#x2F;&#x2F; foo bar\n&#125;\nfor(let value of map.values())&#123;\n     console.log(value); &#x2F;&#x2F; 1 2\n&#125;\nfor(let items of map.entries())&#123;\n    console.log(items);  &#x2F;&#x2F; [&quot;foo&quot;,1]  [&quot;bar&quot;,2]\n&#125;\nmap.forEach( (value,key,map) &#x3D;&gt; &#123;\n     console.log(key,value); &#x2F;&#x2F; foo 1    bar 2\n&#125;)\n复制代码\n\n（2）WeakMap WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。其键必须是对象，原始数据类型不能作为key值，而值可以是任意的。\n该对象也有以下几种方法：\n\nset(key,value) ：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）\nget(key) ：该方法读取key对应的键值，如果找不到key，返回undefined。\nhas(key) ：该方法返回一个布尔值，表示某个键是否在当前Map对象中。\ndelete(key) ：该方法删除某个键，返回true，如果删除失败，返回false。\n\n其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。\nWeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。\n而WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。\n总结：\n\nMap 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\nWeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。\n\n4. JavaScript有哪些内置对象全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在 全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。\n标准内置对象的分类：\n（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量\n（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等\n（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等\n（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date\n（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp\n（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array\n（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 例如 Map、Set、WeakMap、WeakSet\n（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。 例如 SIMD 等\n（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等\n（10）控制抽象对象 例如 Promise、Generator 等\n（11）反射。例如 Reflect、Proxy\n（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等\n（13）WebAssembly\n（14）其他。例如 arguments\n总结： js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。\n5. 常用的正则表达式有哪些？&#x2F;&#x2F; （1）匹配 16 进制颜色值\nvar regex &#x3D; &#x2F;#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)&#x2F;g;\n\n&#x2F;&#x2F; （2）匹配日期，如 yyyy-mm-dd 格式\nvar regex &#x3D; &#x2F;^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$&#x2F;;\n\n&#x2F;&#x2F; （3）匹配 qq 号\nvar regex &#x3D; &#x2F;^[1-9][0-9]&#123;4,10&#125;$&#x2F;g;\n\n&#x2F;&#x2F; （4）手机号码正则\nvar regex &#x3D; &#x2F;^1[34578]\\d&#123;9&#125;$&#x2F;g;\n\n&#x2F;&#x2F; （5）用户名正则\nvar regex &#x3D; &#x2F;^[a-zA-Z$][a-zA-Z0-9_$]&#123;4,16&#125;$&#x2F;;\n复制代码\n\n6. 对JSON的理解JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。\n在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。\n因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。\n在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，\n\nJSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。\nJSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。\n\n7. JavaScript脚本延迟加载的方式有哪些？延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。\n一般有以下几种方式：\n\ndefer 属性： 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。\nasync 属性： 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。\n动态创建 DOM 方式： 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。\n使用 setTimeout 延迟方法： 设置一个定时器来延迟加载js脚本文件\n让 JS 最后加载： 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。\n\n8. JavaScript 类数组对象的定义？一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。\n常见的类数组转换为数组的方法有这样几种：\n（1）通过 call 调用数组的 slice 方法来实现转换\nArray.prototype.slice.call(arrayLike);\n复制代码\n\n（2）通过 call 调用数组的 splice 方法来实现转换\nArray.prototype.splice.call(arrayLike, 0);\n复制代码\n\n（3）通过 apply 调用数组的 concat 方法来实现转换\nArray.prototype.concat.apply([], arrayLike);\n复制代码\n\n（4）通过 Array.from 方法来实现转换\nArray.from(arrayLike);\n复制代码\n\n9. 数组有哪些原生方法？\n数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\n数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\n数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\n数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\n数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\n数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\n数组归并方法 reduce() 和 reduceRight() 方法\n\n10. Unicode、UTF-8、UTF-16、UTF-32的区别？（1）Unicode在说Unicode之前需要先了解一下ASCII码：ASCII 码（American Standard Code for Information Interchange）称为美国标准信息交换码。\n\n它是基于拉丁字母的一套电脑编码系统。\n它定义了一个用于代表常见字符的字典。\n它包含了”A-Z”(包含大小写)，数据”0-9” 以及一些常见的符号。\n它是专门为英语而设计的，有128个编码，对其他语言无能为力\n\nASCII码可以表示的编码有限，要想表示其他语言的编码，还是要使用Unicode来表示，可以说Unicode是ASCII 的超集。\nUnicode全称 Unicode Translation Format，又叫做统一码、万国码、单一码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。\nUnicode的实现方式（也就是编码方式）有很多种，常见的是UTF-8、UTF-16、UTF-32和USC-2。\n（2）UTF-8UTF-8是使用最广泛的Unicode编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容ASCII码的128个字符。\n注意： UTF-8 是一种编码方式，Unicode是一个字符集合。\nUTF-8的编码规则：\n\n对于单字节的符号，字节的第一位为0，后面的7位为这个字符的Unicode编码，因此对于英文字母，它的Unicode编码和ACSII编码一样。\n对于n字节的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的Unicode码 。\n\n来看一下具体的Unicode编号范围与对应的UTF-8二进制格式 ：\n\n\n\n编码范围（编号对应的十进制数）\n二进制格式\n\n\n\n0x00—0x7F （0-127）\n0xxxxxxx\n\n\n0x80—0x7FF （128-2047）\n110xxxxx 10xxxxxx\n\n\n0x800—0xFFFF  （2048-65535）\n1110xxxx 10xxxxxx 10xxxxxx\n\n\n0x10000—0x10FFFF  （65536以上）\n11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n\n那该如何通过具体的Unicode编码，进行具体的UTF-8编码呢？步骤如下：\n\n找到该Unicode编码的所在的编号范围，进而找到与之对应的二进制格式\n将Unicode编码转换为二进制数（去掉最高位的0）\n将二进制数从右往左一次填入二进制格式的X中，如果有X未填，就设为0\n\n来看一个实际的例子： “马” 字的Unicode编码是：0x9A6C，整数编号是39532 （1）首选确定了该字符在第三个范围内，它的格式是 1110xxxx 10xxxxxx 10xxxxxx （2）39532对应的二进制数为1001 1010 0110 1100 （3）将二进制数填入X中，结果是：11101001 10101001 10101100\n（3）UTF-161. 平面的概念\n在了解UTF-16之前，先看一下平面的概念： Unicode编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放65536（216）个字符，这称为一个平面，目前总共有17 个平面。\n最前面的一个平面称为基本平面，它的码点从0 — 216-1，写成16进制就是U+0000 — U+FFFF，那剩下的16个平面就是辅助平面，码点范围是 U+10000—U+10FFFF。\n2. UTF-16 概念：\nUTF-16也是Unicode编码集的一种编码形式，把Unicode字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。Unicode字符的码位需要1个或者2个16位长的码元来表示，因此UTF-16也是用变长字节表示的。\n3. UTF-16 编码规则：\n\n编号在 U+0000—U+FFFF 的字符（常用字符集），直接用两个字节表示。\n编号在 U+10000—U+10FFFF 之间的字符，需要用四个字节表示。\n\n4. 编码识别\n那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？\nUTF-16 编码肯定也考虑到了这个问题，在基本平面内，从 U+D800 — U+DFFF 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。\n辅助平面共有 220 个字符位，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 — U+DBFF，称为高位（H），后 10 位映射在 U+DC00 — U+DFFF，称为低位（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。\n因此，当遇到两个字节时，发现它的码点在 U+D800 —U+DBFF之间，就可以知道，它后面的两个字节的码点应该在 U+DC00 — U+DFFF 之间，这四个字节必须放在一起进行解读。\n5. 举例说明\n以 “𡠀“ 字为例，它的 Unicode 码点为 0x21800，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：\n\n首先计算超出部分的结果：0x21800 - 0x10000\n将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：0001000110 0000000000\n将得到的两个10位二进制数分别对应到两个区间中\nU+D800 对应的二进制数为 1101100000000000， 将0001000110填充在它的后10 个二进制位，得到 1101100001000110，转成 16 进制数为 0xD846。同理，低位为 0xDC00，所以这个字的UTF-16 编码为 0xD846 0xDC00\n\n（4） UTF-32UTF-32 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。\n比如“马” 字的Unicode编号是：U+9A6C，整数编号是39532，直接转化为二进制：1001 1010 0110 1100，这就是它的UTF-32编码。\n（5）总结Unicode、UTF-8、UTF-16、UTF-32有什么区别？\n\nUnicode 是编码字符集（字符集），而UTF-8、UTF-16、UTF-32是字符集编码（编码规则）；\nUTF-16 使用变长码元序列的编码方式，相较于定长码元序列的UTF-32算法更复杂，甚至比同样是变长码元序列的UTF-8也更为复杂，因为其引入了独特的代理对这样的代理机制；\nUTF-8需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而UTF-16不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；\n如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用UTF-8就比UTF-16节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么UTF-16就占优势了，可以节省很多空间；\n\n11. 常见的位运算符有哪些？其计算规则是什么？现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。\n常见的位运算有以下几种：\n\n\n\n运算符\n描述\n运算规则\n\n\n\n\n&amp;\n与\n两个位都为1时，结果才为1\n\n\n\n&#96;\n&#96;\n或\n两个位都为0时，结果才为0\n\n\n^\n异或\n两个位相同为0，相异为1\n\n\n\n~\n取反\n0变1，1变0\n\n\n\n&lt;&lt;\n左移\n各二进制位全部左移若干位，高位丢弃，低位补0\n\n\n\n&gt;&gt;\n右移\n各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃\n\n\n\n1. 按位与运算符（&amp;）定义： 参加运算的两个数据按二进制位进行“与”运算。 运算规则：\n0 &amp; 0 &#x3D; 0  \n0 &amp; 1 &#x3D; 0  \n1 &amp; 0 &#x3D; 0  \n1 &amp; 1 &#x3D; 1\n复制代码\n\n总结：两位同时为1，结果才为1，否则结果为0。 例如：3&amp;5 即：\n0000 0011 \n   0000 0101 \n &#x3D; 0000 0001\n复制代码\n\n因此 3&amp;5 的值为1。 注意：负数按补码形式参加按位与运算。\n用途：\n（1）判断奇偶\n只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((i &amp; 1) == 0)代替if (i % 2 == 0)来判断a是不是偶数。\n（2）清零\n如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。\n2. 按位或运算符（|）定义： 参加运算的两个对象按二进制位进行“或”运算。\n运算规则：\n0 | 0 &#x3D; 0\n0 | 1 &#x3D; 1  \n1 | 0 &#x3D; 1  \n1 | 1 &#x3D; 1\n复制代码\n\n总结：参加运算的两个对象只要有一个为1，其值为1。 例如：3|5即：\n0000 0011\n  0000 0101 \n&#x3D; 0000 0111\n复制代码\n\n因此，3|5的值为7。 注意：负数按补码形式参加按位或运算。\n3. 异或运算符（^）定义： 参加运算的两个数据按二进制位进行“异或”运算。\n运算规则：\n0 ^ 0 &#x3D; 0  \n0 ^ 1 &#x3D; 1  \n1 ^ 0 &#x3D; 1  \n1 ^ 1 &#x3D; 0\n复制代码\n\n总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。 例如：3|5即：\n0000 0011\n  0000 0101 \n&#x3D; 0000 0110\n复制代码\n\n因此，3^5的值为6。 异或运算的性质:\n\n交换律：(a^b)^c == a^(b^c)\n结合律：(a + b)^c == a^b + b^c\n对于任何数x，都有 x^x=0，x^0=x\n自反性: a^b^b=a^0=a;\n\n4. 取反运算符 (~)定义： 参加运算的一个数据按二进制进行“取反”运算。\n运算规则：\n~ 1 &#x3D; 0~ 0 &#x3D; 1\n复制代码\n\n总结：对一个二进制数按位取反，即将0变1，1变0。 例如：~6 即：\n0000 0110&#x3D; 1111 1001\n复制代码\n\n在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。 当发现按位取反为负数时，就直接取其补码，变为十进制：\n0000 0110   &#x3D; 1111 1001反码：1000 0110补码：1000 0111\n复制代码\n\n因此，~6的值为-7。\n5. 左移运算符（&lt;&lt;）定义： 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。 设 a&#x3D;1010 1110，a &#x3D; a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a&#x3D;1011 1000。 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。\n6. 右移运算符（&gt;&gt;）定义： 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 例如：a&#x3D;a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。 操作数每右移一位，相当于该数除以2。\n7. 原码、补码、反码上面提到了补码、反码等知识，这里就补充一下。 计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。\n（1）原码\n原码就是一个数的二进制数。例如：10的原码为0000 1010\n（2）反码\n\n正数的反码与原码相同，如：10 反码为 0000 1010\n负数的反码为除符号位，按位取反，即0变1，1变0。\n\n例如：-10\n原码：1000 1010\n反码：1111 0101\n复制代码\n\n（3）补码\n\n正数的补码与原码相同，如：10 补码为 0000 1010\n负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。\n\n例如：-10\n原码：1000 1010\n反码：1111 0101\n补码：1111 0110\n复制代码\n\n12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?arguments是一个对象，它的属性是从 0 开始依次递增的数字，还有callee和length等属性，与数组相似；但是它却没有数组常见的方法属性，如forEach, reduce等，所以叫它们类数组。\n要遍历类数组，有三个方法：\n（1）将数组的方法应用到类数组上，这时候就可以使用call和apply方法，如：\nfunction foo()&#123; \n  Array.prototype.forEach.call(arguments, a &#x3D;&gt; console.log(a))\n&#125;\n复制代码\n\n（2）使用Array.from方法将类数组转化成数组：‌\nfunction foo()&#123; \n  const arrArgs &#x3D; Array.from(arguments) \n  arrArgs.forEach(a &#x3D;&gt; console.log(a))\n&#125;\n复制代码\n\n（3）使用展开运算符将类数组转化成数组\nfunction foo()&#123; \n    const arrArgs &#x3D; [...arguments] \n    arrArgs.forEach(a &#x3D;&gt; console.log(a)) \n&#125;\n复制代码\n\n13. 什么是 DOM 和 BOM？\nDOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。\nBOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。\n\n14. 对类数组对象的理解，如何转化为数组一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。\n常见的类数组转换为数组的方法有这样几种：\n\n通过 call 调用数组的 slice 方法来实现转换\n\nArray.prototype.slice.call(arrayLike);\n复制代码\n\n\n通过 call 调用数组的 splice 方法来实现转换\n\nArray.prototype.splice.call(arrayLike, 0);\n复制代码\n\n\n通过 apply 调用数组的 concat 方法来实现转换\n\nArray.prototype.concat.apply([], arrayLike);\n复制代码\n\n\n通过 Array.from 方法来实现转换\n\nArray.from(arrayLike);\n复制代码\n\n15. escape、encodeURI、encodeURIComponent 的区别\nencodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。\nencodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。\nescape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。\n\n16. 对AJAX的理解，实现一个AJAX请求AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。\n创建AJAX请求的步骤：\n\n创建一个 XMLHttpRequest 对象。\n在这个对象上使用 open 方法创建一个 HTTP 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。\n在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。\n当对象的属性和监听函数设置完成后，最后调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。\n\nconst SERVER_URL &#x3D; &quot;&#x2F;server&quot;;\nlet xhr &#x3D; new XMLHttpRequest();\n&#x2F;&#x2F; 创建 Http 请求\nxhr.open(&quot;GET&quot;, url, true);\n&#x2F;&#x2F; 设置状态监听函数\nxhr.onreadystatechange &#x3D; function() &#123;\n  if (this.readyState !&#x3D;&#x3D; 4) return;\n  &#x2F;&#x2F; 当请求成功时\n  if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n    handle(this.response);\n  &#125; else &#123;\n    console.error(this.statusText);\n  &#125;\n&#125;;\n&#x2F;&#x2F; 设置请求失败时的监听函数\nxhr.onerror &#x3D; function() &#123;\n  console.error(this.statusText);\n&#125;;\n&#x2F;&#x2F; 设置请求头信息\nxhr.responseType &#x3D; &quot;json&quot;;\nxhr.setRequestHeader(&quot;Accept&quot;, &quot;application&#x2F;json&quot;);\n&#x2F;&#x2F; 发送 Http 请求\nxhr.send(null);\n复制代码\n\n使用Promise封装AJAX：\n&#x2F;&#x2F; promise 封装实现：\nfunction getJSON(url) &#123;\n  &#x2F;&#x2F; 创建一个 promise 对象\n  let promise &#x3D; new Promise(function(resolve, reject) &#123;\n    let xhr &#x3D; new XMLHttpRequest();\n    &#x2F;&#x2F; 新建一个 http 请求\n    xhr.open(&quot;GET&quot;, url, true);\n    &#x2F;&#x2F; 设置状态的监听函数\n    xhr.onreadystatechange &#x3D; function() &#123;\n      if (this.readyState !&#x3D;&#x3D; 4) return;\n      &#x2F;&#x2F; 当请求成功或失败时，改变 promise 的状态\n      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n        resolve(this.response);\n      &#125; else &#123;\n        reject(new Error(this.statusText));\n      &#125;\n    &#125;;\n    &#x2F;&#x2F; 设置错误监听函数\n    xhr.onerror &#x3D; function() &#123;\n      reject(new Error(this.statusText));\n    &#125;;\n    &#x2F;&#x2F; 设置响应的数据类型\n    xhr.responseType &#x3D; &quot;json&quot;;\n    &#x2F;&#x2F; 设置请求头信息\n    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application&#x2F;json&quot;);\n    &#x2F;&#x2F; 发送 http 请求\n    xhr.send(null);\n  &#125;);\n  return promise;\n&#125;\n复制代码\n\n17. JavaScript为什么要进行变量提升，它导致了什么问题？变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。\n造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。\n首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。\n\n在解析阶段，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。\n\n全局上下文：变量定义，函数声明\n函数上下文：变量定义，函数声明，this，arguments\n\n\n在执行阶段，就是按照代码的顺序依次执行。\n\n\n那为什么会进行变量提升呢？主要有以下两个原因：\n\n提高性能\n容错性更好\n\n（1）提高性能 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。\n在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。\n（2）容错性更好\n变量提升可以在一定程度上提高JS的容错性，看下面的代码：\na &#x3D; 1;var a;console.log(a);\n复制代码\n\n如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。\n虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。\n总结：\n\n解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间\n声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行\n\n变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：\nvar tmp &#x3D; new Date();\n\nfunction fn()&#123;\n\tconsole.log(tmp);\n\tif(false)&#123;\n\t\tvar tmp &#x3D; &#39;hello world&#39;;\n\t&#125;\n&#125;\n\nfn();  &#x2F;&#x2F; undefined\n复制代码\n\n在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。\nvar tmp &#x3D; &#39;hello world&#39;;\n\nfor (var i &#x3D; 0; i &lt; tmp.length; i++) &#123;\n\tconsole.log(tmp[i]);\n&#125;\n\nconsole.log(i); &#x2F;&#x2F; 11\n复制代码\n\n由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。\n18. 什么是尾调用，使用尾调用有什么好处？尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。\n19. ES6模块与CommonJS模块有什么异同？ES6 Module和CommonJS模块的区别：\n\nCommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；\nimport的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。\n\nES6 Module和CommonJS模块的共同点：\n\nCommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。\n\n20. 常见的DOM操作有哪些1）DOM 节点的获取DOM 节点的获取的API及使用：\ngetElementById &#x2F;&#x2F; 按照 id 查询\ngetElementsByTagName &#x2F;&#x2F; 按照标签名查询\ngetElementsByClassName &#x2F;&#x2F; 按照类名查询\nquerySelectorAll &#x2F;&#x2F; 按照 css 选择器查询\n\n&#x2F;&#x2F; 按照 id 查询\nvar imooc &#x3D; document.getElementById(&#39;imooc&#39;) &#x2F;&#x2F; 查询到 id 为 imooc 的元素\n&#x2F;&#x2F; 按照标签名查询\nvar pList &#x3D; document.getElementsByTagName(&#39;p&#39;)  &#x2F;&#x2F; 查询到标签为 p 的集合\nconsole.log(divList.length)\nconsole.log(divList[0])\n&#x2F;&#x2F; 按照类名查询\nvar moocList &#x3D; document.getElementsByClassName(&#39;mooc&#39;) &#x2F;&#x2F; 查询到类名为 mooc 的集合\n&#x2F;&#x2F; 按照 css 选择器查询\nvar pList &#x3D; document.querySelectorAll(&#39;.mooc&#39;) &#x2F;&#x2F; 查询到类名为 mooc 的集合\n复制代码\n\n2）DOM 节点的创建创建一个新节点，并把它添加到指定节点的后面。 已知的 HTML 结构如下：\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;DEMO&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;container&quot;&gt; \n      &lt;h1 id&#x3D;&quot;title&quot;&gt;我是标题&lt;&#x2F;h1&gt;\n    &lt;&#x2F;div&gt;   \n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n复制代码\n\n要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：\n&#x2F;&#x2F; 首先获取父节点\nvar container &#x3D; document.getElementById(&#39;container&#39;)\n&#x2F;&#x2F; 创建新节点\nvar targetSpan &#x3D; document.createElement(&#39;span&#39;)\n&#x2F;&#x2F; 设置 span 节点的内容\ntargetSpan.innerHTML &#x3D; &#39;hello world&#39;\n&#x2F;&#x2F; 把新创建的元素塞进父节点里去\ncontainer.appendChild(targetSpan)\n复制代码\n\n3）DOM 节点的删除删除指定的 DOM 节点， 已知的 HTML 结构如下：\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;DEMO&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;container&quot;&gt; \n      &lt;h1 id&#x3D;&quot;title&quot;&gt;我是标题&lt;&#x2F;h1&gt;\n    &lt;&#x2F;div&gt;   \n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n复制代码\n\n需要删除 id 为 title 的元素，做法是：\n&#x2F;&#x2F; 获取目标元素的父元素\nvar container &#x3D; document.getElementById(&#39;container&#39;)\n&#x2F;&#x2F; 获取目标元素\nvar targetNode &#x3D; document.getElementById(&#39;title&#39;)\n&#x2F;&#x2F; 删除目标元素\ncontainer.removeChild(targetNode)\n复制代码\n\n或者通过子节点数组来完成删除：\n&#x2F;&#x2F; 获取目标元素的父元素var container &#x3D; document.getElementById(&#39;container&#39;)&#x2F;&#x2F; 获取目标元素var targetNode &#x3D; container.childNodes[1]&#x2F;&#x2F; 删除目标元素container.removeChild(targetNode)\n复制代码\n\n4）修改 DOM 元素修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。\n将指定的两个 DOM 元素交换位置， 已知的 HTML 结构如下：\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;DEMO&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;container&quot;&gt; \n      &lt;h1 id&#x3D;&quot;title&quot;&gt;我是标题&lt;&#x2F;h1&gt;\n      &lt;p id&#x3D;&quot;content&quot;&gt;我是内容&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;   \n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n复制代码\n\n现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：\n&#x2F;&#x2F; 获取父元素\nvar container &#x3D; document.getElementById(&#39;container&#39;)   \n \n&#x2F;&#x2F; 获取两个需要被交换的元素\nvar title &#x3D; document.getElementById(&#39;title&#39;)\nvar content &#x3D; document.getElementById(&#39;content&#39;)\n&#x2F;&#x2F; 交换两个元素，把 content 置于 title 前面\ncontainer.insertBefore(content, title)\n复制代码\n\n21. use strict是什么意思 ? 使用它区别是什么？use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：\n\n消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;\n消除代码运行的不安全之处，保证代码运行的安全；\n提高编译器效率，增加运行速度；\n为未来新版本的 Javascript 做好铺垫。\n\n区别：\n\n禁止使用 with 语句。\n禁止 this 关键字指向全局对象。\n对象不能有重名的属性。\n\n22. 如何判断一个对象是否属于某个类？\n第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。\n第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。\n第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。\n\n23. 强类型语言和弱类型语言的区别\n强类型语言：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。\n弱类型语言：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串’12’和整数3进行连接得到字符串’123’，在相加的时候会进行强制类型转换。\n\n两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。\n24. 解释性语言和编译型语言的区别（1）解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下\n\n解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；\n只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；\nJavaScript、Python等属于解释型语言。\n\n（2）编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：\n\n一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；\n与特定平台相关，一般无法移植到其他平台；\nC、C++等属于编译型语言。\n\n两者主要区别在于： 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。\n25. for…in和for…of的区别for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下\n\nfor…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；\nfor… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；\n对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；\n\n总结： for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。\n26. 如何使用for…of遍历对象for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。\n如果需要遍历的对象是类数组对象，用Array.from转成数组即可。\nvar obj &#x3D; &#123;\n    0:&#39;one&#39;,\n    1:&#39;two&#39;,\n    length: 2\n&#125;;\nobj &#x3D; Array.from(obj);\nfor(var k of obj)&#123;\n    console.log(k)\n&#125;\n复制代码\n\n如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。\n&#x2F;&#x2F;方法一：\nvar obj &#x3D; &#123;\n    a:1,\n    b:2,\n    c:3\n&#125;;\n\nobj[Symbol.iterator] &#x3D; function()&#123;\n\tvar keys &#x3D; Object.keys(this);\n\tvar count &#x3D; 0;\n\treturn &#123;\n\t\tnext()&#123;\n\t\t\tif(count&lt;keys.length)&#123;\n\t\t\t\treturn &#123;value: obj[keys[count++]],done:false&#125;;\n\t\t\t&#125;else&#123;\n\t\t\t\treturn &#123;value:undefined,done:true&#125;;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;;\n\nfor(var k of obj)&#123;\n\tconsole.log(k);\n&#125;\n\n\n&#x2F;&#x2F; 方法二\nvar obj &#x3D; &#123;\n    a:1,\n    b:2,\n    c:3\n&#125;;\nobj[Symbol.iterator] &#x3D; function*()&#123;\n    var keys &#x3D; Object.keys(obj);\n    for(var k of keys)&#123;\n        yield [k,obj[k]]\n    &#125;\n&#125;;\n\nfor(var [k,v] of obj)&#123;\n    console.log(k,v);\n&#125;\n\n复制代码\n\n27. ajax、axios、fetch的区别（1）AJAX Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：\n\n本身是针对MVC编程，不符合前端MVVM的浪潮\n基于原生XHR开发，XHR本身的架构不清晰\n不符合关注分离（Separation of Concerns）的原则\n配置和调用方式非常混乱，而且基于事件的异步模型不友好。\n\n（2）Fetch fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。\nfetch的优点：\n\n语法简洁，更加语义化\n基于标准 Promise 实现，支持 async&#x2F;await\n更加底层，提供的API丰富（request, response）\n脱离了XHR，是ES规范里新的实现方式\n\nfetch的缺点：\n\nfetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。\nfetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})\nfetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费\nfetch没有办法原生监测请求的进度，而XHR可以\n\n（3）Axios Axios 是一种基于Promise封装的HTTP客户端，其特点如下：\n\n浏览器端发起XMLHttpRequests请求\nnode端发起http请求\n支持Promise API\n监听请求和返回\n对请求和返回进行转化\n取消请求\n自动转换json数据\n客户端支持抵御XSRF攻击\n\n28. 数组的遍历方法有哪些\n\n\n方法\n是否改变原数组\n特点\n\n\n\nforEach()\n否\n数组方法，不改变原数组，没有返回值\n\n\nmap()\n否\n数组方法，不改变原数组，有返回值，可链式调用\n\n\nfilter()\n否\n数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用\n\n\nfor…of\n否\nfor…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环\n\n\nevery() 和 some()\n否\n数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.\n\n\nfind() 和 findIndex()\n否\n数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值\n\n\nreduce() 和 reduceRight()\n否\n数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作\n\n\n遍历方法的详细解释：《细数JavaScript中那些遍历和循环》\n29. forEach和map方法有什么区别这方法都是用来遍历数组的，两者区别如下：\n\nforEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；\nmap()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；\n\n四、原型与原型链1. 对原型、原型链的理解在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。\n当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。\n特点： JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。 \n2. 原型修改、重写function Person(name) &#123;\n    this.name &#x3D; name\n&#125;\n&#x2F;&#x2F; 修改原型\nPerson.prototype.getName &#x3D; function() &#123;&#125;\nvar p &#x3D; new Person(&#39;hello&#39;)\nconsole.log(p.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype) &#x2F;&#x2F; true\nconsole.log(p.__proto__ &#x3D;&#x3D;&#x3D; p.constructor.prototype) &#x2F;&#x2F; true\n&#x2F;&#x2F; 重写原型\nPerson.prototype &#x3D; &#123;\n    getName: function() &#123;&#125;\n&#125;\nvar p &#x3D; new Person(&#39;hello&#39;)\nconsole.log(p.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype)        &#x2F;&#x2F; true\nconsole.log(p.__proto__ &#x3D;&#x3D;&#x3D; p.constructor.prototype) &#x2F;&#x2F; false\n复制代码\n\n可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候p.constructor === Object ，而不是p.constructor === Person。要想成立，就要用constructor指回来：\nPerson.prototype &#x3D; &#123;\n    getName: function() &#123;&#125;\n&#125;\nvar p &#x3D; new Person(&#39;hello&#39;)\np.constructor &#x3D; Person\nconsole.log(p.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype)        &#x2F;&#x2F; true\nconsole.log(p.__proto__ &#x3D;&#x3D;&#x3D; p.constructor.prototype) &#x2F;&#x2F; true\n\n复制代码\n\n3. 原型链指向p.__proto__  &#x2F;&#x2F; Person.prototype\nPerson.prototype.__proto__  &#x2F;&#x2F; Object.prototype\np.__proto__.__proto__ &#x2F;&#x2F;Object.prototype\np.__proto__.constructor.prototype.__proto__ &#x2F;&#x2F; Object.prototype\nPerson.prototype.constructor.prototype.__proto__ &#x2F;&#x2F; Object.prototype\np1.__proto__.constructor &#x2F;&#x2F; Person\nPerson.prototype.constructor  &#x2F;&#x2F; Person\n复制代码\n\n4. 原型链的终点是什么？如何打印出原型链的终点？由于Object是构造函数，原型链终点是Object.prototype.__proto__，而Object.prototype.__proto__=== null // true，所以，原型链的终点是null。原型链上的所有原型都是对象，所有的对象最终都是由Object构造的，而Object.prototype的下一级是Object.prototype.__proto__。 \n5. 如何获得对象非原型链上的属性？使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：\nfunction iterate(obj)&#123;\n   var res&#x3D;[];\n   for(var key in obj)&#123;\n        if(obj.hasOwnProperty(key))\n           res.push(key+&#39;: &#39;+obj[key]);\n   &#125;\n   return res;\n&#125; \n复制代码\n\n五、执行上下文&#x2F;作用域链&#x2F;闭包1. 对闭包的理解闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。\n闭包有两个常用的用途；\n\n闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n\n比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。\nfunction A() &#123;\n  let a &#x3D; 1\n  window.B &#x3D; function () &#123;\n      console.log(a)\n  &#125;\n&#125;\nA()\nB() &#x2F;&#x2F; 1\n复制代码\n\n在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题\nfor (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;\n  setTimeout(function timer() &#123;\n    console.log(i)\n  &#125;, i * 1000)\n&#125;\n复制代码\n\n首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法有三种：\n\n第一种是使用闭包的方式\n\nfor (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;  ;(function(j) &#123;    setTimeout(function timer() &#123;      console.log(j)    &#125;, j * 1000)  &#125;)(i)&#125;\n复制代码\n\n在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。\n\n第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。\n\nfor (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;\n  setTimeout(\n    function timer(j) &#123;\n      console.log(j)\n    &#125;,\n    i * 1000,\n    i\n  )\n&#125;\n复制代码\n\n\n第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式\n\nfor (let i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;\n  setTimeout(function timer() &#123;\n    console.log(i)\n  &#125;, i * 1000)\n&#125;\n复制代码\n\n2. 对作用域、作用域链的理解1）全局作用域和函数作用域（1）全局作用域\n\n最外层函数和最外层函数外面定义的变量拥有全局作用域\n所有未定义直接赋值的变量自动声明为全局作用域\n所有window对象的属性拥有全局作用域\n全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。\n\n（2）函数作用域\n\n函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到\n作用域是分层的，内层作用域可以访问外层作用域，反之不行\n\n2）块级作用域\n使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由&#123; &#125;包裹的代码片段）\nlet和const声明的变量不会有变量提升，也不可以重复声明\n在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。\n\n作用域链： 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。\n作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。\n作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。\n当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。\n3. 对执行上下文的理解1. 执行上下文类型（1）全局执行上下文\n任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。\n（2）函数执行上下文\n当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。\n（3） eval函数执行上下文\n执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。\n2. 执行上下文栈\nJavaScript引擎使用执行上下文栈来管理执行上下文\n当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。\n\nlet a &#x3D; &#39;Hello World!&#39;;\nfunction first() &#123;\n  console.log(&#39;Inside first function&#39;);\n  second();\n  console.log(&#39;Again inside first function&#39;);\n&#125;\nfunction second() &#123;\n  console.log(&#39;Inside second function&#39;);\n&#125;\nfirst();\n&#x2F;&#x2F;执行顺序\n&#x2F;&#x2F;先执行second(),在执行first()\n复制代码\n\n3. 创建执行上下文创建执行上下文有两个阶段：创建阶段和执行阶段\n1）创建阶段\n（1）this绑定\n\n在全局执行上下文中，this指向全局对象（window对象）\n在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined\n\n（2）创建词法环境组件\n\n词法环境是一种有标识符——变量映射的数据结构，标识符是指变量&#x2F;函数名，变量是对实际对象或原始数据的引用。\n词法环境的内部有两个组件：加粗样式：环境记录器:用来储存变量个函数声明的实际位置外部环境的引用：可以访问父级作用域\n\n（3）创建变量环境组件\n\n变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。\n\n2）执行阶段 此阶段会完成对变量的分配，最后执行完代码。\n简单来说执行上下文就是指：\n在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。\n在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。\n\n全局上下文：变量定义，函数声明\n函数上下文：变量定义，函数声明，this，arguments\n\n","slug":"面试题笔记——JS篇(上)","date":"2021-06-20T02:11:19.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"},{"id":"2df08f9dfbf634c7c80b135bee82ec73","title":"面试题笔记——CSS篇","content":"\nCSS选择器及其优先级\n\n\n\n\n选择器\n格式\n优先级权重\n\n\n\nid选择器\n#id\n100\n\n\n类选择器\n.classname\n10\n\n\n属性选择器\na[ref&#x3D;“eee”]\n10\n\n\n伪类选择器\nli:last-child\n10\n\n\n标签选择器\ndiv\n1\n\n\n伪元素选择器\nli:after\n1\n\n\n相邻兄弟选择器\nh1+p\n0\n\n\n子选择器\nul&gt;li\n0\n\n\n后代选择器\nli a\n0\n\n\n通配符选择器\n*\n0\n\n\n对于选择器的优先级：●标签选择器、伪元素选择器：1；●类选择器、伪类选择器、属性选择器：10；●id 选择器：100；●内联样式：1000；  \n注意事项：●!important声明的样式的优先级最高；●如果优先级相同，则最后出现的样式生效；●继承得到的样式的优先级最低；●通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；●样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。2. CSS中可继承与不可继承属性有哪些一、无继承性的属性1display：规定元素应该生成的框的类型2文本属性：●vertical-align：垂直文本对齐●text-decoration：规定添加到文本的装饰●text-shadow：文本阴影效果●white-space：空白符的处理●unicode-bidi：设置文本的方向3盒子模型的属性：width、height、margin、border、padding4背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment5定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index6生成内容属性：content、counter-reset、counter-increment7轮廓样式属性：outline-style、outline-width、outline-color、outline8页面样式属性：size、page-break-before、page-break-after9声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during  \n二、有继承性的属性1字体系列属性●font-family：字体系列●font-weight：字体的粗细●font-size：字体的大小●font-style：字体的风格2文本系列属性●text-indent：文本缩进●text-align：文本水平对齐●line-height：行高●word-spacing：单词之间的间距●letter-spacing：中文或者字母之间的间距●text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）●color：文本颜色3元素可见性●visibility：控制元素显示隐藏4列表布局属性●list-style：列表风格，包括list-style-type、list-style-image等5光标属性●cursor：光标显示为何种形态3. display的属性值及其作用  \n\n\n\n属性值\n作用\n\n\n\nnone\n元素不显示，并且会从文档流中移除。\n\n\nblock\n块类型。默认宽度为父元素宽度，可设置宽高，换行显示。\n\n\ninline\n行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。\n\n\ninline-block\n默认宽度为内容宽度，可以设置宽高，同行显示。\n\n\nlist-item\n像块类型元素一样显示，并添加样式列表标记。\n\n\ntable\n此元素会作为块级表格来显示。\n\n\ninherit\n规定应该从父元素继承display属性的值。\n\n\n\ndisplay的block、inline和inline-block的区别　（1）block：会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；　（2）inline：元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；　（3）inline-block：将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。\n\n对于行内元素和块级元素，其特点如下：（1）行内元素●设置宽高无效；●可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；●不会自动换行；（2）块级元素●可以设置宽高；●设置margin和padding都有效；●可以自动换行；●多个块状，默认排列从上到下。5. 隐藏元素的方法有哪些●display: none：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。●visibility: hidden：元素在页面中仍占据空间，但是不会响应绑定的监听事件。●opacity: 0：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。●position: absolute：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。●z-index: 负值：来使其他元素遮盖住该元素，以此来实现隐藏。●clip&#x2F;clip-path ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。●transform: scale(0,0)：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。6. link和@import的区别两者都是外部引用CSS的方式，它们的区别如下：●link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。●link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。●link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。●link支持使用Javascript控制DOM去改变样式；而@import不支持。7. transition和animation的区别●transition是过渡属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。●animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。8. display:none与visibility:hidden的区别这两个属性都是让元素隐藏，不可见。两者区别如下：（1）在渲染树中●display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；●visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。（2）是否是继承属性●display:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；●visibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示；（3）修改常规文档流中元素的 display 通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘；（4）如果使用读屏器，设置为display:none的内容不会被读取，设置为visibility:hidden的内容会被读取。9. 伪元素和伪类的区别和作用？●伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：●伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：总结：伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。10. 对requestAnimationframe的理解实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是请求动画帧。  \nMDN对该方法的描述：window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。  \n语法： window.requestAnimationFrame(callback); 其中，callback是下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于宏任务，所以会在执行完微任务之后再去执行。  \n取消动画：使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。  \n优势：●CPU节能：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。●函数节流：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。●减少DOM操作：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。  \nsetTimeout执行动画的缺点：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：●settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；●settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。11. 对盒模型的理解CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型  \n\n\n盒模型都是由四个部分组成的，分别是margin、border、padding和content。  \n标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：●标准盒模型的width和height属性的范围只包含了content，●IE盒模型的width和height属性的范围包含了border、padding和content。  \n可以通过修改元素的box-sizing属性来改变元素的盒模型：●box-sizing: content-box表示标准盒模型（默认值）●box-sizing: border-box表示IE盒模型（怪异盒模型）12. 为什么有时候⽤translate来改变位置⽽不是定位？translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个 li 放在一行，这导致 li 换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。  \n解决办法：（1）为 li 设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。（2）将所有 li 写在同一行。不足：代码不美观。（3）将 ul 内的字符尺寸直接设为0，即font-size:0。不足： ul 中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。（4）消除 ul 的字符间隔letter-spacing:-8px，不足：这也设置了 li 内的字符间隔，因此需要将 li 内的字符间隔设为默认letter-spacing:normal。14. CSS3中有哪些新特性●新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）●圆角 （border-radius:8px）●多列布局 （multi-column layout）●阴影和反射 （Shadoweflect）●文字特效 （text-shadow）●文字渲染 （Text-decoration）●线性渐变 （gradient）●旋转 （transform）●增加了旋转,缩放,定位,倾斜,动画,多背景15. 替换元素的概念及计算规则通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。  \n替换元素除了内容可替换这一特性以外，还有以下特性：●内容的外观不受页面上的CSS的影响：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。●有自己的尺寸：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如●在很多CSS属性上有自己的一套表现规则：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。●所有的替换元素都是内联水平元素：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。  \n替换元素的尺寸从内而外分为三类：●固有尺寸： 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。●HTML尺寸： 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。●CSS尺寸： 特指可以通过CSS的width和height或者max-width&#x2F;min-width和max-height&#x2F;min-height设置的尺寸，对应盒尺寸中的content box。  \n这三层结构的计算规则具体如下：（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。16. 常见的图片格式及使用场景（1）BMP，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。  \n（2）GIF是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。  \n（3）JPEG是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。  \n（4）PNG-8是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。  \n（5）PNG-24是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。  \n（6）SVG是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。  \n（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。●在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；●在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；●WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。17. 对 CSSSprites 的理解CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。  \n优点：●利用CSS Sprites能很好地减少网页的http请求，从而大大提高了页面的性能，这是CSS Sprites最大的优点；●CSS Sprites能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。  \n缺点：●在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；●CSSSprites在开发的时候相对来说有点麻烦，需要借助photoshop或其他工具来对每个背景单元测量其准确的位置。●维护方面：CSS Sprites在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的CSS，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动CSS。18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；  \n而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242&#x2F;414&#x3D;3，也就是说，在单边上，一个逻辑像素&#x3D;3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。  \n对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。  \n\n当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。  \n还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:  \n&#123;\n\n    my-image &#123; background: (low.png); &#125;\n\n    @media only screen and (min-device-pixel-ratio: 1.5) &#123;\n\n    #my-image &#123; background: (high.png); &#125;\n\n&#125;\n\n\nmargin 和 padding 的使用场景●需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；●需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。  \n对line-height 的理解及其赋值方式（1）line-height的概念：●line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；●如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；●一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；●把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；●line-height 和 height 都能撑开一个高度；（2）line-height 的赋值方式：●带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高●纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 &#x3D; 27px●百分比：将计算后的值传递给后代\n\n","slug":"面试题笔记——CSS篇","date":"2021-06-18T09:11:19.000Z","categories_index":"","tags_index":"","author_index":"Beastrong"}]